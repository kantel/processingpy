<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="J√∂rg Kantel">
  <title>Processing.py in Beispielen</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="css/tufte.css">
  <link rel="stylesheet" href="css/user.css">
</head>
<body>
<header>
<h1 class="title">Processing.py in Beispielen</h1>
<h1 class="subtitle">Visualisierungen und interaktive Anwendungen mit Python und Processing programmieren</h1>
<h2 class="author">J√∂rg Kantel</h2>
</header>
<h1 id="einleitung">Einleitung</h1>
<h1 id="download-und-installation">Download und Installation</h1>
<h1 id="jep-just-enough-python-gerade-genug-python">JEP: Just Enough Python (Gerade genug Python)</h1>
<h1 id="start-rotk√§ppchen-und-die-drei-tanten">Start: Rotk√§ppchen und die drei Tanten</h1>
<p>Rotk√§ppchen hat nicht nur eine Gro√ümutter, sondern -- was weniger bekannt ist -- auch drei Tanten, Agathe, Beatrice und Cynthia. Diese wohnen in drei H√§usern, die zusammen ein Dreieck bilden. Wenn Rotk√§ppchen nicht ihre Gro√ümutter besucht, dann besucht sie eine der drei Tanten. Letzten Sonntag jedoch war sie sehr unschl√ºssig, welche sie besuchen sollte. Sie startete, um Agathe einen Besuch abzustatten. Jedoch genau auf dem halben Weg zu Agathe wurde sie unsicher und √ºberlegte es sich noch einmal. Sie beschlo√ü, eine ihrer drei Tanten aufzusuchen, es k√∂nnte auch wieder Agathe gewesen sein. Doch es war wie verhext: Jedesmal, wenn sie genau den halben Weg zur√ºckgelegt hatte, wurde sie wieder unsicher und entschlo√ü sich neu, einer ihrer drei Tanten aufzusuchen, m√∂glicherweise die gleiche, m√∂glicherweise eine andere. Und das wieder, und wieder, und wieder ‚Ä¶</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32442344526/"><img src="images/sierpinskidreieck.jpg" alt="Screenshot" /></a></p>
<p><em>William P. Beuamont</em> [Beaum1996] nannte es das ¬ªTantenspiel¬´. Ziel ist es nicht, herauszufinden, welche Tante gewinnt (es kann gar keine gewinnen), sondern welche Figur entsteht, wenn man Rotk√§ppchens Irrweg visualisiert. Ich habe das einmal mit <a href="cp^processingpy">Processing.py</a> nachprogrammiert und herausgekommen ist obige Figur, in der Fachliteratur auch als <a href="https://de.wikipedia.org/wiki/Sierpinski-Dreieck">Sierpinski Dreieck</a> bekannt, benannt nach dem polnischen Mathematiker <em>Wac≈Çaw Sierpi≈Ñski</em>, der das Fraktal schon 1915 als erster beschrieb.</p>
<h2 id="der-quellcode">Der Quellcode</h2>
<p>Normalerweise wird dieses Fraktal mit einem rekursiven Algorithmus erzeugt, aber es geht eben auch mithilfe dieses ¬ªChaos-Spiels¬´ [Herrm1994]</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> random <span class="ch">as</span> r

i = <span class="dv">0</span>
x = y = <span class="dv">0</span>

<span class="kw">def</span> setup():
    size(<span class="dv">640</span>, <span class="dv">480</span>)
    background(<span class="dv">0</span>)
    colorMode(HSB, <span class="dv">360</span>, <span class="dv">100</span>, <span class="dv">100</span>)
    frameRate(<span class="dv">1200</span>)

<span class="kw">def</span> draw():
    <span class="kw">global</span> i, x, y
    p = r.randint(<span class="dv">0</span>, <span class="dv">2</span>)
    <span class="kw">if</span> (p == <span class="dv">0</span>):
        x /= <span class="dv">2</span>
        y = (y + <span class="dv">480</span>)/<span class="dv">2</span>
    <span class="kw">elif</span> (p == <span class="dv">1</span>):
        x = (x + <span class="dv">320</span>)/<span class="dv">2</span>
        y /= <span class="dv">2</span>
    <span class="kw">else</span>:
        x = (x + <span class="dv">640</span>)/<span class="dv">2</span>
        y = (y + <span class="dv">480</span>)/<span class="dv">2</span>
    stroke(i%<span class="dv">360</span>, <span class="dv">100</span>, <span class="dv">100</span>)
    point(x, y)
    i += <span class="dv">1</span>
    <span class="kw">if</span> (i &gt; <span class="dv">120000</span>):
        <span class="dt">print</span>(<span class="st">&quot;I did it, Babe!&quot;</span>)
        noLoop()</code></pre>
<p>Die Schleife wird 120.000 mal durchlaufen, bevor sie stoppt. Damit ich nicht ewig auf das Ergebnis warten mu√ü, habe ich die Framerate auf 1.200 FPS gesetzt. Das ist vermutlich etwas √ºbertrieben, in diversen Foren habe ich Vermutung gefunden, da√ü Processing kaum eine Framerate von 1.000 FPS √ºberschreiten kann. Das habe ich experimentell best√§tigt, obiger Sketch lief auf meinem schnellsten Rechner, einem Mac Pro mit 3,5 GHz 6-Core Intel Xeon E5, 2 Minuten und 20 Sekunden. W√§ren genau 1.000 FPS erreicht worden, h√§tte er exakt 2 Minuten laufen m√ºssen.</p>
<p>Aber man sieht sehr sch√∂n, wie sich das Dreieck zuf√§llig, aber dennoch erkennbar, zusammensetzt. Je nach zuf√§lligem Startwert liegen die ersten drei bis vier Punkte noch au√üerhalb des Fraktals, danach geht aber alles seinen geordneten Gang. Und an den Farben erkennt man, da√ü auch die Reihenfolge, in der die einzelnen Punkte des Fraktals von Rotk√§ppchen angelaufen werden, ebenfalls zuf√§llig sind.</p>
<h2 id="literatur">Literatur</h2>
<ul>
<li><em>[Beaum1996]</em> William P. Beaumont: <em>Conquering the Math Bogeyman</em>, in Clifford A. Pickover (Ed.): <em><a href="https://www.amazon.de/Fractal-Horizons-Future-Use-Fractals/dp/0312125992/ref=as_li_ss_tl?ie=UTF8&amp;qid=1485189165&amp;sr=8-2&amp;keywords=Fractal+Horizons&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=20760d65b4a1abaf199a451570b77705">Fractal Horizons -- The Future Use of Fractals</a></em>, New York (St. Martin's Press) 1996, Seiten 3 - 15</li>
<li><em>[Herrm1994]</em> Dietmar Herrmann: <em><a href="https://www.amazon.de/Algorithmen-Chaos-Fraktale-Dietmar-Herrmann/dp/3893196331/ref=as_li_ss_tl?ie=UTF8&amp;qid=1485189321&amp;sr=8-1&amp;keywords=Algorithmen+f%C3%BCr+Chaos+und+Fraktale&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=137c8e47b75fc858c2eef89d8299f78e">Algorithmen f√ºr Chaos und Fraktale</a></em>, Bonn (Addison-Wesley) 1994, Seiten 132ff.</li>
</ul>
<h1 id="punkte-und-pixel">Punkte und Pixel</h1>
<h2 id="turmite">Turmite</h2>
<p>Turmiten sind quadratische, 1x1 Pixel gro√üe, kybernetische Kreaturen mit einer h√∂chst k√ºmmerlichen Andeutung eines Gehirns. Sie k√∂nnen die Farben des Pixels oder der Zelle, auf der sie gerade stehen, erkennen und danach handeln. Ist die Zelle schwarz, f√§rben sie sie rot und bewegen sich um ein Feld nach links. Ist die Farbe rot, f√§rben sie die Zelle schwarz und bewegen sich um ein Feld nach rechts.</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32407973340/"><img src="images/turmite.jpg" alt="Turmite" /></a></p>
<p>Wird solch eine Turmite auf eine schwarze, unendlichen Ebene gesetzt, erzeugt sie zuerst ein chaotisches Muster. Doch nach ungef√§hr 10.000 Schritten bildet sie auf einmal eine Turmiten-Autobahn, eine regelm√§√üige Struktur, die immer nach 104 Schritten in denselben Zustand zur√ºckkehrt, nur jeweils um 2 Felder verschoben.</p>
<h3 id="die-turmite-programmieren">Die Turmite programmieren</h3>
<p>Ich habe eine dieser Turmiten in einem Processing.py-Sketch zum Leben erweckt. Damit sie nicht in der Unendlichkeit der Ebene entfleucht, habe ich die Ecken des Fensters miteinander verklebt und sie so in eine <a href="https://de.wikipedia.org/wiki/Torus">Torus</a>-Welt verwandelt. Wenn die Turmite am unteren Ende des Fensters verschwindet, taucht sie am oberen Ende wieder auf, verschwindet sie am rechten Rand erscheint sie wieder am linken Rand. F√ºr beide R√§nder gilt das nat√ºrlich auch umgekehrt, die Welt der Turmite ist also ein fett aufgeblasener Fahrradschlauch, auf dem sie sich entlang bewegt.</p>
<p>Den Farbsensor der Turmite habe ich mit dem Processing-Befehl <code>get(x, y)</code> simuliert. Er liest die Farbe des Pixels. Analog dazu gibt es die Funktion <code>set(x, y, color)</code>, die die Farbe <code>color</code> an die Stelle <code>x, y</code> schreibt. Die beiden Farben habe ich im Sketch <code>on</code> f√ºr schwarz und <code>off</code> f√ºr rot genannt. Ich bin von der Metapher ausgegangen, da√ü die Turmite auf der schwarzen Ebene ein Feld entweder einschaltet (also rot f√§rbt) oder es wieder ausschaltet (es wird wieder schwarz).</p>
<p>Als ich damals auf meinem Atari-ST mein erstes Turmitenprogramm schrieb, dauerte es ewig, bis die Turmite mit ihrer Autobahn im Unendlichen verschwunden war (sie das Bildschirmfenster verlassen hatte). An eine R√ºckkehr via Torus wagte ich nicht zu denken, daf√ºr reichte meine Geduld nicht aus. Nun in Processing.py habe ich die Framerate auf 600 gesetzt und so geht es doch recht schnell voran.</p>
<p>Interessant ist, da√ü die Turmite, wenn sie auf eine von ihr geschaffene Autobahn trifft, zwar erst einmal wieder ein chaotisches Verhalten an den Tag legt, aber √ºber kurz oder lang wieder eine Autobahn baut. Diese Turmiten-Autobahnen kennen nur zwei Orientierungen, sie verlaufen entweder parallel oder stehen senkrecht aufeinander.</p>
<h3 id="quellcode">Quellcode</h3>
<p>Nach dem oben Beschriebenen d√ºrfte der Quellcode leicht verst√§ndlich sein. In der <code>setup()</code>-Funktion wird die Hintergrundfarbe auf schwarz und die Turmite in die Mitte des Fensters mit der Ausrichtung nach Norden gesetzt.</p>
<p>Im ersten Abschnitt der <code>draw()</code>-Funktion wird die Turmite gem√§√ü Ihrer aktuellen Orientierung bewegt und die Behandlung der Fensterr√§nder ber√ºcksichtigt. Dann wird die Farbe der aktuellen Zelle gelesen (mit <code>get(x, y)</code>) und je nach Zustand eine neue Farbe gesetzt und die Orientierung der Turmite den Regeln entsprechend ge√§ndert. Das ist alles.</p>
<pre class="sourceCode python"><code class="sourceCode python">south = <span class="dv">0</span>
east  = <span class="dv">1</span>
north = <span class="dv">2</span>
west  = <span class="dv">3</span>

on  = color(<span class="dv">188</span>, <span class="dv">0</span>, <span class="dv">0</span>)   <span class="co"># rot</span>
off = color(<span class="dv">0</span>)           <span class="co"># schwarz</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> x, y, <span class="dt">dir</span>
    size(<span class="dv">600</span>, <span class="dv">200</span>)
    x = width/<span class="dv">2</span>
    y = height/<span class="dv">2</span>
    <span class="dt">dir</span> = north
    frame.setTitle(<span class="st">&quot;Turmite&quot;</span>)
    background(<span class="dv">0</span>)
    frameRate(<span class="dv">600</span>)

<span class="kw">def</span> draw():
    <span class="kw">global</span> x, y, <span class="dt">dir</span>
    <span class="kw">if</span> (<span class="dt">dir</span> == south):
        y += <span class="dv">1</span>
        <span class="kw">if</span> (y == height):
            y = <span class="dv">0</span>
    <span class="kw">elif</span> (<span class="dt">dir</span> == east):
        x += <span class="dv">1</span>
        <span class="kw">if</span> (x == width):
            x = <span class="dv">0</span>
    <span class="kw">elif</span> (<span class="dt">dir</span> == north):
        <span class="kw">if</span> (y == <span class="dv">0</span>):
            y = height - <span class="dv">1</span>
        <span class="kw">else</span>:
            y -= <span class="dv">1</span>
    <span class="kw">elif</span> (<span class="dt">dir</span> == west):
        <span class="kw">if</span> (x == <span class="dv">0</span>):
            x = width - <span class="dv">1</span>
        <span class="kw">else</span>:
            x -= <span class="dv">1</span>
    
    <span class="kw">if</span> (get(x, y) == on):
        <span class="dt">set</span>(x, y, off)
        <span class="kw">if</span> (<span class="dt">dir</span> == south):
            <span class="dt">dir</span> = west
        <span class="kw">else</span>:
            <span class="dt">dir</span> -= <span class="dv">1</span>
    <span class="kw">else</span>:
        <span class="dt">set</span>(x, y, on)
        <span class="kw">if</span> (<span class="dt">dir</span> == west):
            <span class="dt">dir</span> = south
        <span class="kw">else</span>:
            <span class="dt">dir</span> += <span class="dv">1</span></code></pre>
<h3 id="weitere-m√∂gliche-experimente">Weitere m√∂gliche Experimente</h3>
<p>Die Turmiten gehen auf <em>Greg Turk</em> zur√ºck, der damals Doktorand an der Universit√§t von North Carolina in Chapel Hill war. Er zeigte, da√ü sie eine zweidimensionale <a href="https://de.wikipedia.org/wiki/Turingmaschine">Turingmaschine</a> sind. Sp√§ter hat sie <em>Christopher Langton</em> weiterentwickelt und beschrieben -- daher ist sie auch unter dem Namen ¬ªLangtons Ameise¬´ <em>(Lanton's Ant)</em> bekannt. Die hier vorgestellte ist die einfachste Form solch einer Ameise. Ein n√§chster Schritt w√§re beispielsweise, die Welt mit zwei Turmiten zu bev√∂lkern, die eine f√§rbt die Ebene rot, wenn sie auf ein schwarzes Feld trifft, die andere f√§rbt sie blau. Nat√ºrlich m√º√üten dann beide Ameisen auch Regeln implementiert bekommen, wie sie zu verfahren haben, wenn sie auf ein blaues respektive ein rotes Feld treffen.</p>
<p>Von Turk selber gibt es zum Beispiel eine Turmite mit zwei Zust√§nden, nennen wir diese <code>A</code> und <code>B</code> und mit folgendem Regelsatz:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Zustand</th>
<th style="text-align: left;">A</th>
<th style="text-align: left;">B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">gr√ºn</td>
<td style="text-align: left;">schwarz, vorw√§rs, B</td>
<td style="text-align: left;">gr√ºn, rechts, A</td>
</tr>
<tr class="even">
<td style="text-align: left;">schwarz</td>
<td style="text-align: left;">gr√ºn, links, A</td>
<td style="text-align: left;">gr√ºn, rechts, A</td>
</tr>
</tbody>
</table>
<p>Sie erzeugt ein Spiralmuster, ¬ªimmer gr√∂√üer werdende strukturierte Gebiete, die sich in regelm√§√üiger Anordnung um einen Startpunkt winden¬´.</p>
<p>Eine weitere Turmite, die mit vier Farben hantiert, braucht nur einen Zustand, um ebenfalls ein interessantes, symmetrisches Muster zu bilden. Hier ihr Regelsatz:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Zustand</th>
<th style="text-align: left;">A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">blau</td>
<td style="text-align: left;">rot, rechts, A</td>
</tr>
<tr class="even">
<td style="text-align: left;">rot</td>
<td style="text-align: left;">gelb, rechts, A</td>
</tr>
<tr class="odd">
<td style="text-align: left;">gelb</td>
<td style="text-align: left;">gr√ºn, links, A</td>
</tr>
<tr class="even">
<td style="text-align: left;">gr√ºn</td>
<td style="text-align: left;">blau, links, A</td>
</tr>
</tbody>
</table>
<p>Es gibt also noch viel zu entdecken in der Welt der Turmiten und Ameisen.</p>
<h3 id="literatur-1">Literatur</h3>
<ul>
<li>A.K. Dewdney: <em>Turmiten</em>, in: Immo Diener (Hg.): <em>Computer-Kurzweil 2, Spektrum Akademischer Verlag: Verst√§ndliche Forschung</em>, Heidelberg 1992, Seiten 156-160</li>
<li><a href="https://de.wikipedia.org/wiki/Ameise_(Turingmaschine)">Ameise (Turingmaschine)</a> in der Wikipedia.</li>
</ul>
<h2 id="wir-backen-uns-ein-mandelbr√∂tchen">Wir backen uns ein Mandelbr√∂tchen</h2>
<figure>
<img src="images/mandelbrotmenge.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Die <a href="https://de.wikipedia.org/wiki/Mandelbrot-Menge">Mandelbrot-Menge</a> ist die zentrale Ikone der Chaos-Theorie und das Urbild aller Fraktale. Sie ist die Menge aller komplexen Zahlen <em>c</em>, f√ºr welche die durch</p>

<p>rekursiv definierte Folge beschr√§nkt ist. Bilder der Mandelbrot-Menge k√∂nnen erzeugt werden, indem f√ºr jeden Wert des Parameters <em>c</em>, der gem√§√ü obiger Rekursion endlich bleibt, ein Farbwert in der komplexen Ebene zugeordnet wird.</p>
<p>Die komplexe Ebene wird in der Regel so dargestellt, da√ü in der Horizontalen (in der kartesisschen Ebene die <em>x-Achse</em>) der Realteil der komplexen Zahl und in der Vertikalen (in der kartesischen Ebene die <em>y-Achse</em>) der imagin√§re Teil aufgetragen wird. Jede komplexe Zahl entspricht also einen Punkt in der komplexen Ebene. Die zur Mandelbrotmenge geh√∂renden Zahlen werden im Allgemeinen schwarz dargestellt, die √ºbrigen Farbwerte werden der Anzahl von Iterationen (<code>maxiter</code>) zugeordnet, nach der der gew√§hlte Punkt der Ebene einen Grenzwert (<code>maxlimit</code>) verl√§√üt. Der theoretische Grenzwert ist <em>2.0</em>, doch k√∂nnen besonders bei Ausschnitten aus der Menge, um andere Farbkombinationen zu erreichen, auch h√∂here Grenzwerte verwendet werden. Bei Ausschnitten mu√ü auch die Anzahl der Iterationen massiv erh√∂ht werden, um eine hinreichende Genauigkeit der Darstellung zu erreichen.</p>
<h3 id="das-programm">Das Programm</h3>
<p>Python kennt den Datentyp <code>complex</code> und kann mit komplexen Zahlen rechnen. Daher dr√§ngt sich die Sprache f√ºr Experimente mit komplexen Zahlen geradezu auf. Zuert werden mit <code>cr</code> und <code>ci</code> Real- und Imagin√§rteil definiert und dann mit</p>
<pre class="sourceCode python"><code class="sourceCode python">c = <span class="dt">complex</span>(cr, ci)</code></pre>
<p>die komplexe Zahl erzeugt. F√ºr die eigentliche Iteration wird dann -- nachdem der Startwert <code>z = 0.0</code> festgelegt wurde -- nur eine Zeile ben√∂tigt:</p>
<pre class="sourceCode python"><code class="sourceCode python">z = (z**<span class="dv">2</span>) + c</code></pre>
<p>Wie schon in anderen Beispielen habe ich f√ºr die Farbdarstellung den HSB-Raum verwendet und √ºber den <em>Hue</em>-Wert iteriert. Das macht alles sch√∂n bunt, aber es gibt nat√ºrlich viele M√∂glichkeiten, ansprechendere Farben zu bekommen, beliebt sind zum Beispiel selbsterstellte Paletten mit 256 ausgesuchten Farbwerten, die entweder harmonisch ineinander √ºbergehen oder bestimmte Kontraste betonen.</p>
<h3 id="der-komplette-quellcode">Der komplette Quellcode</h3>
<pre class="sourceCode python"><code class="sourceCode python">left   = -<span class="fl">2.25</span>
right  = <span class="fl">0.75</span>
bottom = -<span class="fl">1.5</span>
top    = <span class="fl">1.5</span>
maxlimit = <span class="fl">2.0</span>
maxiter = <span class="dv">20</span>

<span class="kw">def</span> setup():
    size(<span class="dv">400</span>, <span class="dv">400</span>)
    background(<span class="st">&quot;#ffffff&quot;</span>)
    colorMode(HSB, <span class="dv">255</span>, <span class="dv">100</span>, <span class="dv">100</span>)
    <span class="co"># frame.setTitle(u&quot;Mandelbr√∂tchen&quot;)</span>
    noLoop()

<span class="kw">def</span> draw():
    <span class="kw">for</span> x in <span class="dt">range</span>(width):
        cr = left + x*(right - left)/width
        <span class="kw">for</span> y in <span class="dt">range</span>(height):
            ci = bottom + y*(top - bottom)/height
            c = <span class="dt">complex</span>(cr, ci)
            z = <span class="fl">0.0</span>
            i = <span class="dv">0</span>
            <span class="kw">for</span> i in <span class="dt">range</span>(maxiter):
                <span class="kw">if</span> <span class="dt">abs</span>(z) &gt; maxlimit:
                    <span class="kw">break</span>
                z = (z**<span class="dv">2</span>) + c
                <span class="kw">if</span> i == (maxiter - <span class="dv">1</span>):
                    <span class="dt">set</span>(x, y, color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>))
                <span class="kw">else</span>:
                    <span class="dt">set</span>(x, y, color((i*<span class="dv">48</span>)%<span class="dv">255</span>, <span class="dv">100</span>, <span class="dv">100</span>))</code></pre>
<p>Um zu sehen, wie sich die Farben √§ndern, kann man durchaus mal mit den Werten von <code>maxlimit</code> spielen und diesen zum Beispiel auf <code>3.0</code> oder <code>4.0</code> setzen. Auch die Erh√∂hung der Anzahl der Iterationen <code>maxiter</code> ver√§ndert die Farbzuordnung, verl√§ngert aber auch die Rechhenzeit drastisch, so da√ü man speziell bei Ausschnitten aus der Mandelbrotmenge schon einige Zeit auf das Ergebnis warten mu√ü.</p>
<h2 id="pixel-array-versus-set">Pixel-Array versus set()</h2>
<p>Will man einzelne Pixel im Ausgabefenster oder in einem Bild manipulieren, bietet Processing(.py) grunds√§tzlich zwei M√∂glichkeiten: Zum einen kann man mit</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="dt">set</span>(x, y, color)</code></pre>
<p>direkt einen Farbpunkt an eine bestimmte Position <code>x, y</code> setzen, oder aber man l√§dt mit</p>
<pre class="sourceCode python"><code class="sourceCode python">loadPixels()</code></pre>
<p>das gesamte Ausgabe-Fenster in ein eindimensionales Pixel-Array, um dann mit</p>
<pre class="sourceCode python"><code class="sourceCode python">pixels[x + y*width] = color()</code></pre>
<p>die Farbe an die gew√ºnschte Stelle <code>x, y</code> zu setzen. Anschlie√üend darf man nicht vergessen, mit</p>
<pre class="sourceCode python"><code class="sourceCode python">updatePixels()</code></pre>
<p>Processing dazu zu bewegen, die ge√§nderten Pixel auch anzuzeigen. Dadurch, da√ü das Pixel-Array eindimensional ist und so die gew√ºnschte Position mit <code>x + y*width</code> angesprochen werden mu√ü, ist die erste Version (f√ºr die es √ºbrigens auch noch ein entsprechendes <code>get(x, y)</code> gibt, mit dem man die Farbe an der gew√ºnschten Stelle abfragen kann) einfacher handzuhaben, aber die <a href="https://processing.org/reference/set_.html">Reference zu Processing</a> zu bedenken:</p>
<blockquote>
<p>Setting the color of a single pixel with set(x, y) is easy, but not as fast as putting the data directly into pixels[].</p>
</blockquote>
<p>Das gilt aber nicht immer, mit dem im <a href="mandelbrot.md">letzten Abschnitt gebackenen Mandelbr√∂tchen</a> habe ich die Probe aufs Exempel gemacht. Zwei nahezu identische Programme habe ich gegeneinander antreten lassen.</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/34861784971/"><img src="images/mandelbrot2.jpg" alt="Screenshot" /></a></p>
<h3 id="programm-1-mandelbrot-menge-mit-set">Programm 1: Mandelbrot-Menge mit set()</h3>
<pre class="sourceCode python"><code class="sourceCode python">left   = -<span class="fl">2.25</span>
right  = <span class="fl">0.75</span>
bottom = -<span class="fl">1.5</span>
top    = <span class="fl">1.5</span>
maxlimit = <span class="fl">4.0</span>
maxiter = <span class="dv">100</span>

<span class="kw">def</span> setup():
    size(<span class="dv">600</span>, <span class="dv">600</span>)
    background(<span class="st">&quot;#ffffff&quot;</span>)
    colorMode(HSB, <span class="dv">255</span>, <span class="dv">100</span>, <span class="dv">100</span>)
    noLoop()

<span class="kw">def</span> draw():
    <span class="kw">for</span> x in <span class="dt">range</span>(width):
        cr = left + x*(right - left)/width
        <span class="kw">for</span> y in <span class="dt">range</span>(height):
            ci = bottom + y*(top - bottom)/height
            c = <span class="dt">complex</span>(cr, ci)
            z = <span class="dt">complex</span>(<span class="fl">0.0</span>, <span class="fl">0.0</span>)
            i = <span class="dv">0</span>
            <span class="kw">for</span> i in <span class="dt">range</span>(maxiter):
                <span class="kw">if</span> <span class="dt">abs</span>(z) &gt; maxlimit:
                    <span class="kw">break</span>
                z = (z**<span class="dv">2</span>) + c
                <span class="kw">if</span> i == (maxiter - <span class="dv">1</span>):
                    <span class="dt">set</span>(x, y, color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>))
                <span class="kw">else</span>:
                    <span class="dt">set</span>(x, y, color((i*<span class="dv">48</span>)%<span class="dv">255</span>, <span class="dv">100</span>, <span class="dv">100</span>))
    println(millis())</code></pre>
<h3 id="programm-2-mandelbrot-menge-mit-pixel-array">Programm 2: Mandelbrot-Menge mit Pixel-Array</h3>
<pre class="sourceCode python"><code class="sourceCode python">left   = -<span class="fl">2.25</span>
right  = <span class="fl">0.75</span>
bottom = -<span class="fl">1.5</span>
top    = <span class="fl">1.5</span>
maxlimit = <span class="fl">4.0</span>
maxiter = <span class="dv">100</span>

<span class="kw">def</span> setup():
    size(<span class="dv">600</span>, <span class="dv">600</span>)
    background(<span class="st">&quot;#ffffff&quot;</span>)
    colorMode(HSB, <span class="dv">255</span>, <span class="dv">100</span>, <span class="dv">100</span>)
    noLoop()

<span class="kw">def</span> draw():
    loadPixels()
    <span class="kw">for</span> x in <span class="dt">range</span>(width):
        cr = left + x*(right - left)/width
        <span class="kw">for</span> y in <span class="dt">range</span>(height):
            ci = bottom + y*(top - bottom)/height
            c = <span class="dt">complex</span>(cr, ci)
            z = <span class="dt">complex</span>(<span class="fl">0.0</span>, <span class="fl">0.0</span>)
            i = <span class="dv">0</span>
            <span class="kw">for</span> i in <span class="dt">range</span>(maxiter):
                <span class="kw">if</span> <span class="dt">abs</span>(z) &gt; maxlimit:
                    <span class="kw">break</span>
                z = (z**<span class="dv">2</span>) + c
                <span class="kw">if</span> i == (maxiter - <span class="dv">1</span>):
                    pixels[x + y*width] = color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)
                <span class="kw">else</span>:
                    pixels[x + y*width] = color((i*<span class="dv">48</span>)%<span class="dv">255</span>, <span class="dv">100</span>, <span class="dv">100</span>)
    updatePixels()
    println(millis())</code></pre>
<p>Und -- √úberraschung! -- das Programm mit <code>set()</code> war fast immer geringf√ºgig schneller als das Programm mit den Pixel-Arrays. Auf meinem betagten MacBook Pro ben√∂tigte das erste Programm rund 15.000 bis 16.000 Millisekunden, w√§hrend das zweite Programm um die 18.000 Millisekunden ben√∂tigte. Der Unterschied ist nicht gro√ü, aber dennoch bemerkenswert. Es liegt zum einen sicher daran, da√ü die ben√∂tigte Zeit f√ºr die Berechnung des Apfelm√§nnchens im Vergleich zu der ben√∂tigten Zeit, dieses zu zeichnen, riesig ist. Zum anderen wird die <code>draw()</code>-Schleife ja auch nur einmal durchlaufen und so kann das Pixel-Array seine F√§higkeit der schnellen Pixelmanipulation nicht richtig ausspielen.</p>
<p>Die Erkenntnis daraus: Es kann sich durchaus lohnen, auch mal das Handbuch zu hinterfragen. üòà</p>
<h2 id="julia-menge">Julia-Menge</h2>
<figure>
<img src="images/julia.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Die <a href="https://de.wikipedia.org/wiki/Julia-Menge">Julia-Menge</a> wurde 1918 von den beiden franz√∂sischen Mathematikern <em>Gaston Maurice Julia</em> (nachdem sie benannt wurde) und <em>Pierre Fatou</em> (dessen Zugang heute die meisten Lehrb√ºcher folgen) unabh√§ngig voneinander beschrieben. Sie steht im engen Zusammenhang zur im letzten Abschnitt beschriebenen <a href="mandelbrot.md">Mandelbrot-Menge</a>. W√§hrend die Mandelbrot-Menge, die Menge aller komplexen Zahlen <em>c</em> ist, die der iterierten Gleichung</p>

<p>folgen, ist bei der Julia-Menge <em>c</em> konstant:</p>

<p>Die Mandelbrot-Menge ist also eine Beschreibungsmenge aller Julia-Mengen. Jedem Punkt <em>c</em> der komplexen Zahlenebene entspricht eine Julia-Menge. Eigenschaften der Julia-Menge lassen sich an der Lage von <em>c</em> relativ zur Mandelbrot-Menge beurteilen: Wenn der Punkt <em>c</em> Element der Mandelbrot-Menge ist, dann ist die Julia-Menge zusammenh√§ngend. Andernfalls ist sie eine Cantormenge unzusammenh√§ngender Punkte. Ist der Imagin√§rteil <em>c<sub>i</sub> = 0</em>, dann ist die Julia-Menge symmetrisch (vlg. Abbildung links oben), ansonsten kann sie alle m√∂glichen Formen annehmen.</p>
<h3 id="julia-menge-interaktiv">Julia-Menge interaktiv</h3>
<p>Ich habe die obigen Bilder mit diesem Programm erzeugt, da√ü den Parameter <em>c</em> in Abh√§ngigkeit von der Mausposition setzt:</p>
<pre class="sourceCode python"><code class="sourceCode python">left   = -<span class="fl">2.0</span>
right  = <span class="fl">2.0</span>
bottom = <span class="fl">2.0</span>
top    = -<span class="fl">2.0</span>
maxlimit = <span class="fl">3.0</span>
maxiter = <span class="dv">25</span>

<span class="kw">def</span> setup():
    size(<span class="dv">400</span>, <span class="dv">400</span>)
    background(<span class="st">&quot;#555ddd&quot;</span>)
    colorMode(HSB, <span class="dv">1</span>)

<span class="kw">def</span> draw():
    cr = <span class="dt">map</span>(mouseX, <span class="dv">0</span>, width, left, right)
    ci = <span class="dv">0</span>
    <span class="co"># ci = map(mouseY, 0, height, top, bottom)</span>
    c = <span class="dt">complex</span>(cr, ci)
    <span class="kw">for</span> x in <span class="dt">range</span>(width):
        zr = left + x*(right - left)/width
        <span class="kw">for</span> y in <span class="dt">range</span>(height):
            zi = bottom + y*(top - bottom)/height
            z = <span class="dt">complex</span>(zr, zi)
            i = <span class="dv">0</span>
            <span class="kw">for</span> i in <span class="dt">range</span>(maxiter):
                <span class="kw">if</span> <span class="dt">abs</span>(z) &gt; maxlimit:
                    <span class="kw">break</span>
                z = (z**<span class="dv">2</span>) + c
                <span class="kw">if</span> i == (maxiter<span class="dv">-1</span>):
                    <span class="dt">set</span>(x, y, color(<span class="dv">0</span>))
                <span class="kw">else</span>:
                    <span class="dt">set</span>(x, y, color(sqrt(<span class="dt">float</span>(i)/maxiter), <span class="dv">100</span>, <span class="dv">100</span>))
    println(<span class="st">&quot;cr = &quot;</span> + <span class="dt">str</span>(cr))
    println(<span class="st">&quot;ci = &quot;</span> + <span class="dt">str</span>(ci))</code></pre>
<p>Kommentiert man die Zeile <code>ci = 0</code> aus und aktiviert stattdessen die auskommentierte Zeile darunter, erh√§lt man (theoretisch) alle Julia-Mengen, sonst erzeugt das Programm nur die symmetrischen. Richtig fl√ºssig ist die Animation allerdings nicht, Processing.py ger√§t -- zumindest auf meinem betagten MacBook Pro -- schon ganz sch√∂n ins Stottern.</p>
<h3 id="julia-menge-animiert">Julia-Menge animiert</h3>
<p>Das gilt auch f√ºr das zweite Programm, das die Parameter der Julia-Menge anhand zweier Sinus- (wahlweise auch Cosinus-) Funktionen periodisch durchl√§uft:</p>
<pre class="sourceCode python"><code class="sourceCode python">left   = -<span class="fl">2.0</span>
right  = <span class="fl">2.0</span>
bottom = <span class="fl">2.0</span>
top    = -<span class="fl">2.0</span>
maxlimit = <span class="fl">3.0</span>
maxiter = <span class="dv">25</span>

<span class="kw">def</span> setup():
    size(<span class="dv">400</span>, <span class="dv">400</span>)
    background(<span class="st">&quot;#555ddd&quot;</span>)
    colorMode(HSB, <span class="dv">1</span>)

<span class="kw">def</span> draw():
    <span class="co"># cr = 0</span>
    cr = <span class="dv">2</span>*sin(frameCount)
    ci = <span class="dv">0</span>
    <span class="co"># ci = 2*cos(frameCount)</span>
    c = <span class="dt">complex</span>(cr, ci)
    <span class="kw">for</span> x in <span class="dt">range</span>(width):
        zr = left + x*(right - left)/width
        <span class="kw">for</span> y in <span class="dt">range</span>(height):
            zi = bottom + y*(top - bottom)/height
            z = <span class="dt">complex</span>(zr, zi)
            i = <span class="dv">0</span>
            <span class="kw">for</span> i in <span class="dt">range</span>(maxiter):
                <span class="kw">if</span> <span class="dt">abs</span>(z) &gt; maxlimit:
                    <span class="kw">break</span>
                z = (z**<span class="dv">2</span>) + c
                <span class="kw">if</span> i == (maxiter<span class="dv">-1</span>):
                    <span class="dt">set</span>(x, y, color(<span class="dv">0</span>))
                <span class="kw">else</span>:
                    <span class="dt">set</span>(x, y, color(sqrt(<span class="dt">float</span>(i)/maxiter), <span class="dv">100</span>, <span class="dv">100</span>))
    println(<span class="st">&quot;cr = &quot;</span> + <span class="dt">str</span>(cr))
    println(<span class="st">&quot;ci = &quot;</span> + <span class="dt">str</span>(ci))</code></pre>
<p>Auch hier kommt das Programm ganz sch√∂n ins Schwitzen. Das l√§√üt allerdings dem Betrachter Zeit, die Sch√∂nheit der Julia-Menge zu bewundern.</p>
<h2 id="schnelle-bildmanipulation-das-pixel-array">Schnelle Bildmanipulation: Das Pixel-Array</h2>
<p>In den letzten beiden Abschnitt habe ich gezeigt, da√ü Processing.py zwar relativ schnell ist, aber 120.000 Operationen in einem Bildfenster doch eine gewisse Zeit ben√∂tigen. Falls man jedoch auf die Animation verzichten kann (und damit auf <code>point()</code> oder <code>get()</code> und <code>set()</code>), geht es auch wesentlich schneller: Jedes Bild in Processing(.py) -- und das schlie√üt das Graphikfenster ein -- wird intern als eine eindimensionale Liste der Farbwerte gespeichert. Die erste Position der Liste ist das erste Pixel links oben, die letzte Position folgerichtig das letzte Pixel rechts unten.</p>
<p>Ein <code>pixels[]</code>-Array in Processing speichert in dieser Form die Farbwerte f√ºr jedes Pixels des Ausgabefensters. Um es zu initialisieren, mu√ü vor der ersten Nutzung die Funktion <code>loadPixels()</code> aufgerufen werden. Manipulationen im Pixel-Array werden erst sichtbar, wenn die Funktion <code>updatePixels()</code> aufgerufen wird. <code>loadPixels()</code> und <code>updatePixels()</code> bilden so ein √§hnliches Geschwisterpaar von Funktionen, wie zum Beispiel <code>beginShape()</code> und <code>endShape()</code>. Doch einen Unterschied gibt es: Wird das Pixel-Array nur zum Lesen der Farbwerte genutzt, mu√ü <code>updatePixels()</code> nat√ºrlich nicht aufgerufen werden. Da die Manipulationen eines Pixel-Arrays nur im Hauptspeicher des Rechners stattfinden, sind sie nat√ºrlich viel schneller als jede andere Processing-Funktion, die Bildinformationen manipuliert.</p>
<p>Da das Pixel-Array ein eindimensionales Array ist, mu√ü auf die Zeilen und Spalten mit einem kleinen Trick zugegriffen werden. Jeder Punkt <code>(x, y)</code> steht im Pixelarray an der Position <code>x + (y*width)</code>. An die Farbwerte eines Pixels kommt man mit dem Aufruf</p>
<pre class="sourceCode python"><code class="sourceCode python">i = x + (y*width)
color(c) = pixels[i]</code></pre>
<p>Die einzelnen Farbwerte im RGB-Raum kann man danach so auslesen:</p>
<pre class="sourceCode python"><code class="sourceCode python">r = red(c)
g = green(c)
b = blue(c)</code></pre>
<p>Das Setzen eines Pixels erfolgt genau umgekehrt:</p>
<pre class="sourceCode python"><code class="sourceCode python">pixel[i] = color(r, g, b)</code></pre>
<p>Nat√ºrlich kann man auch jeden anderen Farbraum (Graustufen, HSV), den Processing kennt, nutzen.</p>
<h3 id="fantastic-feather-fractal">Fantastic Feather Fractal</h3>
<p>Um zu zeigen, wie schnell die Manipulationen eines Pixel-Arrays sind, m√∂chte ich wieder eine Iteration √ºber 120.000 Schritte durchf√ºhren. Als Demonstrationsobjekt habe ich das <em>Fantastic Feather Fractal</em> gew√§hlt, das <em>Clifford A. Pickover</em> in seinem Buch ¬ªMazes for the Mind¬´ vorgestellt hat. Wenn Ihr untenstehenden Quellcode laufen la√üt, werdet Ihr feststellen, da√ü das fertige Fraktal fast unmittelbar nach dem Aufruf im Graphikfenster erscheint.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32766476595/"><img src="images/featherfractal.jpg" alt="Feather Fractal" /></a></p>
<p>Das <em>Feather Fractal</em> ist ein ¬ª<a href="https://de.wikipedia.org/wiki/Seltsamer_Attraktor">seltsamer Attraktor</a>¬´, ein <a href="http://www.spektrum.de/lexikon/physik/attraktor/926">Attraktor</a> eines dynamischen Systems, das sich zwar chaotisch verh√§lt, aber dennoch eine <em>kompakte Menge</em> ist, die es nie verl√§√üt. Die Parameter des Sketches entstammen der oben genannten Quelle von <em>Pickover</em>, die Faktoren um das Ergebnis dem Bildfenster anzupassen habe ich durch wildes Herumexperimentieren gefunden<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<h3 id="der-quellcode-1">Der Quellcode</h3>
<pre class="sourceCode python"><code class="sourceCode python">a = -.<span class="dv">48</span>
b = .<span class="dv">93</span>

<span class="kw">def</span> setup():
    size(<span class="dv">640</span>, <span class="dv">480</span>)
    background(<span class="dv">0</span>)
    colorMode(HSB, <span class="dv">255</span>, <span class="dv">100</span>, <span class="dv">100</span>)
    frame.setTitle(<span class="st">&quot;Fantastic Feather Fractal&quot;</span>)
    noLoop()

<span class="kw">def</span> draw():
    loadPixels()
    x = <span class="fl">4.0</span>
    y = .<span class="dv">0</span>
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">1</span>, <span class="dv">120000</span>, <span class="dv">1</span>):
        x1 = b*y + f(x)
        y = -x + f(x1)
        x = x1
        pixels[(<span class="dv">350</span> + <span class="dt">int</span>(x*<span class="dv">26</span>)) + ((<span class="dv">280</span> - <span class="dt">int</span>(y*<span class="dv">26</span>))*width)] = color(i%<span class="dv">255</span>, <span class="dv">100</span>, <span class="dv">100</span>)
    updatePixels()

<span class="kw">def</span> f(x):
    <span class="kw">return</span> a*x - (<span class="fl">1.0</span> - a)*((<span class="dv">2</span>*(x**<span class="dv">2</span>))/(<span class="fl">1.0</span> + x**<span class="dv">2</span>))</code></pre>
<p>Wenn ich sp√§ter noch auf Bildmanipulationen in Processing zur√ºckkomme, werden die Pixel-Arrays noch einmal ausf√ºhrlich behandelt werden.</p>
<h3 id="literatur-2">Literatur</h3>
<ul>
<li>Clifford A. Pickover: <em><a href="https://www.amazon.de/Mazes-Mind-Unexpected-Clifford-Pickover/dp/0312081650/ref=as_li_ss_tl?ie=UTF8&amp;qid=1486495162&amp;sr=8-2&amp;keywords=mazes+for+the+mind&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=bc35f133a882d2981e9f20e814cc6ef3">Mazes for the Mind. Computer s and the Unexpected</a></em>, New York (St. Martin's Press) 1992. Das Buch geh√∂rt zu den Besten des umtriebigen Autors und da es aufgrund seines Alters antiquarisch f√ºr ein paar Cent zu bekommen ist, solltet Ihr zuschlagen. Das Feder-Fraktal ist auf den Seiten 33f. beschrieben, die √ºber 400 anderen Seiten erf√ºllen fast jeden Traum eines an Computer-Experimenten interessierten Menschen.</li>
<li>Florian Freistetter: <em><a href="http://scienceblogs.de/astrodicticum-simplex/2015/02/04/best-of-chaos-der-seltsame-attraktor/">Best of Chaos: Der seltsame Attraktor</a></em>, Science Blogs (Astrodicticum Simplex) vom 4. Februar 2015 (Ich bin ein Fan von <em>Florian Freistetter</em>, er ist einer der wenigen guten deutschsprachigen Erkl√§rb√§ren f√ºr Naturwissenschaften)</li>
</ul>
<h1 id="linien">Linien</h1>
<h2 id="anschauliche-mathematik-die-schmetterlingskurve">Anschauliche Mathematik: Die Schmetterlingskurve</h2>
<figure>
<img src="images/buttfly.jpg" alt="Schmetterling" /><figcaption>Schmetterling</figcaption>
</figure>
<p>Seit ich Ende der 1980er Jahre mit meinem damals hochmodernen <a href="https://de.wikipedia.org/wiki/Atari_ST">Atari Mega¬†ST</a> erste Schritte mit einem graphikf√§higen Personalcomputer unternommen hatte, habe ich die Schmetterlingskurve immer wieder als Test f√ºr die Graphikf√§higkeit und Schnelligkeit von Programmiersprachen und Rechnern benutzt. Sie wird in <a href="https://de.wikipedia.org/wiki/Polarkoordinaten">Polarkoordinaten</a> beschrieben und ihre Formel ist</p>
<p><br /><span class="math">$$
\rho=e^{\cos(\theta)}-2\cdot \cos(4\cdot \theta)+\sin(\tfrac{\theta}{12})^5
$$</span><br /></p>
<p>oder in Python-Code:</p>
<pre class="sourceCode python"><code class="sourceCode python">r = exp(cos(theta)) - <span class="dv">2</span>*cos(<span class="dv">4</span>*theta) + (sin(theta/<span class="dv">12</span>))**<span class="dv">5</span></code></pre>
<p>Die Gleichung ist hinreichend kompliziert um selbst in C geschriebene Routinen auf meinen damals unglaubliche 8 MegaBit schnellen Atari alt aussehen zu lassen. Rechenzeiten von 10 - 20 Minuten waren keine Seltenheit. Heute dagegen mu√ü man den Rechner schon k√ºnstlich verlangsamen, damit man sieht, wie sich die Kurve aufbaut. Denn sonst erscheint sofort die fertige Kurve, um die sinnliche Erfahrung, wie diese entsteht, wird man betrogen. Daher habe ich sie in <em>Processing.py</em> innerhalb der <code>draw()</code>-Schleife zeichnen lassen, wobei die Schleifenvariable <code>theta</code> bei jedem Durchlauf um <code>0.02</code> erh√∂ht wurde.</p>
<p>Der Code ist -- dank Processing.py -- wieder von erfrischender Einfachheit und K√ºrze:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    <span class="kw">global</span> theta, xOld, yOld
    theta = xOld = yOld = <span class="fl">0.0</span>
    size(<span class="dv">600</span>, <span class="dv">600</span>)
    background(<span class="dv">100</span>, <span class="dv">100</span>, <span class="dv">100</span>)
    colorMode(HSB, <span class="dv">100</span>)
    
<span class="kw">def</span> draw():
    <span class="kw">global</span> theta, xOld, yOld
    strokeWeight(<span class="dv">2</span>)
    stroke(theta, <span class="dv">100</span> - theta, <span class="dv">100</span>)
    r = exp(cos(theta)) - <span class="dv">2</span>*cos(<span class="dv">4</span>*theta) + (sin(theta/<span class="dv">12</span>))**<span class="dv">5</span>
    <span class="co"># aus Polarkoordinaten konvertieren</span>
    x = r*cos(theta)
    y = r*sin(theta)
    <span class="co"># auf Fenstergr√∂√üe skalieren</span>
    xx = (x*<span class="dv">60</span>) + <span class="dv">300</span>
    yy = (y*<span class="dv">60</span>) + <span class="dv">300</span>
    <span class="kw">if</span> (theta == <span class="fl">0.0</span>):
        point(xx, yy)
    <span class="kw">else</span>:
        line(xOld, yOld, xx, yy)
    xOld = xx
    yOld = yy
    theta += <span class="fl">0.02</span>
    <span class="kw">if</span> (theta &gt; <span class="fl">75.39</span>):
        <span class="dt">print</span>(<span class="st">&quot;I did it, Babe!&quot;</span>)
        noLoop()</code></pre>
<p>In <code>setup()</code> ist eigentlich nur bemerkenswert, da√ü ich nach der Festlegung des grauen Hintergrunds (noch als RGB), den <code>colorMode</code> auf HSB ge√§ndert habe. Damit lassen sich n√§mlich recht einfach diverse Farbeffekte erzielen. Ich habe dabei den <em>Hue</em>-Wert in Abh√§ngigkeit von <code>theta</code> gesetzt, die S√§ttigung auf <code>100 - theta</code> und die <em>Brightness</em> konstant bei 100 belassen. Da <code>theta</code> nie gr√∂√üer als <em>75,39</em> wird, wird es also auch nie gr√∂√üer als 100 und damit sind diese Umrechnungen gefahrlos.</p>
<p>Damit erreicht man, da√ü zu Beginn, wo die S√§ttigung noch ziemlich voll ist, die Zeichnung mit einem satten rot beginnt, w√§hrend im Laufe der Iteration die weiteren Farben immer blasser werden. Ich fand dies das √§sthetisch anspruchvollste Ergebnis, aber um das selber nachvollziehen zu k√∂nnen, solltet Ihr ruhig damit experimentieren, zum Beispiel mit <code>stroke(theta, 100, 100)</code> oder <code>stroke(100-theta, theta, 100)</code> oder was immer Ihr wollt.</p>
<p>Ihr bekommt so diesen wundersch√∂nen Schmetterling auf den Monitor gezeichnet:</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/31543605354/"><img src="images/butterflycurve.jpg" alt="Screenshot" /></a></p>
<p>Um die Entstehung der Kurve zu verstehen, empfiehlt <em>Stan Wagon</em><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>, nacheinander folgende Formlen plotten zu lassen:</p>
<p>In Polarkoordinaten:</p>
<pre class="sourceCode python"><code class="sourceCode python">r = exp(cos(theta))  <span class="co"># ergibt eine Art Kreis</span>
r = -<span class="dv">2</span>*cos(<span class="dv">4</span>*theta)  <span class="co"># ergibt eine Art Blume</span>
r = exp(cos(theta)) - <span class="dv">2</span>*cos(<span class="dv">4</span>*theta)  <span class="co"># ergibt einen sehr einfachen Schmetterling</span></code></pre>
<p>Dann in kartesischen Koordinaten:</p>
<pre class="sourceCode python"><code class="sourceCode python">x = -<span class="dv">2</span>*cos(<span class="dv">4</span>*theta)
y = -sin(theta/<span class="dv">12</span>)**<span class="dv">5</span></code></pre>
<p>Und dann ruhig auch noch einmal (wieder in Polarkoordinaten):</p>
<pre class="sourceCode python"><code class="sourceCode python">r = exp(cos(theta)) - <span class="dv">2</span>*cos(<span class="dv">4</span>*theta) - (sin(theta/<span class="dv">12</span>))**<span class="dv">5</span></code></pre>
<p>Ihr seht dann, da√ü es eigentlich unerheblich ist, ob Ihr den St√∂rungsgteil der Formel addiert oder subtrahiert: Der Schmetterling ist nahezu identisch, lediglich an der anderen Farbgebung erkennt Ihr, da√ü es zwei verschiedene Formeln sind.</p>
<p>Die Schmetterlingskurve und √§hnliche Kurven wurden von <em>Temple Fay</em><a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> an der Universit√§t von Southern Mississpi entwickelt. Sie eignen sich vorz√ºglich zum Experimentieren. So weist Pickover<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> darauf hin, da√ü die Kurve</p>
<pre class="sourceCode python"><code class="sourceCode python">r = exp(cos(theta)) - <span class="fl">2.1</span>*cos(<span class="dv">6</span>*theta) + sin(theta/<span class="dv">30</span>)**<span class="dv">7</span></code></pre>
<p>eine bedeutend gr√∂√üere Wiederholungsperiode besitzt. Ihr solltet Euch auch das ruhig einmal ansehen. Interessante Vergleiche mit der Originalschmetterlingskurve k√∂nnen Ihr auch ziehen, wenn Ihr mit</p>
<pre class="sourceCode python"><code class="sourceCode python">r = exp(cos(<span class="dv">2</span>*theta)) - <span class="fl">1.5</span>*cos(<span class="dv">4</span>*theta)</code></pre>
<p>eine ganz simple Form des Schmetterlings zeichnen lasst. Denn die heutigen Rechner sind schlie√ülich hinreichend schnell, da√ü Ihr nicht mehr minuten- oder gar stundenlang auf ein Ergebnis warten m√º√üt und zum anderen l√§dt die M√∂glichkeit des schnellen Skizzierens mit der Processing-IDE geradezu zu eigenen Experimenten ein.</p>
<h2 id="der-lorenz-attraktor-eine-ikone-der-chaos-theorie">Der Lorenz-Attraktor, eine Ikone der Chaos-Theorie</h2>
<p>Nachdem ich im letzten Abschnitt die Schmetterlingskurve mit Processing.py gezeichnet hatte, wollte ich nun darauf aufbauen und eine Ikone der Chaos-Forschung, den <a href="https://de.wikipedia.org/wiki/Lorenz-Attraktor">Lorenz-Attraktor</a> damit zeichnen. Ich hatte das ja auch schon einmal <a href="http://blog.schockwellenreiter.de/essays/lorenzr.html">mit R getan</a> -- dort findet Ihr auch weitere Hintergrundinformationen zu diesem Attraktor --, aber mit R wurde nur das fertige Ergebnis visualisiert. Hier kommt es mir aber wieder darauf an, die Entstehung der Kurve verfolgen zu k√∂nnen und daf√ºr ist, wie schon bei der Schmetterlingskurve, Processing gut geeignet:</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32063849580/"><img src="images/lorenzprocessingpy.jpg" alt="Screenshot" /></a></p>
<p>Als einer der ersten hatte 1961 <a href="http://de.wikipedia.org/wiki/Edward%20N.%20Lorenz">Edward N. Lorenz</a>, ein Meteorologe am <a href="http://de.wikipedia.org/wiki/Massachusetts%20Institute%20of%20Technology">Massachusetts Institute of Technology</a> (MIT), erkannt, da√ü Iteration Chaos erzeugt. Er benutzte dort einen Computer, um ein einfaches nichtlineares Gleichungssystem zu l√∂sen, das ein simples Modell der Luftstr√∂mungen in der Erdatmosph√§re simulieren sollte. Dazu benutzte er ein System von sieben Differentialgleichungen, das <a href="http://www.yale.edu/opa/arc-ybc/v29.n18/story18.html">Barry Saltzman</a> im gleichen Jahr aus den <a href="http://de.wikipedia.org/wiki/Navier-Stokes-Gleichungen">Navier-Stokes-Gleichungen</a> <a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> hergeleitet hatte. F√ºr dieses System existierte keine analytische L√∂sung, also mu√üte es numerisch (d.h. wie damals und auch heute noch vielfach √ºblich in FORTRAN) gel√∂st werden. Lorenz hatte entdeckt, da√ü bei nichtperiodischen L√∂sungen der Gleichungen vier der sieben Variablen gegen Null strebten. Daher konnte er das System auf drei Gleichungen reduzieren:</p>

<!-- Dabei sind (sigma = -10), (\rho = 40) und (\gamma = - \frac{8}{3}). Die Parameter der Gleichung habe ich *[Herm1994]* entnommen, *[Stew1993]* gibt \\(\rho = 28\\) an, aber der Wert √§ndert nichts an dem Verhalten der Kurve und (\rho = 40) f√ºllt das Fenster einfach besser aus. üòú -->
<p>Processing.py besitzt im Gegensatz zu R oder <a href="http://cognitiones.kantel-chaos-team.de/programmierung/python/numpy.html">NumPy</a> kein Modul zur numerischen L√∂sung von Differentialgleichungen und so habe ich das einfache <a href="https://de.wikipedia.org/wiki/Explizites_Euler-Verfahren">Eulersche Poligonzugverfahren</a> zur numerischen Berechnung benutzt</p>
<pre class="sourceCode python"><code class="sourceCode python">    dx = -sigma*(x - y)*dt
    dy = (x*(r - z) - y)*dt
    dz = (x*y - b*z)*dt
    x += dx
    y += dy
    z += dz</code></pre>
<p>und dabei konstant <code>dt = 0.01</code> gesetzt. Das ben√∂tigt nat√ºrlich mehr Rechenkapazit√§t, als sie Lorenz je zur Verf√ºgung standen, aber trotz der gr√∂√üeren Genauigkeit √§ndert sich nichts am chaotischen Verhalten der Kurve. F√ºr die Farbberechnugn habe ich dieses mal nur den Farbwert (<em>Hue</em>) bei jeder Iteration ge√§ndert, S√§ttigung (<em>Saturation</em>) und Helligkeit (<em>Brightness</em>) bleiben konstant auf dem h√∂chsten Wert. Das ergibt kr√§ftige Farben, die von Rot √ºber Orange nach Gelb und dann nach Gr√ºn, Blau und Violett wandern. So kann man sch√∂n erkennen, da√ü die beiden ¬ªFl√ºgel¬´ des Attraktors immer wieder, aber f√ºr uns unvorhersehbar, durchlaufen werden.</p>
<h3 id="der-quellcode-2">Der Quellcode</h3>
<p>Hier nun der vollst√§ndige Quellcode des Skripts. Er ist kurz und selbsterkl√§rend und folgt weitestgehend dem Pascal-Programm aus <em>[Herm1994]</em>, Seiten 80ff.</p>
<pre class="sourceCode python"><code class="sourceCode python">b = <span class="fl">8.0</span>/<span class="dv">3</span>
r = <span class="fl">40.0</span>
sigma = <span class="fl">10.0</span>
dt = <span class="fl">0.01</span>
x = y = <span class="fl">0.01</span>
z = t = <span class="fl">0.0</span>
xOld = zOld = <span class="fl">0.0</span>
first = <span class="ot">True</span>

<span class="kw">def</span> setup():
    size(<span class="dv">640</span>, <span class="dv">480</span>)
    background(<span class="dv">0</span>)
    colorMode(HSB, <span class="dv">100</span>)

<span class="kw">def</span> draw():
    <span class="kw">global</span> x, y, z, t, xOld, zOld
    <span class="kw">global</span> first
    strokeWeight(<span class="dv">1</span>)
    stroke(t, <span class="dv">100</span>, <span class="dv">100</span>)
    dx = -sigma*(x - y)*dt
    dy = (x*(r - z) - y)*dt
    dz = (x*y - b*z)*dt
    x += dx
    y += dy
    z += dz
    <span class="co"># auf Fenstergr√∂√üe skalieren</span>
    xx = (x*<span class="dv">8</span>) + <span class="dv">320</span>
    zz = <span class="dv">470</span> - (z*<span class="fl">5.5</span>)
    <span class="kw">if</span> first:
        point(xx, zz)
    <span class="kw">else</span>:
       line(xOld, zOld, xx, zz)
    xOld = xx
    zOld = zz
    first = <span class="ot">False</span> 
    t = t + dt
    <span class="kw">if</span> ( t &gt;= <span class="fl">75.0</span>):
       <span class="dt">print</span>(<span class="st">&quot;I did it, Babe!&quot;</span>)
       noLoop()</code></pre>
<h3 id="links">Links</h3>
<ul>
<li>Der <em><a href="http://mathworld.wolfram.com/LorenzAttractor.html">Lorenz Attractor</a></em> auf Wolfram MathWorld</li>
</ul>
<h3 id="literatur-3">Literatur</h3>
<ul>
<li><em>[Herm1994]</em> Dieter Hermann: <em><a href="http://www.amazon.de/gp/product/3893196331/ref=as_li_ss_tl?ie=UTF8&camp=1638&creative=19454&creativeASIN=3893196331&linkCode=as2&tag=derschockwell-21">Algorithmen f√ºr Chaos und Fraktale</a><img src="http://www.assoc-amazon.de/e/ir?t=derschockwell-21&l=as2&o=3&a=3893196331" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></em>, Bonn (Addison-Wesley) 1994, S. 80ff.</li>
<li><em>[Pief1991]</em> Frank Piefke: <em><a href="http://www.amazon.de/gp/product/3778519158/ref=as_li_ss_tl?ie=UTF8&camp=1638&creative=19454&creativeASIN=3778519158&linkCode=as2&tag=derschockwell-21">Simulationen mit dem Personalcomputer</a><img src="http://www.assoc-amazon.de/e/ir?t=derschockwell-21&l=as2&o=3&a=3778519158" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></em>, Heidelberg (H√ºthig) 1991</li>
<li><em>[Stew1993]</em> Ian Stewart: <em><a href="http://www.amazon.de/gp/product/345833243X/ref=as_li_ss_tl?ie=UTF8&camp=1638&creative=19454&creativeASIN=345833243X&linkCode=as2&tag=derschockwell-21">Spielt Gott Roulette?</a><img src="http://www.assoc-amazon.de/e/ir?t=derschockwell-21&l=as2&o=3&a=345833243X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></em>, Frankfurt (Insel TB) 1993</li>
</ul>
<h1 id="shapes">Shapes</h1>
<h2 id="for-your-eyes-only-processing.py-zieht-kreise">For Your Eyes Only ‚Äì Processing.py zieht Kreise</h2>
<p>Nachdem ich in den vorherigen Tutorials zu Processing.py, dem Python-Mode von Processing, schon mit Punkten und Linien hantiert habe, wird es nun Zeit, etwas mit Kreisen und Ellipsen anzustellen (sie werden in Processing mit dem gleichen Befehl erzeugt).</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/31784433034/"><img src="images/foryoureyesonly.jpg" alt="Screenshot" /></a></p>
<p>Ein einfacher Kreis ist schnell erzeugt. Mit diesem kleinen <em>Sketch</em> malt Ihr einen grellroten Kreis auf schwarzem Grund:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    size(<span class="dv">500</span>, <span class="dv">500</span>)

<span class="kw">def</span> draw():
    background(<span class="dv">0</span>)
    fill(<span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">0</span>)
    ellipse(width/<span class="dv">2</span>, height/<span class="dv">2</span>, <span class="dv">450</span>, <span class="dv">450</span>)</code></pre>
<p>Die Funktion <code>ellipse()</code> besitzt vier Parameter, die ersten beiden sind die x- und y-Koordinaten, die per Default die Mitte des Kreises oder der Ellipse bezeichnen, die beiden anderen sind der Durchmesser des Kreises oder der Ellipse (auch wenn sie in der Literatur oft mit <code>r</code> bezeichnet werden, nicht der Radius). Bei einem Kreis m√ºssen die letzten beiden Parameter immer den gleichen Wert besitzen. Wenn Ihr aber zum Beispiel die Funktion mit</p>
<pre class="sourceCode python"><code class="sourceCode python">    ellipse(width/<span class="dv">2</span>, height/<span class="dv">2</span>, <span class="dv">350</span>, <span class="dv">450</span>)</code></pre>
<p>oder</p>
<pre class="sourceCode python"><code class="sourceCode python">    ellipse(width/<span class="dv">2</span>, height/<span class="dv">2</span>, <span class="dv">450</span>, <span class="dv">350</span>)</code></pre>
<p>aufruft, dann seht Ihr, wie aus den Kreisen Ellipsen werden.</p>
<p>Nun steht Processing aber f√ºr Interaktivit√§t. Daher m√∂chte ich aus f√ºnf Kreisen ein Gesicht zaubern, dessen Pupillen dem Mauszeiger folgen. Auch dieser <em>Sketch</em> ist h√ºbsch kurz geraten:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    size(<span class="dv">300</span>, <span class="dv">300</span>)
    strokeWeight(<span class="dv">3</span>)

<span class="kw">def</span> draw():
    background(<span class="dv">139</span>, <span class="dv">134</span>, <span class="dv">130</span>)
    face()
    eye(<span class="dv">110</span>, height/<span class="dv">2</span>)
    eye(<span class="dv">190</span>, height/<span class="dv">2</span>)

<span class="kw">def</span> face():
    fill(<span class="dv">244</span>, <span class="dv">244</span>, <span class="dv">0</span>)
    ellipse(width/<span class="dv">2</span>, height/<span class="dv">2</span>, <span class="dv">160</span>, <span class="dv">160</span>)

<span class="kw">def</span> eye(x, y):
    fill(<span class="dv">255</span>)
    ellipse(x, y, <span class="dv">60</span>, <span class="dv">60</span>)
    <span class="co"># Die Pupillen folgen der Maus</span>
    mx = mouseX - x
    my = mouseY - y
    fill(<span class="dv">50</span>)
    ellipse(x + mx/<span class="dv">12</span>, y + my/<span class="dv">12</span>, <span class="dv">25</span>, <span class="dv">25</span>)</code></pre>
<p>Es w√§re nicht wirklich notwendig gewesen, aber der Modularit√§t willen habe ich das Zeichnen des Gesichtes in die Funktion <code>face()</code> und das Zeichnen der Augen in die Funtion <code>eye()</code> ausgelagert. Mit den Werten in dem <code>ellipse()</code>-Aufruf bei den Augen habe ich solange experimentiert, bis sie meinen Vorstellungen entsprachen. Nun sieht aber alles aus wie in dem obigen Screenshot.</p>
<h3 id="credits">Credits</h3>
<p>Die Idee zu den Augen habe ich einem <a href="https://lernprocessing.wordpress.com/2010/01/10/funktionen/">(Java-) Processing-Tutorial</a> von <em>Thomas Koberger</em> entnommen, das ich variiert und nach Processing.py √ºbertragen habe. Auf <a href="https://lernprocessing.wordpress.com/2010/01/18/processing-links/">seinen Seiten</a> findet man √ºbrigens noch viele weitere, interessante und lehrreiche Tutorials, so da√ü ich Euch einen Besuch dort empfehle.</p>
<p>F√ºr die Farben habe ich mal wieder wild nach einer <a href="http://www.farb-tabelle.de/de/farbtabelle.htm">Seite mit Farbpaletten</a> gegoogelt und fand die gefundene dann zwar nicht unbedingt sch√∂n, aber ungemein praktisch.</p>
<h2 id="spa√ü-mit-kreisen-konfetti">Spa√ü mit Kreisen: Konfetti</h2>
<p>Der folgende kleine Sketch ist nicht mehr als eine Finger√ºbung. Er soll Euch zeigen, wie man schon mit wenigen Zeilen Code und Processings-Zufallsfunktion <code>random()</code> viele bunte Konfetti-Schnipsel auf den Bildschirm zaubern kann:</p>
<figure>
<img src="images/konfetti.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Und hier der Quellcode des Sketches in Processing.py:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    size(<span class="dv">400</span>, <span class="dv">400</span>)
    frame.setTitle(<span class="st">&quot;Konfetti!&quot;</span>)
    background(<span class="dv">0</span>)

<span class="kw">def</span> draw():
    x = random(width)
    y = random(height)
    dia = random(<span class="dv">5</span>, <span class="dv">25</span>)
    r = random(<span class="dv">255</span>)
    g = random(<span class="dv">255</span>)
    b = random(<span class="dv">255</span>)
    fill(r, g, b)
    ellipse(x, y, dia, dia)</code></pre>
<p>F√ºr so wenige Programmzeilen ist das Ergebnis doch recht ansprechend, oder?</p>
<h2 id="syntaktischer-zucker-with-in-processing.py">Syntaktischer Zucker: ¬ªwith¬´ in Processing.py</h2>
<p>Wenn man in Processing.py irgendetwas zum Beispiel zwischen <code>beginShape()</code> und <code>endShape()</code> klammert, f√ºhlt sich das nicht sehr ¬ªpythonisch¬´ an. Ich denke dann die ganze Zeit: Das geh√∂rt doch einger√ºckt! In Processings Java-Mode kann man das auch machen, weil man in Java Leerzeichen einsetzen kann, wie man will -- sie haben dort keine Bedeutung. Doch Python reagiert ja sehr sensibel auf Einr√ºckungen, da hier Leerzeichen Teil der Syntax sind. Aber die Macher von Processing.py haben dies bedacht und uns einen Ausweg aus diesem Dilemma geboten: Das <code>with</code>-Statement.</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32680422996/"><img src="images/withprocessingpy.jpg" alt="Screenshot" /></a></p>
<p>In seiner einfachsten Form sieht das so aus. Statt zum Beispiel</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    size(<span class="dv">400</span>, <span class="dv">400</span>)
    background(<span class="dv">255</span>)

<span class="kw">def</span> draw():
    fill(color(<span class="dv">255</span>,  <span class="dv">153</span>,  <span class="dv">0</span>))
    strokeWeight(<span class="dv">1</span>)
    ellipse(<span class="dv">100</span>, <span class="dv">100</span>, <span class="dv">50</span>, <span class="dv">50</span>)
    fill(color(<span class="dv">255</span>,  <span class="dv">51</span>,  <span class="dv">51</span>))
    strokeWeight(<span class="dv">5</span>)
    ellipse(<span class="dv">200</span>, <span class="dv">200</span>, <span class="dv">50</span>, <span class="dv">50</span>)
    fill(color(<span class="dv">255</span>,  <span class="dv">153</span>,  <span class="dv">0</span>))
    strokeWeight(<span class="dv">1</span>)
    ellipse(<span class="dv">300</span>, <span class="dv">300</span>, <span class="dv">50</span>, <span class="dv">50</span>)</code></pre>
<p>zu schreiben, schreibt man einfach:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    size(<span class="dv">400</span>, <span class="dv">400</span>)
    background(<span class="dv">255</span>)
    

<span class="kw">def</span> draw():
    fill(color(<span class="dv">255</span>,  <span class="dv">153</span>,  <span class="dv">0</span>))
    ellipse(<span class="dv">100</span>, <span class="dv">100</span>, <span class="dv">50</span>, <span class="dv">50</span>)
    
    <span class="kw">with</span> pushStyle():
        fill(color(<span class="dv">255</span>,  <span class="dv">51</span>,  <span class="dv">51</span>))
        strokeWeight(<span class="dv">5</span>)
        ellipse(<span class="dv">200</span>, <span class="dv">200</span>, <span class="dv">50</span>, <span class="dv">50</span>)
    ellipse(<span class="dv">300</span>, <span class="dv">300</span>, <span class="dv">50</span>, <span class="dv">50</span>)</code></pre>
<p>Die Ausgabe ist in beiden F√§llen identisch, aber der zweite Sketch ist in meinen Augen bedeutend eleganter und f√ºhlt sich viel pythonischer an. Au√üerdem erspart man sich viel Tipparbeit. üòú</p>
<p>Da ich die Verwendung des <code>with</code>-Statements auch erst durch eines der mitgelieferten Beispielprogramme herausbekommen habe, hier eine (hoffentlich) komplette Liste der M√∂glichkeiten:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">with</span> pushMatrix():          pushMatrix()
        translate(<span class="dv">10</span>, <span class="dv">10</span>)       translate(<span class="dv">10</span>, <span class="dv">10</span>)
        rotate(PI/<span class="dv">3</span>)            rotate(PI/<span class="dv">3</span>)
        rect(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">10</span>)      rect(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">10</span>)
    rect(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">10</span>)          popMatrix()
                                rect(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">10</span>)

<span class="kw">with</span> beginContour():             beginContour()
    doSomething()                doSomething()
                                 endContour()


<span class="kw">with</span> beginCamera():              beginCamera()
    doSomething()                doSomething()
                                 endCamera()

<span class="kw">with</span> beginPGL():                 beginPGL()
    doSomething()                doSomething()
                                 endPGL()

<span class="kw">with</span> beginShape():               beginShape()
    vertex(x, y)                 vertex(x, y)
    vertex(j, k)                 vertex(j,k)
                                 endShape()
    
    
<span class="kw">with</span> beginShape(TRIANGLES):      beginShape(TRIANGLES)
    vertex(x, y)                 vertex(x, y)
    vertex(j, k)                 vertex(x, y)
                                 endShape()

<span class="kw">with</span> beginClosedShape():         beginShape()
    vertex(x, y)                 vertex(x, y)
    vertex(j, k)                 vertex(j, k)
                                 endShape(CLOSED)</code></pre>
<p>Links steht die Schreibweise mit dem <code>with()-Statement</code>, rechts die traditionelle Form. Abgesehen davon, da√ü die <code>with</code>-Schreibweise immer mindestens eine Zeile k√ºrzer ist, sorgt sie durch die Einr√ºckungen auch f√ºr eine bessere √úbersicht und eine bessere Lesbarkeit.</p>
<h2 id="spa√ü-mit-kreisen-in-processing.py-cantor-k√§se-und-mehr">Spa√ü mit Kreisen in Processing.py: Cantor-K√§se und mehr</h2>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32606723246/"><img src="images/keincantorkaese-s.jpg" alt="Kein Cantor-K√§se" /></a></p>
<p>Wie im letzten Beitrag gezeigt, ist es in Processing (und damit auch in Processing.py, dem Python-Mode f√ºr Processing) recht einfach, einfache Kreise oder Ellipsen zu zeichnen. Aber das ist auf die Dauer nat√ºrlich ein wenig langweilig, daher wende ich mich nun einer rekursiven Figur zu, die zwar ebenfalls nur aus Kreisen besteht, aber dennoch einige interessante Eigenschaften aufweist, dem <strong>Cantor-K√§se</strong>, einer Figur, die der <a href="https://de.wikipedia.org/wiki/Cantor-Menge">Cantor-Menge</a> topologisch √§hnlich ist. Sie wird konstruiert, in dem aus einem Kreis bis auf zwei kleinere Kreise alles entfernt wird. Aus diesen zwei kleineren Kreisen wird wiederum bis auf zwei kleinere Kreise alles entfernt. Nun hat man schon vier Kreise, aus denen man jeweils bis auf zwei kleinere Kreise alles entfernt. Und so weiter und so fort ‚Ä¶</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32268180540/"><img src="images/cantorcheeseprocpy.jpg" alt="Cantor-K√§se" /></a></p>
<p>Das schreit nat√ºrlich nach einer rekursiven Funktion und die ist in Python (genauer: in Processings Python-Mode) recht schnell erstellt:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    size(<span class="dv">500</span>, <span class="dv">500</span>)
    <span class="co"># colorMode(HSB, 100, 100, 100)</span>
    noLoop()

<span class="kw">def</span> draw():
    cheese(width/<span class="dv">2</span>, height/<span class="dv">2</span>, <span class="dv">500</span>, <span class="dv">10</span>)

<span class="kw">def</span> cheese(x, y, r, level):
    ellipse(x, y, r, r)
    <span class="kw">if</span> (level &gt; <span class="dv">1</span>):
        cheese(x - r/<span class="dv">4</span>, y, r/<span class="dv">2</span>, level<span class="dv">-1</span>)
        cheese(x + r/<span class="dv">4</span>, y, r/<span class="dv">2</span>, level<span class="dv">-1</span>)</code></pre>
<p>Das Ergebnis k√∂nnt Ihr in obenstehenden Screenshot bewundern. Im Screenshot sieht man noch, da√ü ich auch versucht habe, mit Farbe zu experimentieren, aber ein wirklich befriedigendes Ergebnis war dabei nicht herausgekommen</p>
<p>Ich hatte diese Figur auch schon mal in <a href="http://blog.schockwellenreiter.de/2016/05/2016050302.html">Shoes zeichnen lassen</a> und dabei Porbleme mit der Rekursiontiefe festgestellt (ab einer Rekursionstiefe von 15 st√ºrzte Shoes gnadenlos ab). Hier scheint Processing robuster zu sein, eine Rekursionstiefe von 15 nahm die Software gelassen hin, lie√ü sich dann nat√ºrlich Zeit mit der Ausgabe. Das mu√ü schlie√ülich alles berechnet werden.</p>
<p>Weil der Durchmesser der Kreise in der Literatur oft mit <code>r</code> bezeichnet wird, neige ich dazu, Radius und Durchmesser zu verwechseln. Setzt man dann den Algorithmus 1:1 um, zum Beispiel wie in diesem Sketch</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    size(<span class="dv">1000</span>, <span class="dv">500</span>)
    noLoop()

<span class="kw">def</span> draw():
    cheese(width/<span class="dv">2</span>, height/<span class="dv">2</span>, <span class="dv">500</span>, <span class="dv">10</span>)

<span class="kw">def</span> cheese(x, y, r, level):
    ellipse(x, y, r, r)
    <span class="kw">if</span> (level &gt; <span class="dv">1</span>):
        cheese(x - r/<span class="dv">2</span>, y, r/<span class="dv">2</span>, level<span class="dv">-1</span>)
        cheese(x + r/<span class="dv">2</span>, y, r/<span class="dv">2</span>, level<span class="dv">-1</span>)</code></pre>
<p>kommt die Figur heraus, die den Kopf dieses Beitrages ziert. Das ist zwar streng genommen kein Cantor-K√§se mehr, aber dennoch ein interessantes Ergebnis. Das macht den Vorteil des schnellen Skizzierens in Processing aus: Selbst Fehler k√∂nnen unerwartete und notierenswerte Ergebnisse liefern. Man hebt dann den Sketch einfach auf.</p>
<h3 id="cantors-doppelk√§se">Cantors Doppelk√§se</h3>
<p>Schon bei meinen Experimenten mit Shoes <a href="http://blog.schockwellenreiter.de/2016/09/2016091601.html">hatte ich mich gefragt</a>, wie es denn auss√§he, wenn man diese Figur sich nicht nur in der Horizontalen, sondern auch in der Vertikalen ausbreiten l√§√üt?</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32494534752/"><img src="images/doppelkaeseprocpy.jpg" alt="Doppelk√§se" /></a></p>
<p>Dabei habe ich auch gleich ein interaktives Element eingef√ºhrt: Startet man das Programm, zeigt es zuerst nur ein wei√ües Fenster, nach dem ersten Mausklick sieht man die erste Rekursionstiefe, einen einfachen Kreis, der n√§chste Mausklick zeigt vier darin eingeschriebene Kreise, der n√§chste Mausklick zeigt dann in jedem der kleinen Kreise wiederum vier eingeschriebene Kreise und so weiter und so fort ‚Ä¶</p>
<pre class="sourceCode python"><code class="sourceCode python">maxlevel = <span class="dv">7</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> i
    i = <span class="dv">1</span>
    size(<span class="dv">500</span>, <span class="dv">500</span>)
    <span class="co"># colorMode(HSB, 100, 100, 100)</span>
    background(<span class="dv">255</span>)
    noFill()

<span class="kw">def</span> draw():
    <span class="kw">pass</span>

<span class="kw">def</span> cheese(x, y, r, level):
    ellipse(x, y, r, r)
    <span class="kw">if</span> (level &gt; <span class="dv">1</span>):
        cheese(x - r/<span class="dv">4</span>, y, r/<span class="dv">2</span>, level<span class="dv">-1</span>)
        cheese(x, y - r/<span class="dv">4</span>, r/<span class="dv">2</span>, level<span class="dv">-1</span>)
        cheese(x + r/<span class="dv">4</span>, y, r/<span class="dv">2</span>, level<span class="dv">-1</span>)
        cheese(x, y + r/<span class="dv">4</span>, r/<span class="dv">2</span>, level<span class="dv">-1</span>)

<span class="kw">def</span> mousePressed():
    <span class="kw">global</span> i
    cheese(width/<span class="dv">2</span>, height/<span class="dv">2</span>, <span class="dv">500</span>, i)
    i += <span class="dv">1</span>
    <span class="kw">if</span> (i &gt;= maxlevel):
        noLoop()</code></pre>
<p>Das Programm stoppt dann bei einer Rekursionstiefe von sieben. Auch hier ist Processing robuster als Shoes, h√∂here Rekursionstiefen waren kein Problem, nur man sah dann nicht viel mehr als ein auf der Spitze stehendes Quadrat mit ein paar Ausbuchtungen -- die Aufl√∂sung des Bildschirms setzt hier neuem Erkenntnisgewinn Grenzen.</p>
<p>Interessant und neu f√ºr mich war, da√ü man -- um √ºberhaupt ein Zeichenfenster zu bekommen, in das man mit der Maus klicken konnte -- eine leere <code>draw()</code>-Funktion ben√∂tigte. Eigentlich logisch, aber ich hatte vorher nie dar√ºber nachgedacht.</p>
<h3 id="literatur-4">Literatur</h3>
<ul>
<li>Clifford A. Pickover: <em><a href="http://www.amazon.de/gp/product/3877913237/ref=as_li_tl?ie=UTF8&amp;camp=1638&amp;creative=19454&amp;creativeASIN=3877913237&amp;linkCode=as2&amp;tag=derschockwell-21">Mit den Augen des Computers. Phantastische Welten aus dem Geist der Maschine</a></em>, M√ºnchen (Markt und Technik) 1992. Diese deutsche √úbersetzung von <em>Computers and the Imagination</em> ist eine geniale Fundgrube f√ºr alle, die Simulationen und mathematische Spielereien mit dem Computer lieben. Es ist eines der besten B√ºcher <a href="http://cognitiones.kantel-chaos-team.de/personen/pickover.html">Pickovers</a>. Dem Cantor-K√§se ist auf den Seiten 171-181 ein eigenes Kapitel gewidmet.</li>
<li>Chris Robart: <em><a href="http://mmhs.ca/compsci/ideas2.pdf">Programming Ideas: For Teaching High School Computer Programming</a></em>, (&lt;%= imageref(&quot;pdf&quot;) %&gt; 260 KB, 2nd Edition) 2001. Ebenfalls eine Fundgrube voller Ideen, deren Download sich in jedem Fall lohnt.</li>
</ul>
<h2 id="weitere-geometrische-grundformen">Weitere geometrische Grundformen</h2>
<p>Processing besitzt ein kleines Set von geometrischen Primitiven in 2D (im Englischen <em>Shapes</em> genannt) mit denen sich so einiges anstellen l√§√üt. Neben den schon bekannten Punkten und Kreisen und Ellipsen, gibt es noch einige andere, die ich der Reihe nach vorstellen m√∂chte:</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32867269721/"><img src="images/shapes.jpg" alt="Screenshot" /></a></p>
<h3 id="rechtecke">Rechtecke</h3>
<p>Rechtecke (<code>rect()</code>) sind die einfachste Grundform. Dennoch besitzen auch sie einige Besonderheiten. Es gibt sie n√§mlich in der Form</p>
<pre class="sourceCode python"><code class="sourceCode python">rect(x, y, w, h)
rect(x, y, w, h, r)
rect(x, y, w, h, tl, tr, br, bl)</code></pre>
<p>Bei vier Parametern sind die ersten beiden Parameter, die x- und y-Koordinate der linken, oberen Ecke des Rechtecks und die beiden anderen Parameter geben die Breite und H√∂he des Rechtecks an. Gilt <code>w == h</code>, dann ist das Rechteck nat√ºrlich ein Quadrat.</p>
<p>Wird <code>rect()</code> mit f√ºnf Parametern aufgerufen, dann ist der f√ºnfte Parameter als Radius f√ºr die Abrundung der Ecken verantwortlich. Mit acht Paramtern bekommt jede Ecke einen eigenen Radius f√ºr die abgerundeten Ecken einen eigenen Radius zugeschrieben. Dabei wird von <em>links oben</em> √ºber <em>rechts oben</em> und <em>rechts unten</em> nach <em>links unten</em> vorgegangen.</p>
<p>Rechtecke besitzen per Default den <code>rectMode(CORNER)</code>. Wird ein anderer <code>rectMode()</code> eingegeben, dann √§ndert sich die Bedeutung des dritten und vierten Parameters. Ist er <code>CORNERS</code>, dann bennen die ersten beiden Paramter weiterhin die linke, obere Ecke, der dritte und vierte Parameter aber die x- und y-Koordinaten der rechten, unteren Ecke.</p>
<p>Ist der <code>rectMode(CENTER)</code>, dann bennen die ersten beiden Parameter den Mittelpunkt des Rechteckes, der dritte und vierte Parameter gibt aber weiterhin die Breite und H√∂he des Rechtecks an.</p>
<p>Dahingegen sind beim <code>rectMode(RADIUS)</code> die ersten beiden Paramter die x- und y-Koordinaten des Mittelpunkts des Rechtecks, w√§hrend die dritte und vierte Koordinate jeweils die H√§lfte der Breite und die H√§lfte der H√∂he angeben.</p>
<p>Der <code>rectMode(CENTER)</code> ist vor allen Dingen dann vom Vorteil, wenn Rechtecke mit Kreisen oder Ellipsen koordiniert werden, da bei diesen per Default <code>ellipseMode(CENTER)</code> gilt. Zu diesen kommen ich daher im Anschlu√ü <a href="http://py.kantel-chaos-team.de/foryoureyesonly/">noch einmal</a>.</p>
<h3 id="kreise-und-ellipsen">Kreise und Ellipsen</h3>
<p>Ellipsen und Kreise (als Spezialform der Ellipse) werden in Processing mit dem Befehl</p>
<pre class="sourceCode python"><code class="sourceCode python">ellipse(x, y, w, h)</code></pre>
<p>erzeugt. Dabei sind <code>x</code> und <code>y</code> der Mittelpunkt der Ellipse und <code>w</code> und <code>h</code> per Default die Breite und H√∂he der Ellipse. Sind <code>w == h</code>, dann bildet die Ellipse einen Kreis.</p>
<p>√Ñndert man jedoch den Default-Mode <code>CENTER</code>, dann ergeben sich folgende Bedeutungs√§nderungen der vier Parameter.</p>
<p>Beim <code>ellipseMode(RADIUS)</code> bilden die ersten beiden Parameter weiterhin den Mittelpunkt der Ellipse oder des Kreises, der dritte und vierte Parameter gibt jedoch die H√§lfte der H√∂he und die H√§lfte der Breite der Ellipse oder des Kreises an.</p>
<p>Ist der <code>ellipseMode(CORNER)</code>, dann benennen die x- und y-Koordinaten die linke, obere Ecke der Ellipse oder des Kreises, die beiden anderen Parameter geben weiterhin die Breite und H√∂he an.</p>
<p>Hei√üt es jedoch <code>ellipseMode(CORNERS)</code>, dann bennenen die x- und y-Koordinaten die linke, obere Ecke des die Ellipse oder den Kreis umschlie√üenden Rechtecks, der dritte und vierte Parameter die rechte untere Ecke dieses Rechtecks.</p>
<p>!!! tip &quot;Achtung&quot; Die Modes <code>CORNER</code>, <code>CORNERS</code>, <code>CENTER</code> und <code>RADIUS</code> m√ºssen immer in Gro√übuchstaben eingegeben werden, da Processing und Python streng zwischen Gro√ü- und Kleinschreibung unterscheiden.</p>
<h3 id="dreieck">Dreieck</h3>
<p>Das Dreieick ist eines der einfachsten geometrischen Grundformen in Processing. Es existiert nur in der Form</p>
<pre class="sourceCode python"><code class="sourceCode python">triangle(x1, y1, x2, y2, x3, y3)</code></pre>
<p>und hat auch keinen besonderen Mode. Die jeweiligen x- und y-Koordinagen sind die Koordinaten des ersten, zweiten und dritten Punktes. Bei der Reihenfolge wird -- oben beginnend -- immer im Uhrzeigersinn vorgegangen. Das ist alles.</p>
<h3 id="unregelm√§√üige-vierecke">Unregelm√§√üige Vierecke</h3>
<p>√Ñhnlich einfach verh√§lt es sich mit den unregelm√§√üigen Vierecken. Sie werden mit</p>
<pre class="sourceCode python"><code class="sourceCode python">quad(x1, y1, x2, y2, x3, y3, x4, y4)</code></pre>
<p>erzeugt und auch hier sind es absolute Koordinaten und das Gebilde besitzt ebenfalls keinen besonderen Mode. Auch hier wird bei der Z√§hlung links oben begonnen und dann werden die Ecken ebenfalls im Uhrzeigersinn abgearbeitet.</p>
<h3 id="kreisb√∂gen">Kreisb√∂gen</h3>
<p>Kreisb√∂gen sind mit der Ellipse (genauer: dem Kreis verwandt) und besitzen die gleichen Modi wie diese (mit dem gleichen Default <code>CENTER</code>). Sie werden wie folgt aufgerufen:</p>
<pre class="sourceCode python"><code class="sourceCode python">arc(x, y, w, h, start, stop)
arc(x, y, w, h, start, stop, mode)</code></pre>
<p>Die x- und y-Koordinaten sind im Default-Mode der Mittelpunkt des Kreises, w√§hrend <code>w</code> und <code>h</code> im Default-Mode die Breite und H√∂he des Kreisen angeben. <code>start</code> und <code>stop</code> sind die Winkel (in <em>radians</em>) f√ºr die L√§nge des Kreisbogens.</p>
<p>Dann gibt es hier noch einen besonderen <code>mode</code>. Der kann <code>OPEN</code> (das ist der Default), <code>CHORD</code> oder <code>PIE</code> hei√üen. Im Default <code>OPEN</code> bleibt der Kreisbogen offen, falls es jedoch ein <code>fill()</code> gibt, wird er dennoch gef√ºllt. Bei <code>CHORD</code> wird der Kreisbogen geschlossen und bei <code>PIE</code> bildet er ein Kuchenst√ºck, wie man es von Tortengraphiken kennt.</p>
<h3 id="der-quelltext">Der Quelltext</h3>
<p>In diesem Beispielprogramm habe ich alle angesprochenen geometrischen Primitive in ihren diversen Erscheinungsformen zeichnen lassen. Mit dem oben geschriebenen d√ºrfte es einfach nachzuvollziehen ein.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    size(<span class="dv">640</span>, <span class="dv">640</span>)
    frame.setTitle(<span class="st">&quot;Geometrische Grundformen in Processing.py&quot;</span>)
    <span class="co"># noLoop()</span>

<span class="kw">def</span> draw():
    background(<span class="dv">255</span>)
    drawGrid()
    stroke(<span class="dv">0</span>)
    
    <span class="co"># Rechtecke</span>
    <span class="kw">with</span> pushStyle():
        fill(<span class="dv">255</span>,<span class="dv">127</span>,<span class="dv">36</span>)
        rect(<span class="dv">20</span>, <span class="dv">20</span>, <span class="dv">120</span>, <span class="dv">120</span>)
        rect(<span class="dv">180</span>, <span class="dv">20</span>, <span class="dv">120</span>, <span class="dv">120</span>, <span class="dv">20</span>)
        rect(<span class="dv">340</span>, <span class="dv">20</span>, <span class="dv">120</span>, <span class="dv">120</span>, <span class="dv">20</span>, <span class="dv">10</span>, <span class="dv">40</span>, <span class="dv">80</span>)
        rect(<span class="dv">500</span>, <span class="dv">60</span>, <span class="dv">120</span>, <span class="dv">80</span>)
    
    <span class="co"># Kreise und Ellipsen</span>
    <span class="kw">with</span> pushStyle():
        fill(<span class="dv">107</span>, <span class="dv">142</span>, <span class="dv">35</span>)
        ellipse(<span class="dv">80</span>, <span class="dv">240</span>, <span class="dv">120</span>, <span class="dv">120</span>)
        ellipse(<span class="dv">240</span>, <span class="dv">240</span>, <span class="dv">120</span>, <span class="dv">80</span>)
        ellipse(<span class="dv">400</span>, <span class="dv">240</span>, <span class="dv">80</span>, <span class="dv">120</span>)
    
    <span class="co"># Dreiecke</span>
    <span class="kw">with</span> pushStyle():
        fill(<span class="dv">255</span>, <span class="dv">236</span>, <span class="dv">139</span>)
        triangle(<span class="dv">560</span>, <span class="dv">180</span>, <span class="dv">620</span>, <span class="dv">300</span>, <span class="dv">500</span>, <span class="dv">300</span>)
        triangle(<span class="dv">20</span>, <span class="dv">340</span>, <span class="dv">140</span>, <span class="dv">460</span>, <span class="dv">20</span>, <span class="dv">460</span>)
        
    <span class="co"># Vierecke</span>
    <span class="kw">with</span> pushStyle():
        fill(<span class="dv">193</span>, <span class="dv">205</span>, <span class="dv">193</span>)
        quad(<span class="dv">180</span>, <span class="dv">340</span>, <span class="dv">300</span>, <span class="dv">340</span>, <span class="dv">300</span>, <span class="dv">400</span>, <span class="dv">180</span>, <span class="dv">460</span>)
        quad(<span class="dv">400</span>, <span class="dv">340</span>, <span class="dv">460</span>, <span class="dv">400</span>, <span class="dv">400</span>, <span class="dv">460</span>, <span class="dv">340</span>, <span class="dv">400</span>)
        quad(<span class="dv">500</span>, <span class="dv">340</span>, <span class="dv">620</span>, <span class="dv">400</span>, <span class="dv">500</span>, <span class="dv">460</span>, <span class="dv">560</span>, <span class="dv">400</span>)
    
    <span class="co"># Kreisb√∂gen</span>
    <span class="kw">with</span> pushStyle():
        fill(<span class="dv">204</span>, <span class="dv">53</span>, <span class="dv">100</span>)
        arc(<span class="dv">80</span>, <span class="dv">560</span>, <span class="dv">120</span>, <span class="dv">120</span>, <span class="dv">0</span>, HALF_PI)
        <span class="kw">with</span> pushStyle():
            noFill()
            arc(<span class="dv">80</span>, <span class="dv">560</span>, <span class="dv">130</span>, <span class="dv">130</span>, HALF_PI, PI)
            arc(<span class="dv">80</span>, <span class="dv">560</span>, <span class="dv">140</span>, <span class="dv">140</span>, PI, PI+QUARTER_PI)
            arc(<span class="dv">80</span>, <span class="dv">560</span>, <span class="dv">150</span>, <span class="dv">150</span>, PI+QUARTER_PI, TWO_PI)
        arc(<span class="dv">240</span>, <span class="dv">560</span>, <span class="dv">120</span>, <span class="dv">120</span>, <span class="dv">0</span>, PI+QUARTER_PI, OPEN)
        arc(<span class="dv">400</span>, <span class="dv">560</span>, <span class="dv">120</span>, <span class="dv">120</span>, <span class="dv">0</span>, PI+QUARTER_PI, CHORD)
        arc(<span class="dv">560</span>, <span class="dv">560</span>, <span class="dv">120</span>, <span class="dv">120</span>, QUARTER_PI, TWO_PI-QUARTER_PI, PIE)
    

<span class="kw">def</span> drawGrid():
    stroke(<span class="dv">200</span>, <span class="dv">200</span>, <span class="dv">255</span>)
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">0</span>, width, <span class="dv">20</span>):
        line(i, <span class="dv">0</span>, i, height)
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">0</span>, height, <span class="dv">20</span>):
        line(<span class="dv">0</span>, i, width, i)</code></pre>
<p>Ich habe das Fenster mit einem 20 x 20 Pixel gro√üen Raster wie auf kariertem Schulpapier versehen, damit Ihr die Eckpunkte der einzelnen Shapes ausz√§hlen k√∂nnt, falls Euch die Koordinaten nicht sofort klar werden.</p>
<h3 id="credits-1">Credits</h3>
<p>Teilweise folgt dieser Sketch einer Idee von <em>Jan Vantomme</em> aus seinem Buch¬ª<a href="https://www.amazon.de/Processing-2-Creative-Programming-Cookbook/dp/1849517940/ref=as_li_ss_tl?ie=UTF8&amp;qid=1487522332&amp;sr=8-1&amp;keywords=Processing+2:+Creative+Programming+Cookbook&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=883652024ea3cb5c1944e15a7f3b957f">Processing 2: Creative Coding Programming Cookbook</a>¬´ (Seiten 31 ff.). Ich habe sie abgewandelt, die Beispiele f√ºr die Kreisb√∂gen hinzugef√ºgt und vom Java-Mode in den Python-Mode √ºbertragen.</p>
<h2 id="eine-analoge-uhr-aus-kreisb√∂gen">Eine analoge Uhr aus Kreisb√∂gen</h2>
<p>In seiner 74. Coding-Challenge auf YouTube zeigte <em>Daniel Shiffman</em>, wie man mit P5.js, dem JavaScript-Mode von Processing eine analoge Uhr aus Kreisb√∂gen programmiert. Inspiriert wurde er von <em>John Maedas</em> <a href="http://cmuems.com/2016/60212/lectures/lecture-09-09b-clocks/maedas-clocks/">12 o'Clocks</a>-Projekt und ich unterlag der Versuchung, <em>Shiffmans</em> JavaScript-Programm nach Processing.py zu portieren:</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/37277064432/"><img src="images/clockpy.jpg" alt="Screenshot clock.py" /></a></p>
<p>Dabei habe ich gegen√ºber dem Original-Script nur einige kleine Ver√§nderungen vorgenommen.Ich habe die Stunden in den √§u√üeren Kreisbogen gelegt und dadurch die Sekunden in den inneren Kreisbogen. Und ich habe die Zeiger der Uhr nicht nur in unterschiedlichen L√§ngen, sondern auch in unterschiedliche Dicken zeichnen lassen, wie man es von analogen Uhren gewohnt ist. Au√üertdem habe ich heftigen Gebrauch vom <code>with</code>-Statement gemacht, das in Processing.py in vielen F√§llen nicht nur das <code>push</code> und <code>pop</code> ersetzen, sondern auch ungterschiedliche Statii klasmmern kann.</p>
<h3 id="der-quellcode-3">Der Quellcode</h3>
<p>Meiner Meinung nach ist der Quellcode gegen√ºber der JavaScript-Version √ºbersichtlicher geworden und leichter zu durchschauen. Das liegt aber sicher nicht an meinen genialen Programmierkenntnissen (die sind eher bescheiden), sondern ist der Klarheit von Python geschuldet:</p>
<pre class="sourceCode python"><code class="sourceCode python">baseStroke = <span class="dv">8</span>

<span class="kw">def</span> setup():
    size(<span class="dv">400</span>, <span class="dv">400</span>)
    frameRate(<span class="dv">30</span>)
    
<span class="kw">def</span> draw():
    background(<span class="dv">0</span>)
    translate(width/<span class="dv">2</span>, height/<span class="dv">2</span>)
    rotate(radians(-<span class="dv">90</span>))
    
    hr = hour()
    mn = minute()
    sc = second()
    
    secondAngle = <span class="dt">map</span>(sc, <span class="dv">0</span>, <span class="dv">60</span>, <span class="dv">0</span>, <span class="dv">360</span>)
    minuteAngle = <span class="dt">map</span>(mn, <span class="dv">0</span>, <span class="dv">60</span>, <span class="dv">0</span>, <span class="dv">360</span>)
    hourAngle = <span class="dt">map</span>(hr%<span class="dv">12</span>, <span class="dv">0</span>, <span class="dv">12</span>, <span class="dv">0</span>, <span class="dv">360</span>)
    noFill()
    strokeWeight(baseStroke)
    
    <span class="co"># Kreisb√∂gen</span>
    <span class="kw">with</span> pushStyle(): <span class="co"># Sekunden</span>
        stroke(<span class="dv">150</span>, <span class="dv">100</span>, <span class="dv">255</span>)
        arc(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">300</span>, <span class="dv">300</span>, radians(<span class="dv">0</span>), radians(secondAngle))
    <span class="kw">with</span> pushStyle(): <span class="co"># Minuten</span>
        stroke(<span class="dv">255</span>, <span class="dv">100</span>, <span class="dv">150</span>)
        arc(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">320</span>, <span class="dv">320</span>, radians(<span class="dv">0</span>), radians(minuteAngle))
    <span class="kw">with</span> pushStyle(): <span class="co"># Stunden</span>
        stroke(<span class="dv">150</span>, <span class="dv">255</span>, <span class="dv">100</span>)
        arc(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">340</span>, <span class="dv">340</span>, radians(<span class="dv">0</span>), radians(hourAngle))

    <span class="co"># Zeiger</span>
    <span class="kw">with</span> pushMatrix(): <span class="co"># Sekunden</span>
        strokeWeight(baseStroke/<span class="dv">4</span>)
        stroke(<span class="dv">150</span>, <span class="dv">100</span>, <span class="dv">255</span>)
        rotate(radians(secondAngle))
        line(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">0</span>)
    <span class="kw">with</span> pushMatrix(): <span class="co"># Minuten</span>
        strokeWeight(baseStroke/<span class="dv">2</span>)
        stroke(<span class="dv">255</span>, <span class="dv">100</span>, <span class="dv">150</span>)
        rotate(radians(minuteAngle))
        line(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">80</span>, <span class="dv">0</span>)
    <span class="kw">with</span> pushMatrix(): <span class="co"># Stunden</span>
        strokeWeight(baseStroke)
        stroke(<span class="dv">150</span>, <span class="dv">255</span>, <span class="dv">100</span>)
        rotate(radians(hourAngle))
        line(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">60</span>, <span class="dv">0</span>)

    noStroke()
    fill(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>)
    ellipse(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">10</span>)</code></pre>
<h3 id="shiffmans-coding-challenge">Shiffmans Coding Challenge</h3>
<p>Zur Information hier auch noch Shiffmans <em>Coding Challenge</em>, damit Ihr die Implementierungen vergleichen k√∂nnt: (Link hinzuf√ºgen)</p>
<h3 id="links-1">Links</h3>
<ul>
<li><em>Golan Levins</em> <a href="http://cmuems.com/2016/60212/lectures/lecture-09-09b-clocks/maedas-clocks/">Notizen</a> zu Maedas 12 o‚ÄôClocks nebst <a href="http://cmuems.com/2016/60212/lectures/lecture-09-09b-clocks/">Anhang</a></li>
<li><a href="https://codepen.io/collection/DqRNLQ/">Alca's Clock Collection</a> auf CodePen</li>
</ul>
<h2 id="visualisierung-die-sonntagsfrage">Visualisierung: Die Sonntagsfrage</h2>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/33310741021/"><img src="images/sonntagsfrage.jpg" alt="Screenshot" /></a></p>
<p>Man kann sich durchaus zu Recht fragen, ob es √ºberhaupt sinnvoll ist, so etwas wie den obigen Barchart in Processing.py per Fu√ü zu erstellen. Schlie√ülich gibt es (auch in Python) Bibliotheken wie etwa die <a href="http://cognitiones.kantel-chaos-team.de/programmierung/python/matplotlib.html">Matplotlib</a>, die f√ºr diese Aufgabe spezialisiert sind und mit wenigen Zeilen Code wunderbarer Graphiken auf den Monitor zaubern und sie auch gleichzeitig publikationsreif in einer Datei ablegen k√∂nnen.</p>
<p>Aber auf der anderen Seite schadet es nichts, wenn man selber genau wei√ü, wie man so etwas anstellen kann. Denn zum einem hat man vielleicht Gr√ºnde, die Umgebung von Processing.py nicht verlassen zu wollen. Und zum anderen gibt es doch auch immer wieder Spezialf√§lle, die von den spezialisierten Bibliotheken nicht abgedeckt werden.</p>
<p>Daher habe ich hier einmal die Ergebnisse der Sonntagsfrage (¬ªWenn am n√§chsten Sonntag Bundestagswahl w√§re ‚Ä¶¬´), die die <em>Forschungsgruppe Wahlen</em> am 10. M√§rz dieses Jahres ver√∂ffentlicht hat, nur mit den Hausmitteln von Processing.py in einem einfachen Barchart dargestellt.</p>
<p>F√ºr die Daten, Namen und Farben habe ich drei Listen erstellt. Das hat den Vorteil, da√ü man bei einer neuen Umfrage nur die Ergebnisse in der Liste <code>prozente[]</code> √§ndern mu√ü -- an den anderen Listen √§ndert sich zumindest bis zur Bundestagswahl im n√§chsten Jahr nichts.</p>
<p>Normalerweise werden Rechtecke in Processing ja mit dem Befehl <code>rect(x, y, w, h)</code> erzeugt, setzt man jedoch <code>rectMode(CORNERS)</code>, dann werden die realen Eckpunkte als Parameter erwartet, also <code>rect(x1, y1, x2, y2)</code>.</p>
<p>F√ºr die Anpassung der Balken an den Bildschirmausschnitt habe ich auf Processings <code>map(value, dataMin, dataMax, targetMin, targetMax)</code>-Funktion zur√ºckgegriffen, die einen Datenwert von einem Bereich in einen anderen √ºbertr√§gt. Nun hat Python selber aber auch noch eine eingebaute <code>map(function, iterable, ‚Ä¶)</code>-Funktion, die mit der Processing-Funktion in Konflikt steht. Aber die Macher von Processing.py haben sich viel M√ºhe gegeben, diesen Konflikt aufzul√∂sen. Erf√ºllt <code>map()</code> die Signatur der Python-Funktion, wird diese aufgerufen, ansonsten die Processing-Funktion.</p>
<h3 id="der-quellcode-4">Der Quellcode</h3>
<pre class="sourceCode python"><code class="sourceCode python">parteien = [<span class="st">&quot;CDU/CSU&quot;</span>, <span class="st">&quot;SPD&quot;</span>, <span class="st">u&quot;Gr√ºne&quot;</span>, <span class="st">&quot;FDP&quot;</span>, <span class="st">&quot;Linke&quot;</span>, <span class="st">&quot;AfD&quot;</span>, <span class="st">&quot;Sonstige&quot;</span>]
prozente = [<span class="dv">34</span>, <span class="dv">32</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">5</span>]
farben = [color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>), color(<span class="dv">255</span>, <span class="dv">48</span>, <span class="dv">48</span>), color(<span class="dv">240</span>, <span class="dv">230</span>, <span class="dv">140</span>),
          color(<span class="dv">238</span>, <span class="dv">238</span>, <span class="dv">0</span>), color(<span class="dv">238</span>, <span class="dv">18</span>, <span class="dv">37</span>),
          color(<span class="dv">65</span>, <span class="dv">105</span>, <span class="dv">225</span>), color(<span class="dv">190</span>, <span class="dv">190</span>, <span class="dv">190</span>)]

titel = <span class="st">&quot;Die Sonntagsfrage&quot;</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> X1, X2, Y1, Y2
    size(<span class="dv">720</span>, <span class="dv">405</span>)
    X1 = <span class="dv">50</span>
    X2 = width - X1
    Y1 = <span class="dv">60</span>
    Y2 = height - Y1
    font1 = createFont(<span class="st">&quot;OpenSans-Regular.ttf&quot;</span>, <span class="dv">20</span>)
    textFont(font1)
    noLoop()

<span class="kw">def</span> draw():
    <span class="kw">global</span> X1, X2, Y1, Y2
    fill(<span class="dv">255</span>)
    rectMode(CORNERS)
    rect(X1, Y1, X2, Y2)
    fill(<span class="dv">0</span>)
    textSize(<span class="dv">20</span>)
    text(titel, X1, Y1 - <span class="dv">10</span>)
    delta = (X2 - X1)/(<span class="dt">len</span>(prozente))
    w = delta*<span class="fl">0.9</span>
    x = w*<span class="fl">1.22</span>
    textSize(<span class="dv">12</span>)
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(prozente)):
        <span class="co"># Balken zeichnen</span>
        h = <span class="dt">map</span>(prozente[i], <span class="dv">0</span>, <span class="dv">40</span>, Y2, Y1)
        fill(farben[i])
        rect(x - w/<span class="dv">2</span>, h, x + w/<span class="dv">2</span>, Y2)
        <span class="co"># Parteinamen und Prozente unter der X-Achse</span>
        textAlign(CENTER, TOP)
        fill(<span class="dv">0</span>)
        text(parteien[i], x, Y2 + <span class="dv">10</span>)
        text(<span class="dt">str</span>(prozente[i]) + <span class="st">&quot; %&quot;</span>, x, Y2 + <span class="dv">25</span>)
        x += delta</code></pre>
<p>Ansonsten ist der Quellcode leicht nachzuvollziehen. Die Abstands- und L√§ngenwerte f√ºr <code>w</code> und <code>delta</code> habe ich durch Experimentieren herausgefunden, ebenso die Startposition von <code>x</code>.</p>
<h3 id="quellen">Quellen</h3>
<p>Die Zahlen der <em>Forschungsgruppe Wahlen</em> habe ich auf der Seite <a href="http://www.wahlrecht.de/umfragen/index.htm">wahlrecht.de</a> entnommen, dort sind viele weitere Umfrageergebnisse zu Bundes- und Landtagswahlen zu finden. Und den verwendeten Font <a href="https://fonts.google.com/specimen/Open+Sans">Open Sans</a> habe ich bei Google Fonts gefunden. Er steht unter der <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache-Lizenz, Version 2</a>. Ihr solltet nicht vergessen, die entsprechende Datei <code>OpenSans-Regular.ttf</code> in den <code>data</code>-Folder Eures Sketches zu schieben, damit Processing.py den Font auch finden kann.</p>
<h2 id="der-baum-des-pythagoras">Der Baum des Pythagoras</h2>
<p>Eine weitere Ikone der fraktalen Geometrie ist der <a href="https://de.wikipedia.org/wiki/Pythagoras-Baum">Pythagoras-Baum</a>. Er geht zur√ºck auf den niederl√§ndischen Ingenieur und sp√§teren Mathematiklehrer <em>Albert E. Bosman</em> (1891‚Äì1961). Er entwarf w√§hrend des 2. Weltkrieges in seiner Freizeit an einem Zeichenbrett, an dem er sonst U-Boot-Pl√§ne zeichnete, geometrische Muster. Seine Graphiken wurden 1957 in dem Buch <em>¬ªHet wondere onderzoekingsveld der vlakke meetkunde¬´</em> ver√∂ffentlicht.</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/31863190274/"><img src="images/pythagorasbaum.jpg" alt="Pythagoras-Baum" /></a></p>
<p>Der Pythagoras-Baum beruht auf einer rekursiven Abbildung des Pythagoras-Lehrsatzes: Die beiden Quadrate auf den Katheten des rechtwinkligen Dreiecks dienen als Verzweigung, auf dem jedes Kathetenquadrat sich wiederum verzweigt.</p>
<h3 id="die-funktion-drawpythagoras">Die Funktion drawPythagoras</h3>
<p>Um die Funktion rekursiv aufrufen zu k√∂nnen, mu√üte ich sie aus der <code>draw()</code>-Funktion auslagern und sie in einen eigenen Aufruf packen:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> drawPythagoras(a1, a2, b1, b2, level):
    <span class="kw">if</span> (level &gt; <span class="dv">0</span>):
        <span class="co"># Eckpunkte berechnen</span>
        n1 = -b2 + a2
        n2 = -a1 + b1
        c1 = b1 + n1
        c2 = b2 + n2
        d1 = a1 + n1
        d2 = a2 + n2
        <span class="co"># Start-Rechteck zeichnen</span>
        fill(palette[(level<span class="dv">-1</span>)%<span class="dv">10</span>])
        <span class="kw">with</span> beginClosedShape():
            vertex(a1 + xmitte, ymax - a2)
            vertex(b1 + xmitte, ymax - b2)
            vertex(c1 + xmitte, ymax - c2)
            vertex(d1 + xmitte, ymax - d2)
        e1 = d1 + w1*(c1 - d1) + w2*n1
        e2 = d2 + w1*(c2 - d2) + w2*n2
        <span class="co"># Schenkel-Quadrate zeichnen</span>
        drawPythagoras(e1, e2, c1, c2, level<span class="dv">-1</span>)
        drawPythagoras(d1, d2, e1, e2, level<span class="dv">-1</span>)</code></pre>
<p>Zum Zeichnen der einzelnen Quadrate habe ich nicht die <code>rect()</code>-Funktion genutzt, sondern <em>Shapes</em>, mit denen sich Punkte zu einem beliebigen Gebilde oder Polygon zusammefassen lassen. Hierzu m√ºssen sie erst einmal mit <code>with beginClosedShape()</code> geklammert werden. Darin werden dann mit <code>vertex(x, y)</code> nacheinander die einzelnen Punkt aufgerufen, die (im einfachten Fall) durch Linien miteinander verbunden werden sollen. Mit <code>beginClosedShape</code> teile ich dem Sketch auch mit, da√ü das entstehende Polygon auf jeden Fall geschlossen werden soll, ein einfaches <code>with beginShape()</code> w√ºrde es offen lassen.</p>
<p>Der Aufruf ist rekursiv: Nachdem zuerst das Grundquadrat gezeichnet wurde, werden die rechten und die linken Schenkelquadrate gezeichnet, die dann wieder als Grundquadrate f√ºr den n√§chsten Rekursionslevel fungieren.</p>
<p>Processing (und damit auch der Python-Mode von Processing) ist gegen√ºber Rekursionstiefen realtiv robust. Die benutzte Rekursionstiefe von 12 wird klaglos abgearbeitet, auch Rekursionstiefen bis 20 sind -- gen√ºgend Geduld vorausgesetzt -- kein Problem. Bei einer Rekursionstiefe von 22 verlie√ü mich aber auf meinem betagten MacBook Pro die Geduld.</p>
<h3 id="die-farben">Die Farben</h3>
<p>F√ºr die Farben habe ich eine Palette in einer Liste zusammengestellt, die der Reihe nach die Quadrate einf√§rbt. Da die Liste nur 10 Elemente enth√§lt, habe ich mit <code>fill(palette[(level-1)%10])</code> daf√ºr gesorgt, da√ü nach 10 Leveln die Palette wieder von vorne durchlaufen wird.</p>
<h3 id="der-quellcode-5">Der Quellcode</h3>
<p>Da die eigentliche Aufgabe des Programms in die Funktion <code>drawPythagoras()</code> ausgelagert wurde, ist der restlich Quellcode von erfrischender K√ºrze:</p>
<pre class="sourceCode python"><code class="sourceCode python">palette = [color(<span class="dv">189</span>,<span class="dv">183</span>,<span class="dv">110</span>), color(<span class="dv">0</span>,<span class="dv">100</span>,<span class="dv">0</span>), color(<span class="dv">34</span>,<span class="dv">139</span>,<span class="dv">105</span>),
           color(<span class="dv">152</span>,<span class="dv">251</span>,<span class="dv">152</span>), color(<span class="dv">85</span>,<span class="dv">107</span>,<span class="dv">47</span>), color(<span class="dv">139</span>,<span class="dv">69</span>,<span class="dv">19</span>),
           color(<span class="dv">154</span>,<span class="dv">205</span>,<span class="dv">50</span>), color(<span class="dv">107</span>,<span class="dv">142</span>,<span class="dv">35</span>), color(<span class="dv">139</span>,<span class="dv">134</span>,<span class="dv">78</span>),
           color(<span class="dv">139</span>, <span class="dv">115</span>, <span class="dv">85</span>)]

xmax = <span class="dv">600</span>
xmitte = <span class="dv">300</span>
ymax = <span class="dv">440</span>

level = <span class="dv">12</span>
w1 = <span class="fl">0.36</span>   <span class="co"># Winkel 1</span>
w2 = <span class="fl">0.48</span>   <span class="co"># Winkel 2</span>

<span class="kw">def</span> setup():
    size(<span class="dv">640</span>, <span class="dv">480</span>)
    background(<span class="dv">255</span>)
    strokeWeight(<span class="dv">1</span>)
    noLoop()

<span class="kw">def</span> draw():
    drawPythagoras(-(xmax/<span class="dv">10</span>), <span class="dv">0</span>, xmax/<span class="dv">20</span>, <span class="dv">0</span>, level)

<span class="kw">def</span> drawPythagoras(a1, a2, b1, b2, level):
    <span class="kw">if</span> (level &gt; <span class="dv">0</span>):
        <span class="co"># Eckpunkte berechnen</span>
        n1 = -b2 + a2
        n2 = -a1 + b1
        c1 = b1 + n1
        c2 = b2 + n2
        d1 = a1 + n1
        d2 = a2 + n2
        <span class="co"># Start-Rechteck zeichnen</span>
        fill(palette[(level<span class="dv">-1</span>)%<span class="dv">10</span>])
        <span class="kw">with</span> beginClosedShape():
            vertex(a1 + xmitte, ymax - a2)
            vertex(b1 + xmitte, ymax - b2)
            vertex(c1 + xmitte, ymax - c2)
            vertex(d1 + xmitte, ymax - d2)
        e1 = d1 + w1*(c1 - d1) + w2*n1
        e2 = d2 + w1*(c2 - d2) + w2*n2
        <span class="co"># Schenkel-Quadrate zeichnen</span>
        drawPythagoras(e1, e2, c1, c2, level<span class="dv">-1</span>)
        drawPythagoras(d1, d2, e1, e2, level<span class="dv">-1</span>)</code></pre>
<p>Auch wenn es nicht n√∂tig gewesen w√§re, ich mag es einfach (und es dient der √úbersichtlichkeit), wenn ich meine Processing.py-Sketche mit <code>def setup()</code> und <code>def draw()</code> gliedere. Mit <code>noLoop()</code> habe ich dann daf√ºr gesorgt, da√ü die <code>draw()</code>-Schleife nur einmal abgearbeitet wird.</p>
<h3 id="erweiterungen-und-√§nderungen">Erweiterungen und √Ñnderungen</h3>
<p>Einen ¬ªsymmetrischen¬´ Pythagoras-Baum erh√§lt man √ºbrigens, wenn man die beiden Winkel-Konstanten <code>w1</code> und <code>w2</code> jeweils auf <code>0.5</code> setzt.</p>
<h3 id="credits-2">Credits</h3>
<p>Den rekursiven Algorithmus habe ich einem Pascal-Programm aus J√ºrgen Plate: <em><a href="https://www.amazon.de/Computergrafik-Algorithmen-Programmentwicklung-J%C3%BCrgen-Plate/dp/3772350062/ref=as_li_ss_tl?ie=UTF8&amp;qid=1486231087&amp;sr=8-1&amp;keywords=Computergrafik:+Einf%C3%BChrung+%E2%80%93+Algorithmen+%E2%80%93+Programmentwicklung&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=1ecefc994bcb34a2eb125fe6b0a584de">Computergrafik: Einf√ºhrung ‚Äì Algorithmen ‚Äì Programmentwicklung</a></em>, M√ºnchen (Franzis) 2.¬†Auflage 1988, Seiten 460-462 entnommen. Und die Geschichte des Baumes steht in dem schon mehrfach erw√§hnten Buch von Dieter Hermann, <em><a href="https://www.amazon.de/Algorithmen-Chaos-Fraktale-Dietmar-Herrmann/dp/3893196331/ref=as_li_ss_tl?ie=UTF8&amp;qid=1486231163&amp;sr=8-1&amp;keywords=Algorithmen+f%C3%BCr+Chaos+und+Fraktale&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=1d9b1f52b6169d24394a3dfc6cc6cf0e">Algorithmen f√ºr Chaos und Fraktale</a></em>, Bonn (Addison-Wesley) 1944 auf den Seiten 170f.</p>
<h1 id="textverarbeitung-in-processing.py">Text(verarbeitung) in Processing.py</h1>
<p>Mit <code>print()</code> oder <code>println()</code> kann man in Processing.py jede Ausgabe in das Konsolenfenster bringen, aber was ist, wenn der Text im Graphikfenster ausgegeben werden soll? Ich gehe erst einmal ganz naiv daran:</p>
<pre class="sourceCode python"><code class="sourceCode python">font = <span class="ot">None</span>
tt = <span class="st">&quot;Zw√∂lf Boxk√§mpfer jagen Eva quer √ºber den gro√üen Sylter Deich.&quot;</span>

<span class="kw">def</span> setup():
    size(<span class="dv">800</span>, <span class="dv">100</span>)
    font = createFont(<span class="st">&quot;American Typewriter&quot;</span>, <span class="dv">20</span>)
    textFont(font)

<span class="kw">def</span> draw():
    background(<span class="dv">255</span>)
    fill(<span class="dv">0</span>)
    text(tt, <span class="dv">25</span>, <span class="dv">50</span>)</code></pre>
<p>In der ersten Zeile teile ich Processing.py mit, da√ü ich die Variable <code>font</code> verwenden will und belege sie erst einmal mit dem Wert <code>none</code>. Das erspart mir ein oder sogar zwei Global-Statements. Die Stringvariable <code>tt</code> bekommt meinen Text zugewiesen. In <code>setup()</code> mache ich ein langes, schamles Fenster auf (mein Text ist ja ziemlich lang) und dann teile ich mit <code>createFont()</code> Processing.py mit, da√ü ich den Font <em>American Typewriter</em> in der Gr√∂√üe von 20 Pixeln verwenden will und weise ihn der Variablen <code>font</code> zu. Zu guter Letzt lege ich noch fest, da√ü eben mein textFont <code>font</code> ist.</p>
<p>In <code>draw()</code> lege ich einen wei√üen Hintergrund und eine schwarze F√ºllfarbe fest und lasse dann mit der Funktion <code>text()</code> den Text in das Fenster zeichnen. <code>text()</code> besitzt drei Parameter, zuerst den zu schreibenden (oder besser: zeichnenden) Text, dann die x- und die y-Koordinate des Textbeginns.</p>
<p>Das sieht eigentlich alles ganz einfach aus, aber wenn Ihr den Sketch ausf√ºhren lasst, erlebt Ihr Euer blaues Wunder:</p>
<figure>
<img src="images/text01.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>So verst√ºmmelt habt Ihr Euch das sicher nicht vorgestellt. Die Ursache ist einfach und √§rgerlich. Das Processing.py zugrundeliegende Python ist ein Jython (also die Java-Version von Python) und entspricht der Python-Version 2.7. Diese ist leider nicht <em>out of the box</em> UTF-8 f√§hig, ein Umstand, der in der (meist englischsprachigen) Literatur geflissentlich verschwiegen wird<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>. Dabei ist er so leicht zu beheben. Ein vor einem String vorangestelltes <code>u</code> teilt Python 2.7 mit, da√ü dieser String ein UTF-8-String ist. Im Sketch ist also lediglich die Zeile</p>
<pre class="sourceCode python"><code class="sourceCode python">tt = <span class="st">&quot;Zw√∂lf Boxk√§mpfer jagen Eva quer √ºber den gro√üen Sylter Deich.&quot;</span></code></pre>
<p>in</p>
<pre class="sourceCode python"><code class="sourceCode python">tt = <span class="st">u&quot;Zw√∂lf Boxk√§mpfer jagen Eva quer √ºber den gro√üen Sylter Deich.&quot;</span></code></pre>
<p>und schon wird der Text wie gew√ºnscht ausgegeben:</p>
<figure>
<img src="images/text02.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Es gibt eine weitere, kleine Ungereimtheit im Umgang mit UTF-8 in Processing.py Im Haupt-Tab, in dem das ausf√ºhrbare Programm steht (das ist der Tab, der die Endung <code>.pyde</code> bekommt), kann man -- wie gezeigt -- ohne gro√üe Probleme im Programmtext Umlaute unterbringen, w√§hrend der Code in den anderen Tabs (die unter <code>.py</code> gespeichert werden) strenger mit dem Programmierer umgeht: Wenn nicht in der ersten Zeile</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># coding=utf-8</span></code></pre>
<p>steht, meckert die IDE gnadenlos, selbst wenn Umlaute nur in den Kommentaren vorkommen.</p>
<p>!!! tip &quot;Pangramm&quot; Der Text mit den zw√∂lf Boxern ist √ºbrigens ein <a href="https://de.wikipedia.org/wiki/Pangramm">Pangramm</a>, ein Satz, der alle Buchstaben des (in diesem Falle deutschen) Alphabets enth√§lt. Fr√ºher wurden sie benutzt, um zum Beispiel Schreibmaschinen nach einer Reparatur zu testen. Heute nutze ich ihn, um festzustellen, ob ein Font auch alle Umlaute des deutschen Alphabets enth√§lt. Das bekannteste englische Pangramm ist der Satz ¬ªThe quick brown fox jumps over the lazy dog¬´.</p>
<h2 id="als-die-pangramme-laufen-lernten">Als die Pangramme laufen lernten</h2>
<p>W√§hrend in der Funktion <code>text()</code> die y-Koordinate immer die Grundlinie des Textes ist, kann man mit <code>textAlign()</code> festlegen, ob die x-Koordinate die rechte Kante (<code>RIGHT</code>), die linke Kante (<code>LEFT</code>) oder die Mitte (<code>CENTER</code>) des Textes betrifft. Das m√∂chte ich ausnutzen, um eine Parade der Pangramme zu programmieren. Als erstes lege ich eine Liste mit Pangrammen an (der oben verlinkte Wikipedia-Artikel ist voll von ihnen). Und damit es auch ein wenig bunt wird, habe ich eine gleichlange Liste mit Farben zusammengestellt. Im Endeffekt soll das dann so aussehen:</p>
<figure>
<img src="images/text03.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Der Sketch selber ist dadurch ein wenig l√§nger geworden, aber das betrifft in der Hauptsache nur die beiden Listen:</p>
<pre class="sourceCode python"><code class="sourceCode python">font = <span class="ot">None</span>
pangramme = [<span class="st">u&quot;Zw√∂lf Boxk√§mpfer jagen Eva quer √ºber den gro√üen Sylter Deich.&quot;</span>,
             <span class="co">u&quot;J√∂rg b√§ckt quasi zwei Haxenf√º√üe vom Wildpony.&quot;</span>,
             <span class="co">u&quot;Falsches √úben von Xylophonmusik qu√§lt jeden gr√∂√üeren Zwerg.&quot;</span>,
             <span class="co">u&quot;Schwei√ügequ√§lt z√ºndet Typograph Jakob verflixt √∂de Pangramme an.&quot;</span>,
             <span class="co">u&quot;Vom √ñdipuskomplex ma√ülos gequ√§lt, √ºbt Wilfried zyklisches Jodeln.&quot;</span>,
             <span class="co">u&quot;Asynchrone Basskl√§nge vom Jazzquintett sind nix f√ºr spie√üige L√∂wen.&quot;</span>]
             
colors = [<span class="st">&quot;#cd0000&quot;</span>, <span class="st">&quot;#008b00&quot;</span>, <span class="st">&quot;#ffff00&quot;</span>, <span class="st">&quot;#a52a2a&quot;</span>, <span class="st">&quot;#ff00ff&quot;</span>, <span class="st">&quot;#00ffff&quot;</span>]

<span class="kw">def</span> setup():
    <span class="kw">global</span> x, index
    frame.setTitle(<span class="st">&quot;Parade der Pangramme&quot;</span>)
    size(<span class="dv">800</span>, <span class="dv">100</span>)
    font = createFont(<span class="st">&quot;American Typewriter&quot;</span>, <span class="dv">24</span>)
    textFont(font)
    x = width
    index = <span class="dv">0</span>

<span class="kw">def</span> draw():
    <span class="kw">global</span> x, index
    background(<span class="dv">0</span>)
    fill(colors[index])
    textAlign(LEFT)
    text(pangramme[index], x, <span class="dv">60</span>)
    x -= <span class="dv">3</span>
    w = textWidth(pangramme[index])
    <span class="kw">if</span> (x &lt; -w):
        x = width
        index = (index<span class="dv">+1</span>) % <span class="dt">len</span>(pangramme)</code></pre>
<p>Mit <code>textAlign(LEFT)</code> und <code>x = width</code> habe ich festgelegt, da√ü der Text im ersten Schritt am rechten Fensterrand beginnt und quasi ins Leere geschrieben wird. Bei jedem Durchlauf wird <code>x</code> umd drei dekrementiert und so beginnt das erste Pangramm von rechts nach links durch das Fenster zu scrollen. Ist der Text aus dem sichtbaren Bereich des Fenster verschwunden (<code>x &lt; -w</code>), dann wird <code>index</code> um einen erh√∂ht und das n√§chste Pangramm beginnt seine Parade. Damit der Index nicht irgendwann √ºberl√§uft wird er Modulo der L√§nge der Liste der Pangramme berechnet. Und da ich in weiser Voraussicht die L√§nge der Farbliste gleich der L√§nge der Liste der Pangramme entworfen habe, passiert auch bei den Farben nichts.</p>
<h3 id="font-font-font">Font, Font, Font</h3>
<p>Jetzt bleibt nur noch eins zu tun. Auf meinem Rechner l√§uft der Sketch ohne Probleme, da ich wei√ü, da√ü auf meinen Rechner der Font <em>American Typewriter</em> vorhanden ist. Dies mu√ü aber nicht auf jedem anderen Rechner der Fall sein (falls also bei Euch die Sketche nicht laufen, tauscht einfach <em>American Typewriter</em> mit einem anderen Font, der auf Eurem Rechner vorhanden ist, aus). Wenn ich die <code>.ttf</code>-Datei des Fonts in den <code>data</code>-Ordner des Sketches kopiere (das geht am einfachsten, wenn ich die Datei auf das Editor-Fenster der IDE schiebe), w√ºrde der Sketch -- wenn ich ihn weitergebe -- √ºberall funktionieren. Aber <em>American Typewriter</em> unterliegt mit Sicherheit dem Urheberrecht und eine Weitergabe ist vermutlich verboten oder mit hohen Kosten verbunden.</p>
<p>Aber es gibt ja eine Menge freier Fonts im Web und die gr√∂√üte Quelle dieser freien Fonts ist <a href="https://fonts.google.com/">Google Fonts</a>. Dort habe ich mir den Font <a href="https://fonts.google.com/specimen/Barrio">Barrio</a> heruntergeladen, der unter der <a href="http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;id=OFL_web">Open Font Licence</a> zu nutzen ist.</p>
<figure>
<img src="images/text04.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Selbstverst√§ndlich habe ich mich vorher vergewissert, da√ü der Font auch die von mir gew√ºnschten deutschen Umlaute enth√§lt. Nachdem ich die Fontdatei dem Sketch hinzugef√ºgt hatte, war eigentlich nur noch eine Zeile im Programm zu √§ndern:</p>
<pre class="sourceCode python"><code class="sourceCode python">    font = createFont(<span class="st">&quot;Barrio-Regular.ttf&quot;</span>, <span class="dv">64</span>)</code></pre>
<p><em>Barrio</em> ist ein Display-Font, der nur ab einer gewissen Gr√∂√üe wirkt. Daher habe ich ihn auf <code>64</code> gesetzt und dann die y-Koordinate etwas weiter nach unten geschoben. Der vollst√§ndige und endg√ºltige Sketch der Pangramm-Parade sieht daher nun so aus:</p>
<pre class="sourceCode python"><code class="sourceCode python">font = <span class="ot">None</span>
pangramme = [<span class="st">u&quot;Zw√∂lf Boxk√§mpfer jagen Eva quer √ºber den gro√üen Sylter Deich.&quot;</span>,
             <span class="co">u&quot;J√∂rg b√§ckt quasi zwei Haxenf√º√üe vom Wildpony.&quot;</span>,
             <span class="co">u&quot;Falsches √úben von Xylophonmusik qu√§lt jeden gr√∂√üeren Zwerg.&quot;</span>,
             <span class="co">u&quot;Schwei√ügequ√§lt z√ºndet Typograph Jakob verflixt √∂de Pangramme an.&quot;</span>,
             <span class="co">u&quot;Vom √ñdipuskomplex ma√ülos gequ√§lt, √ºbt Wilfried zyklisches Jodeln.&quot;</span>,
             <span class="co">u&quot;Asynchrone Basskl√§nge vom Jazzquintett sind nix f√ºr spie√üige L√∂wen.&quot;</span>]
             
colors = [<span class="st">&quot;#cd0000&quot;</span>, <span class="st">&quot;#008b00&quot;</span>, <span class="st">&quot;#ffff00&quot;</span>, <span class="st">&quot;#a52a2a&quot;</span>, <span class="st">&quot;#ff00ff&quot;</span>, <span class="st">&quot;#00ffff&quot;</span>]

<span class="kw">def</span> setup():
    <span class="kw">global</span> x, index
    frame.setTitle(<span class="st">&quot;Parade der Pangramme&quot;</span>)
    size(<span class="dv">800</span>, <span class="dv">100</span>)
    font = createFont(<span class="st">&quot;Barrio-Regular.ttf&quot;</span>, <span class="dv">64</span>)
    textFont(font)
    x = width
    index = <span class="dv">0</span>

<span class="kw">def</span> draw():
    <span class="kw">global</span> x, index
    background(<span class="dv">0</span>)
    fill(colors[index])
    textAlign(LEFT)
    text(pangramme[index], x, <span class="dv">80</span>)
    x -= <span class="dv">3</span>
    w = textWidth(pangramme[index])
    <span class="kw">if</span> (x &lt; -w):
        x = width
        index = (index<span class="dv">+1</span>) % <span class="dt">len</span>(pangramme)</code></pre>
<p>Wenn Ihr noch mehr √ºber Strings, Text und Fonts in Processing.py wissen wollt, <em>Daniel Shiffman</em> hat dazu ein <a href="http://py.processing.org/tutorials/text/">nettes Tutorial</a> verfa√üt, da√ü auch mir bei meinen Erkundungen sehr geholfen hat.</p>
<h3 id="utf-8-text-aus-dateien-lesen">UTF-8-Text aus Dateien lesen</h3>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/34885001666/"><img src="images/boxerscreenshot.jpg" alt="Screenshot" /></a></p>
<p>In der Reference f√ºr Processing 3 steht bei allen Datei-Operationen, <a href="https://processing.org/reference/loadStrings_.html">so auch bei <code>loadStrings()</code></a>:</p>
<blockquote>
<p><em>Starting with Processing release 0134, all files loaded and saved by the Processing API use UTF-8 encoding. In previous releases, the default encoding for your platform was used, which causes problems when files are moved to other platforms.</em></p>
</blockquote>
<p>Das lie√ü hoffen, da√ü man in Processing.py wenigstens an dieser Stelle ohne das (von mir) ungeliebte <code>u&quot;utf-8-string&quot;</code> auskommen kann. Das wollte ich ausprobieren, also legte ich mir als erstes eine (UTF-8-) Textdatei mit diesem Inhalt an:</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/34885000846/"><img src="images/boxertext01.jpg" alt="Screenshot" /></a></p>
<p>Das sieht doch schon sehr gef√§hrlich aus, in der ersten Zeile die b√∂sen deutschen Umlaute, die zweite Zeile mit japanischen Schriftzeichen, die dritte enth√§lt chinesische Glyphen und die letzte Zeile kyrillische (russische) Zeichen. Noch vor wenigen Jahren h√§tte das jeden Programmierer an den Rand des Wahnsinns gebracht, aber nun: Selbst dieser simple Dreizeiler</p>
<pre class="sourceCode python"><code class="sourceCode python">lines = loadStrings(<span class="st">&quot;boxer.txt&quot;</span>)
<span class="kw">for</span> line in lines:
    <span class="dt">print</span>(line)</code></pre>
<p>gibt den Text mit allen Sonderzeichen auf der Konsole aus. Und auch der Befehl <code>text(line, x, y, w, h)</code> hat keine Schwierigkeiten (einen UTF-8-f√§higen Font vorausgesetzt) diesen Text in das Processing-Fenster zu zaubern. Hier das Progr√§mmchen, das obigen Screenshot produziert:</p>
<pre class="sourceCode python"><code class="sourceCode python">font = <span class="ot">None</span>

<span class="kw">def</span> setup():
    size(<span class="dv">500</span>, <span class="dv">500</span>)
    <span class="co"># fontList = PFont.list()</span>
    <span class="co"># printArray(fontList)</span>
    font = createFont(<span class="st">&quot;Palatino-Roman&quot;</span>, <span class="dv">32</span>)
    textFont(font)
    noLoop()

<span class="kw">def</span> draw():
    background(<span class="dv">30</span>)
    textSize(<span class="dv">32</span>)
    u = <span class="dv">50</span>
    text(<span class="st">&quot;Seltsame Zeichen&quot;</span>, <span class="dv">20</span>, u)
    u = <span class="dv">80</span>
    textSize(<span class="dv">24</span>)
    lines = loadStrings(<span class="st">&quot;boxer.txt&quot;</span>)
    <span class="kw">for</span> line in lines:
        <span class="dt">print</span>(line)
        text(line, <span class="dv">20</span>, u, <span class="dv">460</span>, <span class="dv">500</span>)
        u += <span class="dv">80</span></code></pre>
<p>Die beiden auskommentierten Zeilen listen in der Konsole alle auf dem System verf√ºgbaren Fonts auf, mit dem Namen, in dem sie mit <code>createFont()</code> in Processing angesprochen werden k√∂nnen. Wenn man einen dieser Fonts verwendet, erspart das zwar einerseits die Installation eines Fonts im <code>data</code>-Ordner, macht aber auf der anderen Seite solch ein Skript weniger portabel, denn was ist, wenn der Empf√§nger diesen Font nicht installiert hat.</p>
<h3 id="keine-emojis">Keine Emojis</h3>
<p>In einer ersten Version des Textes hatte ich auch noch ein paar Emojis hineingeschmuggelt. Hier wurde aber eine Grenze √ºberschritten, Emojis wurden weder in der Konsole noch auf dem Canvas angezeigt (man kann sie auch nicht per <em>Copy &amp; Paste</em>) in den Editor schmuggeln auch nicht mit <code>u&quot;üíÄ&quot;</code>. Das gilt aber auch f√ºr den Java-Mode von Processing, Emojis sind erst in P5.js in der Welt von Processing vorgesehen.</p>
<h3 id="caveat">Caveat</h3>
<p>Auch wenn ich es nat√ºrlich sch√∂n finde, da√ü das ungeliebte <code>u&quot;utf-8-string&quot;</code> bei den Dateioperationen mit Processing-Befehlen wegf√§llt, ist es nat√ºrlich inkonsistent. Denn Dateioperationen mit Python-Befehlen arbeiten nat√ºrlich weiterhin mit der besonderen UTF-8-Kodierung von Python 2.7, so zum Beispiel die Befehle um CSV- oder JSON-Dateien zu lesen und zu schreiben. Daher ist eine gewisse Vorsicht angebracht.</p>
<h2 id="spa√ü-mit-processing.py-rentenuhr">Spa√ü mit Processing.py: Rentenuhr</h2>
<p>Was f√ºr Gr√ºnde sprechen eigentlich daf√ºr, Processing.py statt des ¬ªnormalen¬´ Processings zu nutzen? Nun, zum einen k√∂nnen es pers√∂nliche Gr√ºnde sein: Ich mag zum Beispiel keine Programmiersprachen, die Bl√∂cke mit geschweiften Klammern (<code>{}</code>) trennen und vermeide sie, wo es nur geht. Zum anderen komme ich aus der <a href="http://cognitiones.kantel-chaos-team.de/programmierung/pascal.html">Pascal</a>-Ecke (Pascal und Algol 68 waren meine ersten Programmiersprachen √ºberhaupt) und mag daher Programme, die so etwas sind wie ¬ªausf√ºhrbarer Pseudocode¬´. Aber der wichtigste Grund ist, Processing.py ist eben nicht nur Processing, sondern auch Python. Und Python kommt <em>¬ªbatteries included¬´</em>, es bringt eine gro√üe Anzahl von Standard-Bibliotheken mit, die man auch in Processing.py nutzen kann. Ich m√∂chte das am Beispiel des Python-Moduls <code>datetime</code> einmal zeigen:</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/31675983150/"><img src="images/rentenuhr.jpg" alt="Screenshot" /></a></p>
<p>Als erstes habe ich den freien (<a href="http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;id=OFL_web">Open Font Licence</a>) Font <a href="https://fonts.google.com/specimen/Coda">Coda Heavy</a> von Googles Seiten heruntergeladen, entpackt und ihn dem Skript zug√§nglich gemacht, indem ich die <code>.ttf</code>-Datei einfach auf das IDE-Fenster geschoben habe. Processing legt dann automatisch im Skriptordner ein <code>data</code>-Vertzeichnis an und kopiert die Datei -- wie auch alle Bild- oder Audio-Datein dorthin. Die Skripte finden sie dann, zum Beispiel mit</p>
<pre class="sourceCode python"><code class="sourceCode python">    font = createFont(<span class="st">&quot;Coda-Heavy.ttf&quot;</span>, <span class="dv">96</span>)</code></pre>
<p>ohne eine spezielle Pfadangabe. Der zweite Parameter gibt die maximale Fontgr√∂√üe vor. Am Anfang des Skriptes habe ich mit</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="ch">import</span> datetime <span class="ch">as</span> dt</code></pre>
<p>das Python-Modul <code>datetime</code> aus der Standardbibliothek geladen und dann als erstes eine einfache Uhr gebastelt</p>
<pre class="sourceCode python"><code class="sourceCode python">    myNow = dt.datetime.now()
    myHour = <span class="dt">str</span>(myNow.hour)
    myMinute = <span class="dt">str</span>(myNow.minute)
    mySecond = <span class="dt">str</span>(myNow.second)</code></pre>
<p>und dann die <code>datetime</code>-Objekte in Strings verwandelt. Im eigentlichen Programm habe ich sie sogar noch ein wenig aufgeh√ºbscht und den einstelligen Sekunden und Minute eine f√ºhrende Null verpa√üt. Das k√∂nnt Ihr weiter unten im kompletten Quellcode nachlesen.</p>
<p>Jetzt kommt aber der eigentliche Gag: Mit den <code>datetime</code>-Objekten kann man n√§mlich rechnen! Und da ich am 31. Dezember 2018 in Rente gehe, wollte ich wissen, wieviele Tage ich noch ausharren mu√ü</p>
<pre class="sourceCode python"><code class="sourceCode python">    rente = dt.date(<span class="dv">2018</span>, <span class="dv">12</span>, <span class="dv">31</span>)
    heute = dt.date.today()
    differenz = rente - heute
    myDays = <span class="dt">str</span>(differenz.days)
    workingDays = <span class="dt">float</span>(myDays)/<span class="fl">7.0</span> * <span class="dv">5</span>
    workingDays = <span class="dt">str</span>(<span class="dt">int</span>(workingDays - <span class="dv">80</span>))</code></pre>
<p>und wieviele Tage davon Arbeitstage sind. Dazu habe ich einfach die Anzahl der Tage durch sieben geteilt und mit f√ºnf multipliziert, was grob die Anzahl der Werktage ergibt. Und da ich noch 20 Tage Resturlaub in dieses Jahr mitgeschleppt habe und mir pro Jahr auch noch je 30 Tage regul√§rer Urlaub zusteht, habe ich diese 80 Tage auch noch abgezogen. Die Feiertage habe ich nicht ber√ºcksichtigt, mir reicht diese grobe Sch√§tzung.</p>
<p>Da die Differenz zweier <code>datetime</code>-Objekte wieder ein <code>datetime</code>-Objekt ist, mu√ü die Umwandlung in einen <em>String</em> explizit mittels <em>Typecasting</em> vorgenommen werden und bei der Division durch sieben ist zu beachten, da√ü das Processing.py zugrundelegende Jython ein Python 2.7 ist und deshalb bei einer Integer-Division alle Nachkommastellen abschneidet (zum Beispiel ergibt <code>13/7</code> eine <code>1</code>, dieses -- dokumentierte -- Verhalten wurde in Python 3 ge√§ndert). Um das zu vermeiden, habe ich durch <code>7.0</code> geteilt und so eine Float-Division erzwungen und durch ein anschlie√üendes Runden das Ergebnis doch wieder in eine Integer-Zahl verwandelt.</p>
<p>Jetzt das komplette Skript zum Nachlesen und Nachprogrammieren:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> datetime <span class="ch">as</span> dt

<span class="kw">def</span> setup():
    size(<span class="dv">640</span>, <span class="dv">480</span>)
    font = createFont(<span class="st">&quot;Coda-Heavy.ttf&quot;</span>, <span class="dv">96</span>)
    textFont(font)

<span class="kw">def</span> draw():
    background(<span class="st">&quot;#000000&quot;</span>)
    myNow = dt.datetime.now()
    myHour = <span class="dt">str</span>(myNow.hour)
    myMinute = <span class="dt">str</span>(myNow.minute).rjust(<span class="dv">2</span>, <span class="st">&quot;0&quot;</span>)
    mySecond = <span class="dt">str</span>(myNow.second).rjust(<span class="dv">2</span>, <span class="st">&quot;0&quot;</span>)
    myTime = myHour + <span class="st">&quot; : &quot;</span> + myMinute + <span class="st">&quot; : &quot;</span> + mySecond
    textSize(<span class="dv">96</span>)
    text(myTime, <span class="dv">60</span>, <span class="dv">150</span>)
    rente = dt.date(<span class="dv">2018</span>, <span class="dv">12</span>, <span class="dv">31</span>)
    heute = dt.date.today()
    differenz = rente - heute
    myDays = <span class="dt">str</span>(differenz.days)
    workingDays = <span class="dt">float</span>(myDays)/<span class="fl">7.0</span> * <span class="dv">5</span>
    workingDays = <span class="dt">str</span>(<span class="dt">int</span>(workingDays - <span class="dv">80</span>))
    myText = <span class="st">u&quot;Lieber J√∂rg, es sind nur noch &quot;</span> + myDays + \
    <span class="co">u&quot; Tage bis zu Deiner Rente!\nDas sind etwa &quot;</span> + \
    workingDays + <span class="st">&quot; Arbeits- tage. Das schaffst Du!&quot;</span>
    textSize(<span class="dv">32</span>)
    text(myText, <span class="dv">60</span>, <span class="dv">200</span>, <span class="dv">540</span>, <span class="dv">300</span>)</code></pre>
<p>Wegen des Umlautes in meinem Vornamen, mu√üte ich mit <code>u&quot;‚Ä¶&quot;</code> die Umwandlung des Strings in einen UTF-8-String erzwingen (auch das ist Python 3 nicht mehr n√∂tig), aber wie der obige Screenshot zeigt, wird dann der Umlaut auch brav angezeigt.</p>
<p>Die Funktion <code>text()</code> kann man in Processing einmal mit drei und einmal mit f√ºnf Parametern aufrufen. Im ersten Fall √ºbergibt man den Text und die x- und y-Koordinaten der linken Grundlinie des Textes. Im zweiten Fall kommen noch die Weite und die H√∂he der Textbox hinzu. Damit erreicht man, da√ü ein langer String an den Textbox-Grenzen umgebrochen wird und der Text nicht aus dem Fenster herausl√§uft. Die Parameter habe ich durch einfaches Ausprobieren bekommen.</p>
<h1 id="bildmanipulation-mit-processing.py">Bildmanipulation mit Processing.py</h1>
<h2 id="jeder-sein-kleiner-warhol">Jeder sein kleiner Warhol</h2>
<p>Processing und damit auch Processing.py besitzt ein ganzes Arsenal von Filtern zur Bildmanipulation. Davon m√∂chte ich zu Beginn zwei heraussuchen und damit ein kleines Programm erstellen, dessen Ergebnis ein wenig an die ber√ºhmten Siebdrucke des Pop-Art-K√ºnstlers <a href="https://de.wikipedia.org/wiki/Andy_Warhol">Andy Warhol</a> erinnern soll.</p>
<figure>
<img src="images/warhollike.jpg" alt="Warhol like" /><figcaption>Warhol like</figcaption>
</figure>
<p>Ich habe dazu ein Photo von unserem Sheltie Joey und mir genommen, das <em>Stefanie Radon</em> vor etwa vier Jahren von uns geschossen hatte, und das mein Facebook-Profil ziert und mit dem <code>filter(THRESHOLD, 0.55)</code> in eine reine schwarz-wei√ü-Zeichnung umgewandelt. <code>THRESHOLD</code> akzeptiert Parameter zwischen <code>0.0</code> und <code>1.0</code> -- je kleiner der Wert, desto weniger wird angezeigt. Nach einigen Experimenten habe ich mich dann auf <code>0.55</code> festgelegt, das brachte in meinen Augen das brauchbarste Ergebnis f√ºr dieses Photo.</p>
<p>In der <code>draw()</code>-Funktion habe ich dann das Bild acht mal hintereinander in zwei Reihen gezeichnet und mit dem filter <code>tint(color)</code> jeweils in einer anderen Farbe eingef√§rbt. Ich habe einige Zeit mit den Farben experimentieren m√ºssen, bis ich das oben angezeigt Ergebnis bekam, mit dem ich nun zufrieden bin.</p>
<h3 id="der-quellcode-6">Der Quellcode</h3>
<p>Der Quellcode ist einfach und leicht zu verstehen. Im <code>setup()</code> habe ich das Bild geladen und in eine schwarz-wei√ü-Version umgewandelt, in <code>draw()</code> habe ich dann die acht unterschiedlich eingef√§rbten Versionen erstellt. Dabei habe ich eine Schleife √ºber die Liste <code>palette[]</code> der von mir ausgew√§hlten Farben laufen lassen:</p>
<pre class="sourceCode python"><code class="sourceCode python">palette = [color(<span class="dv">205</span>, <span class="dv">133</span>, <span class="dv">63</span>), color(<span class="dv">124</span>, <span class="dv">205</span>, <span class="dv">124</span>),
           color(<span class="dv">255</span>, <span class="dv">140</span>, <span class="dv">0</span>), color(<span class="dv">255</span>, <span class="dv">20</span>, <span class="dv">147</span>),
           color(<span class="dv">238</span>, <span class="dv">238</span>, <span class="dv">0</span>), color(<span class="dv">224</span>, <span class="dv">102</span>, <span class="dv">255</span>),
           color(<span class="dv">151</span>, <span class="dv">255</span>, <span class="dv">255</span>), color(<span class="dv">205</span>, <span class="dv">200</span>, <span class="dv">177</span>)]

<span class="kw">def</span> setup():
    <span class="kw">global</span> jojo
    size(<span class="dv">640</span>, <span class="dv">320</span>)
    jojo = loadImage(<span class="st">&quot;jojo.jpg&quot;</span>)
    jojo.<span class="dt">filter</span>(THRESHOLD, <span class="fl">0.55</span>)
    noLoop()

<span class="kw">def</span> draw():
    <span class="kw">global</span> jojo
    background(<span class="dv">51</span>)
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(palette)):
        <span class="kw">if</span> (i &lt; <span class="dv">4</span>):
            row = <span class="dv">0</span>
            j = i
        <span class="kw">else</span>:
            row = <span class="dv">160</span>
            j = i - <span class="dv">4</span>
        tint(palette[i])
        image(jojo, j*<span class="dv">160</span>, row)</code></pre>
<h3 id="ressourcen">Ressourcen</h3>
<p>Nat√ºrlich k√∂nnt Ihr f√ºr Eure eigenen Experimente auch das Photo von <a href="https://www.flickr.com/photos/schockwellenreiter/7780799276/">Joey und mir</a> nutzen -- es steht schlie√ülich auf Flickr und im Fratzenbuch, aber es w√§re sicher mehr im Sinne von Andy Warhol, wenn Ihr Euch Eure eigene Bilder (aus-) sucht, die Ihr einf√§rben und serialisieren wollt.</p>
<h2 id="filter-f√ºr-die-bildverarbeitung">Filter f√ºr die Bildverarbeitung</h2>
<p>Processing und damit auch Processing.py bringen eine kleine Sammlung vorgefertigter Filter f√ºr die Bildmanipulation mit, die auf jedes Bild angewandt werden k√∂nnen. Die Filter haben folgende Syntax: Entweder</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="dt">filter</span>(MODE)</code></pre>
<p>oder</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="dt">filter</span>(MODE, param)</code></pre>
<p>Ob ein Filter einen zus√§tzlichen Paramter mitbekommen kann, h√§ngt vom Filter ab. Wie die Filter wirken und ob und wie sie einen Paramter mitbekommen, k√∂nnt Ihr der folgenden Tabelle entnehmen:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Filter</th>
<th style="text-align: center;">Ergebnis</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Originalbild (keinen Filter)</td>
<td style="text-align: center;"><img src="images/filter0200.jpg" /></td>
</tr>
<tr class="even">
<td style="text-align: left;">THRESHOLD, Parameter (optional) zwischen 0 und 1, Default 0.5</td>
<td style="text-align: center;"><img src="images/filter0201.jpg" /></td>
</tr>
<tr class="odd">
<td style="text-align: left;">GRAY, keinen Parameter</td>
<td style="text-align: center;"><img src="images/filter0202.jpg" /></td>
</tr>
<tr class="even">
<td style="text-align: left;">INVERT, photographisch gesprochen das Negativ, keinen Parameter</td>
<td style="text-align: center;"><img src="images/filter0203.jpg" /></td>
</tr>
<tr class="odd">
<td style="text-align: left;">POSTERIZE, zwischen 2 und 255, aber einen richtigen Effekt hat man nur mit niedrigen Werten</td>
<td style="text-align: center;"><img src="images/filter0204.jpg" /></td>
</tr>
<tr class="even">
<td style="text-align: left;">BLUR, je gr√∂√üer der Wert, desto verschwommener wird das Bild. Der Parameter ist optional, der Default ist 1</td>
<td style="text-align: center;"><img src="images/filter0205.jpg" /></td>
</tr>
<tr class="odd">
<td style="text-align: left;">ERODE, keinen Parameter</td>
<td style="text-align: center;"><img src="images/filter0206.jpg" /></td>
</tr>
<tr class="even">
<td style="text-align: left;">DILATE (das Gegenteil von ERODE), keinen Parameter</td>
<td style="text-align: center;"><img src="images/filter0207.jpg" /></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Filter k√∂nnen auch kombiniert werden, hier erst GRAY und dann POSTERIZE</td>
<td style="text-align: center;"><img src="images/filter0208.jpg" /></td>
</tr>
</tbody>
</table>
<p>Mit folgendem kleinen Sketch k√∂nnt Ihr mit den diversen Filtern spielen (die auskommentierten Teile habe ich f√ºr die <em>Thumbnails</em> in obiger Tabelle ben√∂tigt):</p>
<pre class="sourceCode python"><code class="sourceCode python">selectFilter = <span class="dv">8</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> img
    <span class="co"># Thumbnails</span>
    <span class="co"># size(160, 120)</span>
    <span class="co"># img = loadImage(&quot;abendrot-s.jpg&quot;)</span>
    <span class="co"># Volle Gr√∂√üe</span>
    size(<span class="dv">640</span>, <span class="dv">480</span>)
    img = loadImage(<span class="st">&quot;abendrot.jpg&quot;</span>)
    noLoop()

<span class="kw">def</span> draw():
    <span class="kw">global</span> img
    background(<span class="dv">255</span>, <span class="dv">127</span>, <span class="dv">36</span>)
    image(img, <span class="dv">0</span>, <span class="dv">0</span>)
    <span class="kw">if</span> (selectFilter == <span class="dv">1</span>):
        <span class="dt">filter</span>(THRESHOLD, <span class="fl">0.55</span>)
    <span class="kw">elif</span> (selectFilter == <span class="dv">2</span>):
        <span class="dt">filter</span>(GRAY)
    <span class="kw">elif</span> (selectFilter == <span class="dv">3</span>):
        <span class="dt">filter</span>(INVERT)
    <span class="kw">elif</span> (selectFilter == <span class="dv">4</span>):
        <span class="dt">filter</span>(POSTERIZE, <span class="dv">4</span>)
    <span class="kw">elif</span> (selectFilter == <span class="dv">5</span>):
        <span class="dt">filter</span>(BLUR, <span class="dv">6</span>)
    <span class="kw">elif</span> (selectFilter == <span class="dv">6</span>):
        <span class="dt">filter</span>(ERODE)
    <span class="kw">elif</span> (selectFilter == <span class="dv">7</span>):
        <span class="dt">filter</span>(DILATE)
    <span class="kw">elif</span> (selectFilter == <span class="dv">8</span>):
        <span class="dt">filter</span>(GRAY)
        <span class="dt">filter</span>(POSTERIZE, <span class="dv">4</span>)
    <span class="co"># save(&quot;filter020&quot; + str(selectFilter) + &quot;.jpg&quot;)</span></code></pre>
<p>Einfach bei <code>selectFilter</code> den gew√ºnschten Wert (zwischen <code>0</code> und <code>8</code>) eingeben und dann den Sketch laufen lassen. Ihr seid nat√ºrlich eingeladen, bei den Filtern, die Parameter zulassen, mit diesen zu spielen.</p>
<p>Die letzte (auskommentierte) Zeile zeigt Euch, wie Ihr das Ergebnis abspeichern k√∂nnt. Das Format des Bildes erkennt Processing an der Endung.</p>
<h3 id="filter-interaktiv">Filter interaktiv</h3>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32778594203/"><img src="images/posterize.jpg" alt="Screenshot" /></a></p>
<p>Noch besser k√∂nnt Ihr nat√ºrlich die Wirkung der diversen Filterparameter interaktiv mit der Maus erkunden. Ich habe als Beispiel daf√ºr zwei kleine Sketche geschrieben, die einmal <code>POSTERIZE</code> und zum anderen <code>THRESHOLD</code> erkunden.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    <span class="kw">global</span> img
    size(<span class="dv">640</span>, <span class="dv">480</span>)
    frame.setTitle(<span class="st">&quot;Posterize interaktiv&quot;</span>)
    img = loadImage(<span class="st">&quot;abendrot.jpg&quot;</span>)

<span class="kw">def</span> draw():
    v = <span class="dt">map</span>(mouseX, <span class="dv">0</span>, width, <span class="dv">2</span>, <span class="dv">64</span>)
    image(img, <span class="dv">0</span>, <span class="dv">0</span>)
    <span class="dt">filter</span>(POSTERIZE, v)</code></pre>
<p>Da die hohen Werte bei <code>POSTERIZE</code> keinen interessanten Effekte mehr liefern, habe ich hier mithilfe der <code>map()</code>-Funktion den Parameter auf die Werte zwischen <code>2</code> und <code>64</code> begrenzt.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    <span class="kw">global</span> img
    size(<span class="dv">640</span>, <span class="dv">480</span>)
    frame.setTitle(<span class="st">&quot;Threshold interaktiv&quot;</span>)
    img = loadImage(<span class="st">&quot;abendrot.jpg&quot;</span>)

<span class="kw">def</span> draw():
    v = <span class="dt">float</span>(mouseX)/width
    image(img, <span class="dv">0</span>, <span class="dv">0</span>)
    <span class="dt">filter</span>(THRESHOLD, v)</code></pre>
<p><code>THRESHOLD</code> erwartet Werte zwischen <code>0.0</code> und <code>1.0</code>. Daher habe ich einfach den <code>mouseX</code>-Wert durch die Breite des Fensters geteilt. Wegen der Integer-Division von Python 2.7 mu√üte ich einen der Werte explizit zu einem <code>float</code> konvertieren, um das gew√ºnschte Ergebnis zu erhalten (denn sonst bekommt man nur den Wert Null). So aber wird das Bild, wenn die Maus ganz weit links ist, nur wei√ü, w√§hrend es bei einer Mausposition ganz rechts im Fenster fast vollst√§ndig schwarz wird. Irgendwo dazwischen liegen die interessanten Ergebnisse. Ihr solltet dies mit diversen Bildern ausprobieren, um ein Gef√ºhl f√ºr die zu erwartenden Effekte zu bekommen.</p>
<h2 id="pointillismus">Pointillismus</h2>
<p><a href="https://de.wikipedia.org/wiki/Pointillismus">Pointillismus</a> bezeichnet eine Stilrichtung der Malerei, die zwsichen 1889 und 1910 ihre Bl√ºtezeit hatte. Pointillistische Bilder bestehen aus kleinen regelm√§√üigen Farbtupfern in reinen Farben. Der Gesamt-Farbeindruck einer Fl√§che ergibt sich erst im Auge des Betrachters und aus einer gewissen Entfernung. So etwas in der Art kann man nat√ºrlich auch leicht in Processing.py nachbilden (wobei die m√∂glichst reinen Farben in dem Beispielprogramm nur ann√§hernd getroffen werden, weil es sich bei dem Ausgangsbild um eine handkolorierte Photographie vermutlich ebenfalls aus dem 19. Jahrhundert handelt[^pointfn1]).</p>
<figure>
<img src="images/screenshotfarbakt02.jpg" alt="Nachkolorierter Akt" /><figcaption>Nachkolorierter Akt</figcaption>
</figure>
<p>Das Programmfenster zeigt links das Ausgangsbild. Rechts entsteht so langsam das aus Kreisen zuf√§lliger Gr√∂√üe zusammengesetzte Zielbild. Dabei besitzen die Punkte einen Ausganswert (<code>radius</code>) von sechs, der mit einem Zufallsfaktor zwischen 0.2 und 1.5 multipliziert wird. (Ich benutze im Programm die <code>randint()</code>-Funktion von Python und nicht die eingebaute <code>random()</code>-Funktion von Processing. Mir ist die Python-Funktion irgendwie sympathischer, aber das ist vermutlich Geschmackssache.)</p>
<p>Bei jedem Durchlauf der <code>draw()</code>-Schleife wird der Farbwert eines zuf√§lligen Punktes im Ursprungsbild ermittelt und dann als Kreis (Punkt) im Zielbild eingezeichnet. Das Ergebnis gleicht dem Ursprungsbild, nur das es den Anschein erweckt, als w√ºrde man es durch eine Scheibe Strukturglas, wie sie manchmal Duschen- oder Badezimmert√ºren zieren, betrachten.</p>
<h3 id="der-quellcode-7">Der Quellcode</h3>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> random <span class="ch">as</span> r
radius = <span class="dv">6</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> akt
    size(<span class="dv">800</span>, <span class="dv">640</span>)
    akt = loadImage(<span class="st">&quot;akt.jpg&quot;</span>)
    background(<span class="dv">0</span>)
    frameRate(<span class="dv">600</span>)

<span class="kw">def</span> draw():
    <span class="kw">global</span> akt
    image(akt, <span class="dv">0</span>, <span class="dv">0</span>)
    x = r.randint(<span class="dv">0</span>, akt.width - <span class="dv">1</span>)
    y = r.randint(<span class="dv">0</span>, akt.height - <span class="dv">1</span>)
    c = akt.pixels[x + y*akt.width]
    zufall = r.randint(<span class="dv">2</span>, <span class="dv">15</span>)/<span class="fl">10.0</span>
    noStroke()
    fill(c)
    ellipse(x + <span class="dv">400</span>, y, radius*zufall, radius*zufall)</code></pre>
<p>Der Quellcode ist wieder sch√∂n kurz und l√§dt zum Experimentieren ein. Setzt man zum Beispiel die Konstante <code>radius = 3</code>, dann wirkt das Zielbild bedeutend realistischer. Und ein sehr seltsames Ergebnis bekommt man, wenn man die Zeile mit dem <code>noStroke()</code> auskommentiert.</p>
<p>Man mu√ü nat√ºrlich nicht unbedingt Kreise zeichnen. Ein Quadrat oder ein Dreieck ergibt noch ganz andere Effekte. Spielt einfach mal ein wenig damit herum. Processing(.py) ist zum Spielen entworfen worden.</p>
<h2 id="noch-mehr-pointillismus">Noch mehr Pointillismus</h2>
<p>Wenn ich ehrlich bin, kann das Ergebnis des Programms aus dem letzten Abschnitt weder √§sthetisch noch im Sinne des Pointillismus wirklich √ºberzeugen. Das liegt daran, da√ü im Programm jedes einzelne Pixel befragt und dann als vergr√∂√üerter Punkt wiedergegeben wird. So entsteht im Endeffekt so etwas wie ein verwaschenes Original, aber kein Raster. Daher habe ich -- nach einer Idee aus dem wunderbaren Buch ¬ª<a href="https://www.amazon.de/Generative-Gestaltung-Programmieren-internationalen-Best-Practise-Beispielen/dp/3874397599/ref=as_li_ss_tl?ie=UTF8&amp;qid=1496078767&amp;sr=8-1&amp;keywords=Generative+Gestaltung&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=006bf37e45fc0b671a7ec6a217fb69da">Generative Gestaltung</a>¬´ (derzeit leider nur auf englisch <a href="https://www.amazon.de/Generative-Design-Visualize-Program-Processing/dp/1616890770/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=60caedf2804bda621d07eea10332003d">verf√ºgbar</a>) -- tats√§chlich eine Rasterversion des Aktbildes programmiert und das Ergebnis √ºberzeugt mich mehr:</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/34807667812/"><img src="images/akt2.jpg" alt="Screenshot" /></a></p>
<p>Daf√ºr habe ich zuerst das Bild, das im Original 400 x 640 Pixel gro√ü war, auf 50 x 80 Pixel verkleinert um dann mit</p>
<pre class="sourceCode python"><code class="sourceCode python">tileWidth = width/<span class="dt">float</span>(akt.width)
tileHeight = height/<span class="dt">float</span>(akt.height)
posX = tileWidth*gridX
posY = tileHeight*gridY</code></pre>
<p>ein entsprechendes Raster f√ºr das immer noch 400 x 640 Pixel gro√üe Ausgabefenster zu schaffen. Mit der Formel</p>
<pre class="sourceCode python"><code class="sourceCode python">greyscale = <span class="dt">round</span>(red(cc)*<span class="fl">0.222</span> + green(cc)*<span class="fl">0.707</span> + blue(cc)*<span class="fl">0.071</span>)</code></pre>
<p>habe ich danach die abgetasteten Farben in Graustufen gewandelt, die Gewichtungen habe ich dem oben erw√§hnten Buch ¬ªGenerative Gestaltung¬´ entnommen, die <a href="https://de.wikipedia.org/wiki/Grauwert">Wikipedia</a> zum Beispiel nennt andere Gewichtungen, aber auch gleichverteilte Gewichtungen sind m√∂glich und √ºblich. Hier gibt es also noch Raum f√ºr Experimente.</p>
<p>Mit</p>
<pre class="sourceCode python"><code class="sourceCode python">w = <span class="dt">map</span>(greyscale, <span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">12</span>, <span class="dv">0</span>)</code></pre>
<p>habe ich dann den Radius der Kreise in Abh√§ngigkeit von der Graustufe bestimmt: Je dunkler die Graustufe, desto gr√∂√üer der Kreis. Den Wert <code>12</code> habe ich experimentell herausgefunden, auch hier ist ebenfalls noch Raum f√ºr Experimente. So bekommt man zum Beispiel auch ein nettes Ergebnis, wenn man die Zeile</p>
<pre class="sourceCode python"><code class="sourceCode python">fill(cc)</code></pre>
<p>durch</p>
<pre class="sourceCode python"><code class="sourceCode python">fill(greyscale)</code></pre>
<p>ersetzt. Der <a href="https://github.com/generative-design/Code-Package-Processing-3.x/blob/master/01_P/P_4_3_1_01/P_4_3_1_01.pde">Processing-Quellcode</a> aus ¬ªGenerative Gestaltung¬´ zeigt ebenfalls noch ein paar wirklich nette M√∂glichkeiten, was man mit so einem Grid alles anstellen kann.</p>
<h3 id="der-quellcode-8">Der Quellcode</h3>
<p>Hier nun der vollst√§ndige Quellcode, er ist -- wie fast immer -- erfrischend kurz:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    <span class="kw">global</span> akt
    size(<span class="dv">400</span>, <span class="dv">640</span>)
    akt = loadImage(<span class="st">&quot;akt50x80.jpg&quot;</span>)
    background(<span class="dv">255</span>)
    noLoop()

<span class="kw">def</span> draw():
    <span class="kw">global</span> akt
    <span class="kw">for</span> gridX in <span class="dt">range</span>(akt.width):
        <span class="kw">for</span> gridY in <span class="dt">range</span>(akt.height):
            <span class="co"># grid position and tile size</span>
            tileWidth = width/<span class="dt">float</span>(akt.width)
            tileHeight = height/<span class="dt">float</span>(akt.height)
            posX = tileWidth*gridX
            posY = tileHeight*gridY
            <span class="co"># get current color</span>
            cc = akt.pixels[gridY*akt.width + gridX]
            <span class="co"># greyscale conversion</span>
            greyscale = <span class="dt">round</span>(red(cc)*<span class="fl">0.222</span> + green(cc)*<span class="fl">0.707</span> + blue(cc)*<span class="fl">0.071</span>)
            <span class="co"># pixel color to fill, greyscale to ellipse size</span>
            noStroke()
            fill(cc)
            w = <span class="dt">map</span>(greyscale, <span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">12</span>, <span class="dv">0</span>)
            ellipse(posX, posY, w, w)</code></pre>
<h1 id="animationen">Animationen</h1>
<h2 id="ein-kleiner-roter-luftballon">Ein kleiner roter Luftballon</h2>
<p>Die Idee zu diesem Tutorial kam mir, nachdem ich <a href="https://www.youtube.com/watch?v=DPFJROWdkQ8">ein Video</a> von <em>Daniel Shiffman</em> gesehen hatte, in dem er Pflanzen wie Blasen aufsteigen lie√ü. Dieser Sketch war eine Erweiterung eines anderen Sketches <em>Bubbles</em> (<a href="https://github.com/CodingRainbow/Rainbow-Code/tree/master/Processing/11_video/sketch_15_2_array_images">Quellcode</a>), in dem er die dort verwendeten Kreise durch die Bilder von Bl√ºten ersetzte. Ich dachte mir, so etwas √§hnliches m√∂chte ich auch einmal mit Processing.py programmieren und es sollte auch noch sch√∂ner aussehen. Zwar hatte ich zumindest eine der Bl√ºten auch als PNG-Datei -- es ist n√§mlich das Logo von <em>TextMate 2</em>, meines bevorzugten Texteditors --, aber ich dachte schon beim Anschauen des Videos sofort an Ballons und die bekommt man als Emoji geliefert. Nun ist aber Python 2.7 und damit auch Jython, das den Python-Mode von Processing antreibt, nicht gerade wirklich UTF-8-fest und Emoji-freundlich, also mu√üten Bilder her. Die L√∂sung sind die <a href="https://github.com/twitter/twemoji">Twemojis</a> von Twitter, ein vollst√§ndiger Emoji-Bilder-Satz in diversen Aufl√∂sungen und auch als SVG, der unter der unter der <a href="https://creativecommons.org/licenses/by/4.0/">CC-BY-4.0</a> Lizenz steht und frei verwendet werden kann. Dort habe ich mir erst einmal den Ballon als 72x72 Pixel gro√ües, transparentes PNG herausgesucht</p>
<figure>
<img src="images/1f388.png" alt="Ballon" /><figcaption>Ballon</figcaption>
</figure>
<p>und dann zum Warmwerden damit diesen kleinen Sketch geschrieben:</p>
<pre class="sourceCode python"><code class="sourceCode python">speed = <span class="fl">1.5</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> balloon, x, y
    size(<span class="dv">400</span>, <span class="dv">200</span>)
    balloon = loadImage(<span class="st">&quot;1f388.png&quot;</span>)
    x = random(<span class="dv">0</span>, width<span class="dv">-72</span>)
    y = height

<span class="kw">def</span> draw():
    <span class="kw">global</span> balloon, x, y
    background(<span class="dv">51</span>)
    image(balloon, x, y)
    y -= speed
    <span class="kw">if</span> (y &lt; -<span class="dv">72</span>):
        y = height
        x = random(<span class="dv">0</span>, width<span class="dv">-72</span>)</code></pre>
<p>Damit zieht ein einsamer kleiner, roter Luftballon durch das Sketch-Fenster, der -- wenn er oben am Fesnterrand verschwindet -- unten an einer anderen, zuf√§lligen Position wieder auftaucht.</p>
<figure>
<img src="images/ballon01.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<h3 id="viele-viele-rote-luftballons">Viele, viele rote Luftballons</h3>
<p>Doch da geht nat√ºrlich mehr. Ich wollte mehrere Ballons aufsteigen lassen und sie sollten sich auch ein wenig zuf√§lliger bewegen. Und was macht man, wenn man mehrere √§hnliche Objekt hat? Richtig, man erstellt eine Klasse f√ºr diese Objekte:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Balloon():
    
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, dia, img):
        <span class="ot">self</span>.diameter = dia
        <span class="ot">self</span>.x = random(<span class="dv">0</span>, width - <span class="ot">self</span>.diameter)
        <span class="ot">self</span>.y = height
        <span class="ot">self</span>.diameter = dia
        <span class="ot">self</span>.img = img
        <span class="ot">self</span>.yspeed = random(<span class="fl">0.5</span>, <span class="dv">2</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.y -= <span class="ot">self</span>.yspeed
        <span class="ot">self</span>.x = <span class="ot">self</span>.x + random(-<span class="dv">2</span>, <span class="dv">2</span>)
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.img, <span class="ot">self</span>.x, <span class="ot">self</span>.y, <span class="ot">self</span>.diameter, <span class="ot">self</span>.diameter)
        
    <span class="kw">def</span> top(<span class="ot">self</span>):
        <span class="kw">if</span> (<span class="ot">self</span>.y &lt;= <span class="dv">0</span>):
            <span class="ot">self</span>.y = <span class="dv">0</span></code></pre>
<p>Bilder in Processing funktionieren im Prinzip wie Rechtecke. Wird die Funktion <code>image(x, y)</code> nur mit zwei Parametern aufgerufen, wird das Bild an dieser Stelle in seiner vollen Gr√∂√üe gezeigt. Ruft man hingegen <code>image(x, y, w, h)</code> auf, dann wird das Bild an dieser Stelle mit den Seitenl√§ngen <code>w</code> und <code>h</code> gezeigt. Dabei wird das Bild im Zweifelsfalle auch proportional gestaucht oder gestreckt. Ihr k√∂nnt es einfach mal ausprobieren, indem Ihr ein Bild in <code>draw()</code> mit <code>image(0, 0, mouseX, mouseY)</code> aufruft.</p>
<p>Ich habe aber einfach dem Konstruktor der Klasse den Durchmesser des Bildes mitgegeben und eine Referenz auf das Bild, das zu laden ist. Dann wird mit <code>move()</code> das Bild bewegt und mit <code>display()</code> wird es in das Sketchfenster gezeichnet. Diese Konstruktion wird Euch in vielen Klassen in Processing begegnen.</p>
<p>Eine Besonderheit ist die Methode <code>top()</code>. Hier wird abgefragt, ob der Luftballon das obere Fenster erreicht hat und bleibt dann zitternd dort kleben.</p>
<p>Hier dann das Hauptprogramm,</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> balloon <span class="ch">import</span> Balloon

numBalloons = <span class="dv">15</span>
balloons = []

<span class="kw">def</span> setup():
    size(<span class="dv">640</span>, <span class="dv">320</span>)
    i = <span class="dv">0</span>
    balloon = loadImage(<span class="st">&quot;1f388.png&quot;</span>)
    <span class="kw">while</span> (i &lt; numBalloons):
        dia = random(<span class="dv">24</span>, <span class="dv">72</span>)
        balloons.append(Balloon(dia, balloon))
        i += <span class="dv">1</span>

<span class="kw">def</span> draw():
    background(<span class="dv">51</span>)
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(balloons)):
        balloons[i].move()
        balloons[i].display()
        balloons[i].top()</code></pre>
<p>das dann dieses Bild erzeugt, das ich in diesem Screenshot zu Beginn festgehalten habe:</p>
<figure>
<img src="images/balloon02.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Ein wenig habe ich dabei gemogelt. Denn um √ºberhaupt noch ein paar Ballons zu erwischen, die nicht an der Decke kleben, hatte ich die Geschwindigkeit drastisch reduziert.</p>
<h3 id="es-kann-nicht-nur-einen-geben">Es kann nicht nur einen geben</h3>
<p>Meine Idee war es aber, da√ü die Ballons vollst√§ndig den oberen Fensterrand passieren und dann an einer zuf√§lligen Position und in einer zuf√§lligen Gr√∂√üe unten wieder auftauchte, so da√ü die Illusion eines kontinuierlichen Ballonaufstiegs entsteht. Daher habe ich die Methode <code>top()</code> in der Klasse <code>Ballon</code> umgeschrieben:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> top(<span class="ot">self</span>):
        <span class="kw">if</span> (<span class="ot">self</span>.y &lt;= -<span class="ot">self</span>.diameter):
            <span class="ot">self</span>.y = height + <span class="ot">self</span>.diameter
            <span class="ot">self</span>.x = random(<span class="dv">0</span>, width - <span class="ot">self</span>.diameter)
            <span class="ot">self</span>.diameter = random(<span class="dv">24</span>, <span class="dv">72</span>)
            <span class="ot">self</span>.yspeed = random(<span class="fl">0.5</span>, <span class="dv">2</span>)</code></pre>
<p>Au√üerdem fand ich nur einen Ballon langweilig. <em>Dan Shiffman</em> hat in seinem oben erw√§hnten Video ja auch drei unterschiedliche Bl√ºten gen√ºtzt. Also habe ich die Twemojis weiter gepl√ºndert und mir diese drei Vertreter ausgesucht:</p>
<p><img src="images/1f388.png" alt="Ballon" /> <img src="images/1f383.png" alt="Ballon" /> <img src="images/1f390.png" alt="Ballon" /></p>
<p>Neben dem schon bekannten Ballon (<code>1f388.png</code>) ist es noch ein Halloween-K√ºrbis (<code>1f383.png</code>) und ein japanisches Windspiel (<code>1f390.png</code>), das zum Himmel aufsteigen soll:</p>
<figure>
<img src="images/ballon03.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Die Klasse <code>Balloon</code> mu√üte daf√ºr nicht weiter ge√§ndert werden, aber im Hauptprogramm habe ich einige Erweiterungen durchgef√ºhrt.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> balloon <span class="ch">import</span> Balloon

numBalloons = <span class="dv">100</span>
balloons = []

<span class="kw">def</span> setup():
    size(<span class="dv">640</span>, <span class="dv">320</span>)
    i = <span class="dv">0</span>
    balloon = loadImage(<span class="st">&quot;1f388.png&quot;</span>)
    jackolantern = loadImage(<span class="st">&quot;1f383.png&quot;</span>)
    windchime = loadImage(<span class="st">&quot;1f390.png&quot;</span>)
    <span class="kw">while</span> (i &lt; numBalloons):
        rand = random(<span class="dv">10</span>)
        <span class="kw">if</span> (rand &lt; <span class="dv">1</span>):
            img = jackolantern
        <span class="kw">elif</span> (rand &lt; <span class="dv">8</span>):
            img = balloon
        <span class="kw">else</span>:
            img = windchime
        dia = random(<span class="dv">24</span>, <span class="dv">72</span>)
        balloons.append(Balloon(dia, img))
        i += <span class="dv">1</span>

<span class="kw">def</span> draw():
    background(<span class="dv">51</span>)
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(balloons)):
        balloons[i].move()
        balloons[i].display()
        balloons[i].top()</code></pre>
<p>Die Anzahl der ¬ªBallons¬´ habe ich gro√üz√ºgig auf 100 erh√∂ht -- man hat's ja. In <code>setup()</code> habe ich dann die Bilder der einzelnen Objekte geladen und in der <code>while</code>-Schleife sie erst einmal zuf√§llig verteilt und dann die 100 Objekte in einer Liste erzeugt.</p>
<h3 id="in-lorenzkirch-ist-jahrmarkt">In Lorenzkirch ist Jahrmarkt</h3>
<figure>
<img src="images/jahrmarkt03.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Zu guter Letzt habe ich noch den Hintergrund aufgeh√ºbscht und ihn mit einem Bild des <a href="https://de.wikipedia.org/wiki/Lorenzkirch#Gr.C3.BCndung_des_Ortes_Lorenzkirch.2C_der_Sankt_Laurentiuskirche_und_des_Laurentiusmarktes">Jahrmarkts von Lorenzkirch</a> um 1900 versehen. Der vollst√§ndige Sketch sieht nun so aus:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> balloon <span class="ch">import</span> Balloon

numBalloons = <span class="dv">100</span>
balloons = []

<span class="kw">def</span> setup():
    <span class="kw">global</span> jahrmarkt
    size(<span class="dv">640</span>, <span class="dv">320</span>)
    jahrmarkt = loadImage(<span class="st">&quot;jahrmarkt.jpg&quot;</span>)
    i = <span class="dv">0</span>
    balloon = loadImage(<span class="st">&quot;1f388.png&quot;</span>)
    jackolantern = loadImage(<span class="st">&quot;1f383.png&quot;</span>)
    windchime = loadImage(<span class="st">&quot;1f390.png&quot;</span>)
    <span class="kw">while</span> (i &lt; numBalloons):
        rand = random(<span class="dv">10</span>)
        <span class="kw">if</span> (rand &lt; <span class="dv">1</span>):
            img = jackolantern
        <span class="kw">elif</span> (rand &lt; <span class="dv">8</span>):
            img = balloon
        <span class="kw">else</span>:
            img = windchime
        dia = random(<span class="dv">24</span>, <span class="dv">72</span>)
        balloons.append(Balloon(dia, img))
        i += <span class="dv">1</span>

<span class="kw">def</span> draw():
    <span class="kw">global</span> jahrmarkt
    background(jahrmarkt)
    <span class="co"># background(51)</span>
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(balloons)):
        balloons[i].move()
        balloons[i].display()
        balloons[i].top()</code></pre>
<p>An der Klasse <code>Balloon</code> wurde nichts mehr ge√§ndert.</p>
<h3 id="credits-3">Credits</h3>
<p>Neben den oben schon erw√§hnten Twemojis, f√ºr die ich Twitter danke, habe ich das <a href="https://commons.wikimedia.org/wiki/File:Jahrmarkt_in_Lorenzkirch_im_Jahr_1900.jpg">Bild des Lorenzmarktes um 1900</a> den Wikimedia Commons entnommen. Es ist alt genug, da√ü es gemeinfrei ist und frei verwendet werden darf.</p>
<figure>
<img src="images/jahrmarkt.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<h1 id="spa√ü-mit-svg--shapes-pinguine-im-eismeer">Spa√ü mit (SVG-) Shapes: Pinguine im Eismeer</h1>
<p>Neben Bildern kann Processing (und damit auch Processing.py) auch SVG-Dateien laden und darstellen. Wie alle anderen Assets auch, m√ºssen diese sich im <code>data</code>-Verzeichnis des Sketches befinden, damit Processing sie auch finden kann. Doch woher soll solch ein absoluter Kunstbanause wie ich SVG-Dateien finden, wenn er sie nicht stehlen will? Hier haben mir wieder die <a href="https://github.com/twitter/twemoji">Twemojis</a> geholfen, der vollst√§ndige Emoji-Bilder-Satz von Twitter, der nicht nur in diversen Aufl√∂sungen, sondern auch als SVG-Dateien unter der <a href="https://creativecommons.org/licenses/by/4.0/">CC-BY-4.0 Lizenz</a> zur Verf√ºgung steht und frei verwendet werden kann. Eines dieser Emojis ist ein Pinguin und mit dem werde ich nun ein wenig herumspielen.</p>
<!-- 
![Pinguin](images/1f427.svg) -->
<p>SVG-Dateien sind Vektorgraphiken und sie k√∂nnen verlustlos vergr√∂√üert und verkleinert werden. Das m√∂chte ich im ersten Sketch vorf√ºhren:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    <span class="kw">global</span> penguin
    size(<span class="dv">400</span>, <span class="dv">400</span>)
    penguin = loadShape(<span class="st">&quot;1f427.svg&quot;</span>)
    shapeMode(CENTER)

<span class="kw">def</span> draw():
    background(<span class="dv">155</span>)
    shape(penguin, width/<span class="dv">2</span>, height/<span class="dv">2</span>,
          <span class="dt">map</span>(mouseX, <span class="dv">0</span>, width, <span class="dv">0</span>, <span class="dv">800</span>),
          <span class="dt">map</span>(mouseX, <span class="dv">0</span>, width, <span class="dv">0</span>, <span class="dv">800</span>))</code></pre>
<p>Die Gr√∂√üe des Pinguins ist nun von der Mauskoordinate-x abh√§ngig und variiert von winzig klein bis riesengro√ü. Zu beachten ist, da√ü auch ein SVG-Shape diverse <code>shapeModes()</code> besitzen kann, der Default ist <code>CORNER</code>, bei dem die linke obere Ecke der Ankerpunkt ist, aber es gibt, wie bei anderen Shapes auch, die Modes <code>CENTER</code> und <code>CORNERS</code>.</p>
<p>Ein SVG-Shape wird mit <code>loadShape(&quot;dateiname.svg&quot;)</code> geladen und mit</p>
<pre class="sourceCode python"><code class="sourceCode python">shape(dateihandle, x, y)</code></pre>
<p>oder</p>
<pre class="sourceCode python"><code class="sourceCode python">shape(dateihandle, x, y, w, h)</code></pre>
<p>in das Sketch-Fenster gezeichnet. Im ersten Fall wird das SVG-Shape an den Punkten <code>x, y</code> in der Originalgr√∂√üe gezeichnet, im zweiten Fall wird das SVG-Shape mit den Paramtern f√ºr die Weite und H√∂he verkleinert oder vergr√∂√üert dargestellt.</p>
<figure>
<img src="images/penguin.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Wenn Ihr diesen Sketch laufen lasst, seht Ihr, da√ü die Verkleinerung oder Vergr√∂√üerung tats√§chlich absolut verlustfrei erfolgt.</p>
<h2 id="und-nun-das-eismeer">Und nun das Eismeer</h2>
<figure>
<img src="images/pinguine.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Wenn man den obige Sketch ein wenig erweitert, kann man etwas mehr Aktion in die Angelegenheit bringen. Ich habe dazu drei Pinguine in ein Eismeer gestellt, die, je nach Interpretation, ein wenig die Gegend erkunden oder sich einfach nur die F√º√üe vertreten.</p>
<pre class="sourceCode python"><code class="sourceCode python">easing = <span class="fl">0.05</span>
offset = <span class="dv">0</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> penguin, landscape
    size(<span class="dv">640</span>, <span class="dv">400</span>)
    penguin = loadShape(<span class="st">&quot;1f427.svg&quot;</span>)
    landscape = loadImage(<span class="st">&quot;eismeer.jpg&quot;</span>)
    

<span class="kw">def</span> draw():
    <span class="kw">global</span> offset
    background(landscape)
    
    targetOffset = <span class="dt">map</span>(mouseX, <span class="dv">0</span>, width, -<span class="dv">100</span>, <span class="dv">100</span>)
    offset += (targetOffset - offset)*easing
    smallerOffset = offset*<span class="fl">0.7</span>
    smallestOffset = smallerOffset * -<span class="fl">0.5</span>
    shape(penguin, <span class="dv">60</span> + offset, <span class="dv">160</span>, <span class="dv">160</span>, <span class="dv">160</span>)
    shape(penguin, <span class="dv">260</span> + smallerOffset, <span class="dv">130</span>, <span class="dv">80</span>, <span class="dv">80</span>)
    shape(penguin, <span class="dv">520</span> + smallestOffset, <span class="dv">220</span>, <span class="dv">120</span>, <span class="dv">120</span>)</code></pre>
<p>Es passiert eigentlich immer noch nicht viel, aber wenn man etwas mehr Aktion w√ºnscht, dann kommt man wohl nicht darum herum, eine Pinguin-Klasse anzulegen und die einzelnen Pinguin-Objekte in einer Liste zu verwalten, so wie ich es zum Beispiel im letzten Tutorial mit den Ballons gemacht hatte.</p>
<h2 id="wartet-da-ist-noch-mehr">Wartet, da ist noch mehr</h2>
<p>Die Funktion <code>shape()</code> kann nicht nur SVG-Dateien darstellen, sondern auch dreidimensionale OBJ-Dateien. Daf√ºr mu√ü nat√ºrlich der Sketch im <code>P3D</code>-Mode laufen.</p>
<h2 id="credits-4">Credits</h2>
<figure>
<img src="images/eismeer.jpg" alt="Das Eismeer" /><figcaption>Das Eismeer</figcaption>
</figure>
<p>Das Hintergrundbild des zweiten Sketches ist ein Gem√§lde des deutschen, romantischen Malers <a href="https://de.wikipedia.org/wiki/Caspar_David_Friedrich">Caspar David Friedrich</a>. Dieser ist 1840 gestorben, also hinreichend lange tot, so da√ü das Bild gemeinfrei ist und ohne Lizenzkosten verwendet werden kann.</p>
<h1 id="objkete-und-klassen-mit-kitty">Objkete und Klassen mit Kitty</h1>
<h2 id="hallo-h√∂rnchen-hallo-kitty-revisited">Hallo H√∂rnchen ‚Äì Hallo Kitty revisited</h2>
<p>Nachdem ich am Wochenende mal wieder an <a href="http://cognitiones.kantel-chaos-team.de/multimedia/spieleprogrammierung/pygame.html">PyGame</a> verzweifelt bin (aus irgendwelchen Gr√ºnden funktionierte die Tastaturabfrage nicht), habe ich beschlossen, mich doch eher <a href="http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/processingpy.html">Processing.py</a> zuzuwenden, dem Python-Mode f√ºr <a href="http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/processing.html">Processing</a>. Ziel sollte es sein, mein vierteiliges PyGame-Tutorial vom Mai dieses Jahres in Processing.py zu implementieren. Erfreulich war, da√ü ich mir den <a href="http://blog.schockwellenreiter.de/2016/05/2016052001.html">ersten Teil</a> gleich schenken konnte, denn</p>
<pre class="{python}"><code>def setup():
    size(640, 480)

def draw():
    background(0, 80, 125)</code></pre>
<p>erzeugt bereits ein leeres, blaues Fenster. Also habe ich gleich den <a href="http://blog.schockwellenreiter.de/2016/05/2016052003.html">zweiten Teil</a> in Angriff genommen und das <em>¬ªHorn Girl¬´</em> aus dem von <em>Daniel Cook (Danc)</em> in seinem Blog <em><a href="http://www.lostgarden.com/search/label/free%20game%20graphics">Lost Garden</a></em> unter einer <a href="http://www.lostgarden.com/2007/03/lost-garden-license.html">freien Lizenz</a> (<a href="http://creativecommons.org/licenses/by/3.0/us/">CC BY 3.0 US</a>) zu Verf√ºgung gestellten Tileset <a href="http://www.lostgarden.com/2007/05/dancs-miraculously-flexible-game.html">Planet Cute</a> in das Fenster gezaubert:</p>
<figure>
<img src="images/hellokitty-b.jpg" alt="Hallo H√∂rnchen!" /><figcaption>Hallo H√∂rnchen!</figcaption>
</figure>
<p>Zur Vorbereitung habe ich erst einmal das Bild der jungen Dame auf das Editorfenster der Processing-IDE geschoben. Falls noch nicht vorhanden, erzeugt Processing dann automatisch ein <code>data</code>-Verzeichnis und legt das Bild (aber auch Schriften oder andere Dateien) darin ab. Processing und damit auch Processing.py finden alles in diesem Verzeichnis ohne da√ü eine genauere Pfadangabe n√∂tig ist. Und so ist auch das fertige Programm von erfrischender K√ºrze:</p>
<pre class="{python}"><code>font = None
greetings = u&#39;Hallo H√∂rnchen!&#39;

def setup():
    global img
    size(640, 480)
    img = loadImage(&quot;horngirl.png&quot;)
    font = createFont(&quot;Verdana-Bold&quot;, 64)
    textFont(font)

def draw():
    background(0, 80, 125)
    image(img, 275, 100)
    text(greetings, 25, 350)</code></pre>
<p>Mehr ist nicht n√∂tig, um obigen Screenshot zu bekommen. Vergleiche ich diese 14 Zeilen mit den 34 Zeilen der PyGame-Version, dann frage ich mich schon, warum ich nicht fr√ºher zu Processing.py gewechselt bin<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>.</p>
<p>An der zweiten Zeile kann man es erkennen: Processing.py basiert auf <a href="http://cognitiones.kantel-chaos-team.de/programmierung/python/jython.html">Jython</a> und ist damit kompatibel zu Python 2.7.5, aber nicht zu Python 3. Daher mu√ü man Unicode-Strings (zum Beispiel mit deutschen Umlauten) explizit mit dem vorangestellten <code>u</code> markieren, sonst bekommt man seltsame Zeichen im Programmfenster angezeigt.</p>
<p>Processing(.py) kann mit Fonts im TrueType- (<code>.ttf</code>), OpenType- (<code>.otf</code>) und in einem eigenen Bitmap-Format, genannt VLW, umgehen. Nat√ºrlich findet es alle auf dem eigenen Rechner installierte Fonts, mit</p>
<pre class="{python}"><code>fontList = PFont.list()
print(fontList)</code></pre>
<p>kann man sich diese in der Konsole anzeigen lassen. Wenn man den Sketch allerdings weitergeben will, ist es sinnvoll, einen Font mitzugeben[kittyfn^2], da man nicht sicher sein kann, ob der gew√§hlte Systemfont auf dem anderen Rechner vorhanden ist. Daf√ºr schiebt man eine entsprechende Font-Datei einfach ebenfalls auf das Editorfenster der IDE, damit sie dem <code>data</code>-Ordner hinzugef√ºgt wird. Ich habe testweise mal die Datei <code>OpenSans-Semibold-webfont.ttf</code> installiert, die entsprechende Zeile im Programm hie√üe dann:</p>
<pre class="{python}"><code>font = createFont(&quot;OpenSans-Semibold-webfont.ttf&quot;, 64)</code></pre>
<p>Der zweite Parameter der Funktion <code>createFont()</code> benennt die gew√ºnschte Gr√∂√üe des Fonts. Mehr ist zu diesem ersten Sketch in Processing.py eigentlich nciht zu sagen. Im n√§chsten Schritt wird es darum gehen, die junge Dame √ºber das Fenster zu bewegen. Nach meinen Erfahrungen mit PyGame werde ich sie nicht nur mit der Maus, sondern auch mit der Tastatur steuern. <em>Still digging!</em></p>
<h2 id="moving-kitty">Moving Kitty</h2>
<p>Im zweiten Teil meiner kleinen Erkundung von <a href="http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/processingpy.html">Processing.py</a>, dem <a href="http://cognitiones.kantel-chaos-team.de/programmierung/python/python.html">Python</a>-Mode von <a href="http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/processing.html">Processing</a>, m√∂chte ich die im <a href="hallohoernchen.md">ersten Teil</a> auf den Monitor gezauberte <em>Kitty</em> mithilfe der Pfeiltasten der Tastatur sich √ºber den Monitor bewegen lassen.</p>
<figure>
<img src="images/movingkitty-b.jpg" alt="Moving Kitty" /><figcaption>Moving Kitty</figcaption>
</figure>
<p>In Processing geh√∂ren die Pfeiltasten wie einige andere auch zu den <code>coded keys</code>, weil sie sich nicht einem Buchstaben zuordnen lassen und haben daher einen speziellen Namen. Die Pfeiltastten hei√üen <code>LEFT</code>, <code>RIGHT</code>, <code>UP</code> und <code>DOWN</code>, andere <code>coded keys</code> sind zum Beispiel <code>ALT</code>, <code>CONTROL</code> oder <code>SHIFT</code>. Diese m√ºssen in Processing wie in Processing.py gesondert abgefragt werden, und zwar so:</p>
<pre class="{python}"><code>    if keyPressed and key == CODED:
        if keyCode == LEFT:</code></pre>
<p>w√§hrend die ¬ªnormalen¬´ Tasten so abgefragt werden k√∂nnen:</p>
<pre class="{python}"><code>    if keyPressed:
        if key == &#39;b&#39; or key == &#39;B&#39;:</code></pre>
<p>Das ist eigentlich alles, was man wissen mu√ü, um das Progr√§mmchen zu verstehen. Wenn Kitty den linken Rand des Fensters erreicht hat, taucht sie am rechten Rand wieder auf und umgekehrt. Genauso habe ich mit oben unten verfahren. Die Variabeln <code>radius_x</code> und <code>radius_y</code> sorgen daf√ºr, da√ü <em>Kitty</em> vollst√§ndig vom Bildschirm verschwunden ist, bevor sie am anderen Ende wieder auftaucht (ich mag keine halben Kittys üòú ) und mit <code>STEP</code> bestimmt Ihr die Geschwindigkeit, mit der Kitty √ºber den Bildschirm wuselt. Hier der vollst√§ndige Quellcode zum nachprogrammieren:</p>
<pre class="{python}"><code>pos_x = 275
pos_y = 100
radius_x = 50  # Bildbreite/2
radius_y = 85  # Bildh√∂he/2
STEP = 5       # Geschwindigkeit

def setup():
    global horngirl
    size(640, 480)
    horngirl = loadImage(&quot;horngirl.png&quot;)

def draw():
    global pos_x, pos_y
    background(0, 80, 125)
    image(horngirl, pos_x, pos_y)
    if keyPressed and key == CODED:
        if keyCode == LEFT:
            pos_x -= STEP
        elif keyCode == RIGHT:
            pos_x += STEP
        elif keyCode == UP:
            pos_y -= STEP
        elif keyCode == DOWN:
            pos_y += STEP
        if pos_x &gt; width + radius_x:
            pos_x = -radius_x
        elif pos_x &lt; -2*radius_x:
            pos_x = width + radius_x
        if pos_y &lt; -2*radius_y:
            pos_y = height
        elif pos_y &gt; height:
            pos_y = -radius_y</code></pre>
<p><em>Kitty</em> alias <em>¬ªHorn Girl¬´</em> stammt wieder aus dem von <em>Daniel Cook (Danc)</em> in seinem Blog <em><a href="http://www.lostgarden.com/search/label/free%20game%20graphics">Lost Garden</a></em> unter einer <a href="http://www.lostgarden.com/2007/03/lost-garden-license.html">freien Lizenz</a> (<a href="http://creativecommons.org/licenses/by/3.0/us/">CC BY 3.0 US</a>) zu Verf√ºgung gestellten Tileset <a href="http://www.lostgarden.com/2007/05/dancs-miraculously-flexible-game.html">Planet Cute</a>. Aber Ihr k√∂nnt nat√ºrlich auch jedes andere Bild nehmen, das gerade auf Eurer Festplatte herumliegt.</p>
<h2 id="klasse-kitty">Klasse Kitty!</h2>
<p>Nach den <a href="hallohoernchen.md">ersten</a> <a href="movingkitty.md">beiden</a> Teilen meiner kleinen Erkundung von <a href="http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/processingpy.html">Processing.py</a>, dem <a href="http://cognitiones.kantel-chaos-team.de/programmierung/python/python.html">Python</a>-Mode von <a href="http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/processing.html">Processing</a> und vermutlich die einzige, derzeit aktiv gepflegte Alternative zu <a href="http://cognitiones.kantel-chaos-team.de/multimedia/spieleprogrammierung/pygame.html">PyGame</a>, m√∂chte ich erst einmal ein wenig aufr√§umen und daran erinnern, da√ü Akteure eines Computerspiels programmiertechnisch am besten in Klassen aufgehoben sind. Daher habe ich auch <em>Kitty</em> eine eigene Klasse spendiert:</p>
<pre class="{python}"><code># coding=utf-8

class Kitty(object):
    def __init__(self, tempX, tempY):
        self.x = tempX
        self.y = tempY
        self.radiusX = 50  # Bildbreite/2
        self.radiusY = 85  # Bildh√∂he/2
        
    def loadPic(self):
        self.img = loadImage(&quot;horngirl.png&quot;)
    
    def move(self):
        self.x = mouseX - self.radiusX
        self.y = mouseY - self.radiusY
        
    def display(self):
        image(self.img, self.x, self.y)</code></pre>
<p>Klassen kann man in Processing der √úbersicht halber in separaten Dateien unterbringen, die in der IDE jeweils einen eigenen Reiter bekommen (siehe Screenshot).</p>
<figure>
<img src="images/klassekitty.png" alt="Klasse Kitty" /><figcaption>Klasse Kitty</figcaption>
</figure>
<p>Hierbei ist jedoch zu beachten, da√ü im Gegensatz zu Processing und [P5.js][7] (jeweils aus anderen Gr√ºnden) die Klasse nicht automatisch dem Quelltext der Applikation bei der Ausf√ºhrung hinzugef√ºgt wird. Sie ist wenn sie nicht im Quelltext der Applikation steht -- wie in Python √ºblich -- ein Modul und mu√ü gesondert mit</p>
<pre class="{python}"><code>from kitty import Kitty</code></pre>
<p>importiert werden. Und da sie ein reines Python2- (oder genauer Jython-) Modul ist, sollte man auch nicht vergessen <code># coding=utf-8</code> in die erste Zeile der Datei schreiben, denn sonst bekommt man Probleme mit dem <em>√∂</em> im Kommentar (<em>Bildh√∂he</em>). üòú</p>
<p>Den Konventionen folgend, habe ich dem Objekt <em>Kitty</em> neben der eigentlichen Initialisierung drei Funktionen spendiert, n√§mlich <code>loadPic()</code>, <code>move()</code> und <code>display()</code>. Die beiden letzeren h√§tte man auch in einer Funktion zusammenfassen k√∂nnen (beispielsweise <code>update()</code> wie bei PyGame √ºblich), aber da die Philosophie sein sollte, jeder Aktivit√§t eine eigene Funktion zu spendieren, bin ich der Konvention gefolgt<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a>.</p>
<p>Ansonsten ist zu dem Programm nichts weiter zu sagen. Es zeigt einfach eine <em>Kitty</em> die der Maus hinterherrennt. Und dadruch, da√ü fast die gesamte Logik in die Klasse <code>Kitty</code> ausgelagert wurde, ist das Hauptprogramm von erfrischender K√ºrze:</p>
<pre class="{python}"><code>from kitty import Kitty

kitty = Kitty(275, 100)

def setup():
    size(640, 480)
    kitty.loadPic()

def draw():
    background(0, 80, 125)
    kitty.move()
    kitty.display()</code></pre>
<p>So mu√ü es ja auch sein.</p>
<figure>
<img src="images/horngirl.png" alt="Horm Girl" /><figcaption>Horm Girl</figcaption>
</figure>
<p><em>Kitty</em> alias <em>¬ªHorn Girl¬´</em> stammt wieder aus dem von <em>Daniel Cook (Danc)</em> in seinem Blog <em><a href="http://www.lostgarden.com/search/label/free%20game%20graphics">Lost Garden</a></em> unter einer <a href="http://www.lostgarden.com/2007/03/lost-garden-license.html">freien Lizenz</a> (<a href="http://creativecommons.org/licenses/by/3.0/us/">CC BY 3.0 US</a>) zu Verf√ºgung gestellten Tileset <a href="http://www.lostgarden.com/2007/05/dancs-miraculously-flexible-game.html">Planet Cute</a>.</p>
<h2 id="cute-planet-mit-processing.py">¬ªCute Planet¬´ mit Processing.py</h2>
<p>Im <a href="klassekitty,md">letzten Teil</a> meiner kleinen Tutorial-Reihe zu <a href="http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/processingpy.html">Processing.py</a>, dem <a href="http://cognitiones.kantel-chaos-team.de/programmierung/python/python.html">Python</a>-Mode f√ºr <a href="http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/processing.html">Processing</a>, hatte ich ja eine Klasse erstellt. Auf den ersten Blick erschien sie nicht besonders n√ºtzlich, da ich im eigentlichen Sketch ja nur eine Instanz der Klasse erzeugt hatte. So sah das schon ein wenig nach mehr Schreibaufwand ohne gro√üen Nutzen aus. Um die Skeptiker zu √ºberzeugen, werde ich in diesem Tutorial wieder eine Klasse erstellen, von der es im Sketch dann aber vier Instanzen geben wird. Vier Raumschiffe werden im Anschlu√ü √ºber den Bildschirm wuseln.</p>
<figure>
<img src="images/cuteplanet.jpg" alt="Cute Planet" /><figcaption>Cute Planet</figcaption>
</figure>
<p>Also erst einmal die Klasse selber, ich habe sie aus naheliegenden Gr√ºnden <code>Spaceship</code> genannt (auch wenn ein Planet ja im eigentlichen Sinne des Wortes kein Raumschiff ist, aber wie Ihr sp√§ter sehen werdet, in ¬ªSpace Cute¬´ schon üòú ):</p>
<pre class="{python}"><code>class Spaceship():
    
    def __init__(self, pic, posX, posY):
        self.pic = pic
        self.x = posX
        self.y = posY
        self.dx = 0
        
    def loadPic(self):
        self.img = loadImage(self.pic)
    
    def move(self):
        self.x += self.dx
        if self.x &gt;= width + 120:
            self.x = -120
            self.y = random(height-120)
        elif self.x &lt; -120:
            self.x = width + 120
            self.y = random(height-120)
    
    def display(self):
        image(self.img, self.x, self.y)</code></pre>
<p>Der Konstruktor der Klasse verlangt die URL eines Bildes, das das Raumschiff (oder den Planeten) auf dem Monitor darstellt und eine initiale Position, auf der es im Fenster erscheinen soll.</p>
<p>Dann gibt es die Funktion <code>loadPic()</code>, die dieses Bild dann l√§dt. Die Bilder stammen wieder aus dem von <em>Daniel Cook (Danc)</em> in seinem Blog <em><a href="http://www.lostgarden.com/search/label/free%20game%20graphics">Lost Garden</a></em> unter einer <a href="http://www.lostgarden.com/2007/03/lost-garden-license.html">freien Lizenz</a> (<a href="http://creativecommons.org/licenses/by/3.0/us/">CC BY 3.0 US</a>) zu Verf√ºgung gestellten Tileset <em><a href="http://www.lostgarden.com/2007/05/dancs-miraculously-flexible-game.html">Planet Cute</a></em>. Ich habe sie mit dem <a href="http://cognitiones.kantel-chaos-team.de/multimedia/computergraphik/gimp.html">Bildverarbeitungsprogramm meiner Wahl</a> zurechtgeschnitten und auf eine Gr√∂√üe von 120x120 Pixeln heruntergerechnet und sie dann durch einfaches Schieben auf das Editor-Fenster der Processing IDE in den <code>data</code>-Ordner des Sketches transportiert. So findet Processing (und damit auch Processing.py) sie ohne zus√§tzliche Pfadangabe.</p>
<p><img src="images/planet.png" alt="Planet" /> <img src="images/rocketship.png" alt="Rocketship" /> <img src="images/octopussy.png" alt="Octopussy" /> <img src="images/beetleship.png" alt="Beetleship" /></p>
<p>Dann folgt die Funktion <code>move()</code>, die das Herzst√ºck der Klasse darstellt. Hier werden die einzelnen Raumschiffe bewegt und wenn sie die Grenzen des Fenster verlassen haben, von der gegen√ºberliegenden Seite von einer zuf√§llig gew√§hlten Position wieder zur√ºck ins Fenster geschickt. Die Funktion <code>display()</code> k√ºmmert sich dann um die Darstellung des Raumschiffs.</p>
<p>Nun das Hauptprogramm: Dank der Klasse <code>Spaceship</code> ist es kurz und √ºbersichtlich geblieben.</p>
<pre class="{python}"><code>from spaceship import Spaceship

planet = Spaceship(&quot;planet.png&quot;, 500, 350)
rocket = Spaceship(&quot;rocketship.png&quot;, 300, 300)
octopussy = Spaceship(&quot;octopussy.png&quot;, 400, 150)
beetle = Spaceship(&quot;beetleship.png&quot;, 200, 100)

ships = [planet, rocket, octopussy, beetle]

def setup():
    size(640, 480)
    planet.loadPic()
    planet.dx = 1
    rocket.loadPic()
    rocket.dx = 10
    octopussy.loadPic()
    octopussy.dx = -5
    beetle.loadPic()
    beetle.dx = 5

def draw():
    background(0, 80, 125)
    for i in range(len(ships)):
        ships[i].move()
        ships[i].display()</code></pre>
<p>Als erstes wird die Klasse <code>Spaceship</code> importiert und der Variablen <code>spaceship</code> zugewiesen. Dann werden vier <em>Spaceships¬´</em> erzeugt und einer Variablen zugewiesen, die den Konstruktor der Klasse aufruft. Dann wird noch eine Liste erstellt, die alle vier ¬ªRaumschiffe¬´ enth√§lt. Im <code>setup()</code> laden dann alle vier ihre Bilder und bekommen (mit <code>dx</code>) eine Geschwindigkeit verpa√üt.</p>
<p>Das war es dann scho fast: In <code>draw()</code> wird dann nur noch eine Schleife durchlaufen, die f√ºr jedes der ¬ªRaumschiffe¬´ die Funktionen <code>move()</code> und <code>display()</code> aufruft. Wenn Ihr nun den Sketch laufen la√üt, werdet Ihr sehen, da√ü im Weltall rund um den Planeten ¬ªSpace Cute¬´ ein Verkehr wie auf dem Kudamm herrscht. Stellt Euch mal vor, ich h√§tte noch mehr Instanzen der Klasse <code>Spaceship</code> erzeugt. üòá</p>
<h2 id="fluffy-planet">Fluffy Planet</h2>
<p>Nachdem ich nun ein paar Tage mit Orks und Fraktalen herumgespielt habe, f√ºhle ich mich gest√§rkt genug, um mit meinen Processing.py-Experimenten mit den niedlichen Fig√ºrchen aus dem von <em>Daniel Cook (Danc)</em> in seinem Blog <em><a href="http://www.lostgarden.com/search/label/free%20game%20graphics">Lost Garden</a></em> unter einer <a href="http://www.lostgarden.com/2007/03/lost-garden-license.html">freien Lizenz</a> (<a href="http://creativecommons.org/licenses/by/3.0/us/">CC BY 3.0 US</a>) zu Verf√ºgung gestellten Tileset <a href="http://www.lostgarden.com/2007/05/dancs-miraculously-flexible-game.html">Planet Cute</a> fortzufahren.</p>
<figure>
<img src="images/fluffyplanet.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Ich m√∂chte aus dem <a href="http://py.kantel-chaos-team.de/cuteplanet/">bisher erlernten</a> ein kleines Spielchen entwickeln: Die s√º√üe <em>Octopussy</em> ist mit ihrem Raumschiff auf den Weg nach Hause. Dabei wird sie allerdings von den Br√ºdern <em>Rocketboy</em> und dem <em>K√§ferjungen</em> attackiert, die versuchen, sie zu rammen. Zwar hat Octopussys Raumschiff Schutzschilde, die die Karambolage abfangen, aber es sind nur f√ºnf. Die Gegner haben keine Schutzschilde und werden nach jeder Kollision in das Weltall zur√ºckgeworfen, aus dem sie nach einer gewissen Zeit aber wieder auftauchen. Es ist also so eine Art <a href="https://de.wikipedia.org/wiki/Autoscooter">Autoscooter</a> im Weltenraum</p>
<p>Um ihre Schutzschilde zu erneuern, mu√ü Octopussy m√∂glichst oft die kleinen Planeten √ºberfliegen, denn diese laden ihre Schutzschilde bis zur maximalen Anzahl von f√ºnf wieder auf.</p>
<p>Im ersten Schritt habe ich nur eine simple Spielmechanik integriert: Octopussy kann ihr Schiff mit den Pfeiltasten nach unten und oben bewegen, mit jedem Druck auf die Tasten erh√∂ht sich ihre Geschwindigkeit, w√§hrend die gegen√ºberliegende Taste sie dann jeweils wieder um den gleichen Betrag erniedrigt. Nat√ºrlich gibt es eine Maximalgeschwindigkeit und an den Bildr√§ndern oben und unten wird sie rigoros auf Null gesetzt. Die Gegner kommen von links nach rechts in geraden Bahnen und Octopussy mu√ü ihnen ausweichen, aber dennoch versuchen, die kleinen Planeten zu √ºberfliegen.</p>
<p>Um dem l√§stigen Umstand entgegenzuwirken, da√ü die Tastaturbefehle nur greifen, wenn das Graphikfenster von Processing.py den Fokus besitzt, wird das Spiel erst gestartet, wenn zum ersten Mal eine Taste bewegt wurde, bis dahin bleibt es im Startzustand eingefroren.</p>
<h3 id="quellcode-1">Quellcode</h3>
<p>Jetzt aber der Quellcode, zuerst das Modul <code>spaceship.py</code> mit den Klassen <code>Spaceship</code> und der daraus abgeleiteten Klasse <code>Octopussy</code>:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Spaceship():
    
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, pic, posX, posY):
        <span class="ot">self</span>.pic = pic
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY
        <span class="ot">self</span>.dx = <span class="dv">0</span>
        <span class="ot">self</span>.dy = <span class="dv">0</span>
        
    <span class="kw">def</span> loadPic(<span class="ot">self</span>):
        <span class="ot">self</span>.img = loadImage(<span class="ot">self</span>.pic)
    
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.x += <span class="ot">self</span>.dx
        <span class="kw">if</span> <span class="ot">self</span>.x &gt;= width + <span class="dv">120</span>:
            <span class="ot">self</span>.x = -<span class="dv">120</span>
            <span class="ot">self</span>.y = random(height<span class="dv">-120</span>)
        <span class="kw">elif</span> <span class="ot">self</span>.x &lt; -<span class="dv">120</span>:
            <span class="ot">self</span>.x = width + <span class="dv">120</span>
            <span class="ot">self</span>.y = random(height<span class="dv">-120</span>)
    
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.img, <span class="ot">self</span>.x, <span class="ot">self</span>.y)

<span class="kw">class</span> Octopussy(Spaceship):
    
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.y += <span class="ot">self</span>.dy
        <span class="kw">if</span> <span class="ot">self</span>.dy &gt;= <span class="dv">5</span>:
            <span class="ot">self</span>.dy = <span class="dv">5</span>
        <span class="kw">elif</span> <span class="ot">self</span>.dy &lt;= -<span class="dv">5</span>:
            <span class="ot">self</span>.dy = -<span class="dv">5</span>
        <span class="kw">if</span> <span class="ot">self</span>.y &lt; <span class="dv">0</span>:
            <span class="ot">self</span>.y = <span class="dv">0</span>
            <span class="ot">self</span>.dy = <span class="dv">0</span>
        <span class="kw">if</span> <span class="ot">self</span>.y &gt; height - <span class="dv">120</span>:
            <span class="ot">self</span>.y = height - <span class="dv">120</span>
            <span class="ot">self</span>.dy = <span class="dv">0</span></code></pre>
<p>Das d√ºrfte f√ºr Euch, die Ihr diese Serie schon verfolgt, nichts Neues mehr sein. Die ben√∂tigten Sprites findet Ihr auch <a href="http://py.kantel-chaos-team.de/cuteplanet/">hier</a>.</p>
<p>Auch das Hauptprogramm birgt wenig √úberraschungen:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Spaceship</span>
<span class="ch">from</span> spaceship <span class="ch">import</span> Spaceship, Octopussy

octopussy = Octopussy(<span class="st">&quot;octopussy.png&quot;</span>, <span class="dv">800</span>, <span class="dv">150</span>)
planet = Spaceship(<span class="st">&quot;planet.png&quot;</span>, <span class="dv">500</span>, <span class="dv">350</span>)
rocketboy1 = Spaceship(<span class="st">&quot;rocketship.png&quot;</span>, <span class="dv">300</span>, <span class="dv">300</span>)
rocketboy2 = Spaceship(<span class="st">&quot;rocketship.png&quot;</span>, -<span class="dv">300</span>, <span class="dv">250</span>)
beetle = Spaceship(<span class="st">&quot;beetleship.png&quot;</span>, <span class="dv">200</span>, <span class="dv">100</span>)

ships = [planet, rocketboy1, rocketboy2, beetle]
fps = <span class="dv">30</span>

<span class="kw">def</span> setup():
    size(<span class="dv">920</span>, <span class="dv">480</span>)
    frameRate(fps)
    planet.loadPic()
    rocketboy1.loadPic()
    rocketboy2.loadPic()
    beetle.loadPic()
    octopussy.loadPic()
    rocketboy1.dx = rocketboy2.dx = beetle.dx = planet.dx= <span class="dv">0</span>
    octopussy.dx = <span class="dv">0</span>
    octopussy.dy = <span class="dv">0</span>

<span class="kw">def</span> draw():
    background(<span class="dv">0</span>, <span class="dv">80</span>, <span class="dv">125</span>)
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(ships)):
        ships[i].move()
        ships[i].display()
    octopussy.move()
    octopussy.display()

<span class="kw">def</span> keyPressed():
    <span class="kw">if</span> keyPressed and key == CODED:
        planet.dx = <span class="dv">2</span>
        rocketboy1.dx = <span class="dv">8</span>
        rocketboy2.dx = <span class="dv">10</span>
        beetle.dx = <span class="dv">6</span>
        <span class="kw">if</span> keyCode == UP:
            octopussy.dy -= <span class="dv">1</span>
        <span class="kw">elif</span> keyCode == DOWN:
            octopussy.dy += <span class="dv">1</span></code></pre>
<p>Im zweiten Teil dieses Tutorials m√∂chte ich dann eine Kollisionserkennung implementieren und zeigen, wie man die Schutzschilde ab- und wieder aufbaut und die gegnerischen Raumschiffe ins All schleudert. <em>Still digging!</em></p>
<h1 id="zellul√§re-automaten">Zellul√§re Automaten</h1>
<h2 id="das-demokratie-spiel">Das Demokratie-Spiel</h2>
<p>Sp√§testens seit der Wahl von Donald Trump zum Pr√§sidenten der USA fragen sich ja einige, wie es dort mit der Demokratie bestellt sei. Dazu passend ein Spiel, das <em>Peter Donelly</em> vom <em>University College of Swansea</em> in Wales und <em>Domenic Welsh</em> von der <em>Oxford University</em> schon in den 80er Jahren des letzten Jahrhunderts untersucht hatten. Popul√§r wurde es dann durch eine Ver√∂ffentlichung von <em>Alexander K. Dewdney</em> in der <em>Scientific American</em> und in der deutschen Schwesterzeitschrift <em>Spektrum der Wissenschaft</em>. Er nannte das Spiel ¬ªWAEHLER¬´:</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/35034616836/"><img src="images/waehler.jpg" alt="Screenshot" /></a></p>
<p>In diesem Spiel werden die Felder eines rechteckigen Feldes (hier 20 x 20 Felder) zuerst wahllos mit den Symbolen der Republikaner (Elephant) oder der Demokraten (Esel) besetzt. Das widerspiegelt die politische Einstellung der ¬ªEinwohner¬´ dieses ¬ªPlaneten¬´. Bei jedem Spielzug wird nun ein Einwohner in seiner politischen Meinung schwankend und nimmt die Einstellung eines seiner zuf√§llig herausgegriffenen Nachbarn an (falls er nicht sowieso schon dessen Meinung ist).</p>
<p>Als Nachbarschaft gilt hier die Moore-Nachbarschaft, also alle 8 Nachbarfelder. Die Randbedingungen sind periodisch, das hei√üt jeder Spieler auf einem Randfeld hat ¬ªNachbarn¬´ auf der gegen√ºberliegenden Seite, die Spieler in den Eckfeldern sogar auf beiden gegen√ºberliegenden Seiten. Unser Spielfeld nimmt daher die Form eines Reifens oder eines Torus an, wie zum Beispiel auch in der popul√§ren Simulation WATOR.</p>
<p>Nun passiert Folgendes: Aus der anf√§nglich w√ºsten Verteilung bilden sich im Laufe des Spiels feste Inseln einer Meinung heraus. Und im Endeffekt gewinnt eine Partei die alleinige Herrschaft. Das geschieht manchmal sehr schnell, manchmal dauert es l√§nger, weil sich einige Inseln des Widerstands hartn√§ckig halten, aber das Endergebnis ist immer gleich: Der Planet wird entweder komplett von Eseln oder komplett von Elephanten regiert. Ob das der Sinn einer Demokratie ist?</p>
<p>Das Spiel ist verwandt mit dem Selektions-Spiel, das <em>Ruthild Winkler</em> und <em>Manfred Eigen</em> schon 1975 in ihrem Buch ¬ªDas Spiel¬´ vorgestellt hatten. Auch wenn die Regeln leicht abgewandelt sind, das Ergebnis ist stets das gleiche. Es √ºberlebt immer nur eine Partei. Das √§ndert sich √ºbrigens auch nicht, wenn man das Feld mit mehr als zwei Parteien beim Start f√ºllt. Also ist nicht das amerikanische Wahlsystem die alleinige Ursache des √úbels.</p>
<h3 id="der-code">Der Code</h3>
<p>Der Processing.py-Code ist <em>straight forward</em>. Lediglich die Behandlung der Randbedingungen ist allgemeiner gehalten, als unbedingt n√∂tig. Damit sind bei Abwandlungen auch andere Nachbarschaften als die Moore-Umgebung m√∂glich. Er folgt einem <a href="http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/demokratiespiel.html">Processing- (Java-) Code</a>, den ich vor Jahren schon einmal programmiert hatte.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> random <span class="ch">as</span> r

rep = <span class="dv">0</span>
dem = <span class="dv">1</span>
nReps = nDems = <span class="dv">0</span>
nCols  = nRows = <span class="dv">20</span>
w = h = <span class="dv">34</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> grid, reps, dems, nReps, nDems
    size(<span class="dv">680</span>, <span class="dv">680</span>)
    reps = loadImage(<span class="st">&quot;rep.png&quot;</span>)
    dems = loadImage(<span class="st">&quot;dem.png&quot;</span>)
    grid = []
    <span class="kw">for</span> x in <span class="dt">xrange</span>(nRows):
        grid.append([])
        <span class="kw">for</span> y in <span class="dt">xrange</span>(nCols):
            grid[x].append(r.randint(<span class="dv">0</span>, <span class="dv">1</span>))
            <span class="kw">if</span> grid[x][y] == rep:
                nReps += <span class="dv">1</span>
                image(reps, x*w, y*w, w, h)
            <span class="kw">else</span>:
                image(dems, x*w, y*w, w, h)
                nDems += <span class="dv">1</span>
    println(<span class="st">&quot;Start: Demokraten = &quot;</span> + <span class="dt">str</span>(nDems) + <span class="st">&quot;, Republikaner = &quot;</span> + <span class="dt">str</span>(nReps))

<span class="kw">def</span> draw():
    <span class="kw">global</span> reps, dems, nReps, nDems
    actorX = r.randint(<span class="dv">0</span>, nRows - <span class="dv">1</span>)
    actorY = r.randint(<span class="dv">0</span>, nCols - <span class="dv">1</span>)
    selection = r.randint(<span class="dv">0</span>, <span class="dv">7</span>)
    <span class="kw">if</span> selection == <span class="dv">0</span>:
        neighboorX = actorX
        neighboorY = actorY - <span class="dv">1</span>
    <span class="kw">elif</span> selection == <span class="dv">1</span>:
        neighboorX = actorX + <span class="dv">1</span>
        neighboorY = actorY - <span class="dv">1</span>
    <span class="kw">elif</span> selection == <span class="dv">2</span>:
        neighboorX = actorX + <span class="dv">1</span>
        neighboorY = actorY
    <span class="kw">elif</span> selection == <span class="dv">3</span>:
        neighboorX = actorX + <span class="dv">1</span>
        neighboorY = actorY + <span class="dv">1</span>
    <span class="kw">elif</span> selection == <span class="dv">4</span>:
        neighboorX = actorX
        neighboorY = actorY + <span class="dv">1</span>
    <span class="kw">elif</span> selection == <span class="dv">5</span>:
        neighboorX = actorX - <span class="dv">1</span>
        neighboorY = actorY + <span class="dv">1</span>
    <span class="kw">elif</span> selection == <span class="dv">6</span>:
        neighboorX = actorX - <span class="dv">1</span>
        neighboorY = actorY
    <span class="kw">elif</span> selection == <span class="dv">7</span>:
        neighboorX = actorX - <span class="dv">1</span>
        neighboorY = actorY - <span class="dv">1</span>
    <span class="kw">else</span>:
        println(<span class="st">&quot;Irgend etwas ist gewaltig schiefgelaufen!&quot;</span>)
    
    <span class="co"># Pr√ºfung der R√§nder:</span>
    <span class="kw">if</span> neighboorX &lt; <span class="dv">0</span>:
        neighboorX = nRows + neighboorX
    neighboorX = neighboorX % nRows
    <span class="kw">if</span> neighboorY &lt; <span class="dv">0</span>:
        neighboorY = nCols + neighboorY
    neighboorY = neighboorY % nCols
    
    <span class="co"># Neuzeichnen des Spielfelds:</span>
    <span class="kw">if</span> grid[neighboorX][neighboorY] == dem:
        <span class="kw">if</span> grid[actorX][actorY] != dem:
            nDems += <span class="dv">1</span>
            nReps -= <span class="dv">1</span>
        grid[actorX][actorY] = dem
        image(dems, actorX*w, actorY*w, w, h)
    <span class="kw">else</span>:
        <span class="kw">if</span> grid[actorX][actorY] != rep:
            nReps += <span class="dv">1</span>
            nDems -= <span class="dv">1</span>
        grid[actorX][actorY] = rep
        image(reps, actorX*w, actorY*w, w, h)
    println(<span class="st">&quot;Runde &quot;</span> + <span class="dt">str</span>(frameCount) + <span class="st">&quot;: Demokraten = &quot;</span> + <span class="dt">str</span>(nDems) + <span class="st">&quot;, Republikaner = &quot;</span> + <span class="dt">str</span>(nReps))
    
    <span class="kw">if</span> nDems == <span class="dv">0</span>:
        println(<span class="st">&quot;Die Republikaner haben nach &quot;</span> + <span class="dt">str</span>(frameCount) + <span class="st">u&quot; Runden die Macht √ºbernommen!&quot;</span>)
        noLoop()
    <span class="kw">if</span> nReps == <span class="dv">0</span>:
        println(<span class="st">&quot;Die Demokraten haben nach &quot;</span> + <span class="dt">str</span>(frameCount) + <span class="st">u&quot; Runden die Macht √ºbernommen!&quot;</span>)
        noLoop()</code></pre>
<p>Wer das Spiel selber nachprogrammieren m√∂chte, hier gibt es auch noch die beiden Icons f√ºr die Republikaner (Elephant) und Demokraten (Esel):</p>
<p><img src="images/rep.png" alt="Elefant" /> <img src="images/dem.png" alt="Esel" /></p>
<h3 id="caveat-1">Caveat</h3>
<p>Ungeduldige sollten ert einmal mit einem 10x10-Gitter beginnen (<code>size(340, 340)</code>). Dann hat man in der Regel sp√§testens nach 20.000 Runden ein Ergebnis. Oder es kann sehr schnell gehen: Ich hatte auf diesem kleinen Gitter auch schon nach unter 2.000 Runden die absolute Herrschaft einer Partei erreicht. Auf einem 20x20-Gitter wie hier kann es durchaus 200.000 Runden und mehr dauern, bis die Diktatur kommt. Aber auf so einem gro√üen Spielfeld erkennt man nat√ºrlich die stabilen ¬ªInseln gleicher Meinung¬´ sehr viel besser.</p>
<p>Es gibt sicher einen Schwellwert, der -- wenn unterschritten -- kein Zur√ºck zur Macht mehr erlaubt. Aber er ist sehr klein: Ich habe es schon erlebt, da√ü sich Populationen, die unter die 10-Prozent-Marke gerutscht waren, sich wieder berappelten und im Endeffekt die Macht ergriffen.</p>
<p>Das ist das erste aus einer Reihe von (geplanten) Processing.py-Programmen, die sich mit Simulationen auf einem Gitter (aka ¬ªzellul√§re Automaten¬´) besch√§ftigen.</p>
<h3 id="literatur-5">Literatur</h3>
<ul>
<li><p>A.K. Dewdney: <em>Wie man œÄ erschie√üt. F√ºnf leichte St√ºcke f√ºr WHILE-Schleifen und Zufallsgenerator, oder: lebensechte Simulationen von Zombies, W√§hlern und Warteschlangen</em>, in: Immo Diener (Hg.): <em><a href="https://www.amazon.de/gp/product/3922508502/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=70d2a1ad2291abd09c8579f1b3652042">Computer-Kurzweil</a></em>, Heidelberg (Spektrum der Wissenschaft, Reihe: Verst√§ndliche Forschung) 1988</p></li>
<li><p>Manfred Eigen, Ruthild Winkler: <em><a href="https://www.amazon.de/gp/product/3492204104/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=d8a0345a29710b35b7e75ebe8565574d">Das Spiel. Naturgesetze steuern den Zufall</a></em>, M√ºnchen (Piper), 1975 (unver√§nderte Taschenbuchausgabe 1985)</p></li>
</ul>
<h2 id="fr√∂sche-und-schildkr√∂ten-oder-wie-entsteht-segregation">Fr√∂sche und Schildkr√∂ten oder: Wie entsteht Segregation?</h2>
<p><a href="https://de.wikipedia.org/wiki/Mitchel_Resnick">Mitchel Resnick</a> erz√§hlt uns eine nette Geschichte: In einem Teich lebten Fr√∂sche und Schildkr√∂ten in trauter Eintracht zusammen. Jeder Frosch lebt auf einer Seerose und hat auf den acht benachbarten anliegenden Seerosen je vier Fr√∂sche und je vier Schildkr√∂ten als Nachbarn. (Man erkennt leicht, da√ü es sich um quadratische Seerosen mit einer <a href="http://cognitiones.kantel-chaos-team.de/programmierung/softcomputing/moorenb.html">Moore-Nachbarschaft</a> handelt.) Doch eines Tages kommt ein b√∂ser Sturm auf und wirbelt alles durcheinander und auch etliche Fr√∂sche und Schildkr√∂ten kommen (zu gleichen Teilen) dabei um. Als sich der Sturm gelegt hat, versuchen die Tiere sich wieder zu organisieren und es sich auf den Seerosen gem√ºtlich zu machen. Sie sind jedoch nur gl√ºcklich, wenn sie mindestens drei Nachbarn haben, die der gleichen Spezies angeh√∂ren, ansonsten versuchen sie, eine andere, freie Seerose zu besiedeln. Und was passiert dabei? Es entstehen Kolonien, die nur von Schildkr√∂ten und andere Kolonien, die nur von Fr√∂schen bev√∂lkert werden. Eine vorbeifliegende Eule wundert sich und fragt einen Frosch, ob sie sich denn nicht mehr lieb haben w√ºrden. ¬ªDoch, wir haben uns lieb wie eh und je. Nur ‚Ä¶ es passiert einfach, da√ü wir zusammenziehen, unter der einzigen Voraussetzung, da√ü wir mindestens drei Nachbarn unserer Spezies haben wollen. Und den Schildkr√∂ten geht es genauso.¬´</p>
<h3 id="schauen-wir-uns-das-doch-einfach-einmal-an">Schauen wir uns das doch einfach einmal an:</h3>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/34316764284/"><img src="images/segregation-start.jpg" alt="Segregationsspiel Startzustand" /></a></p>
<p><em>Segregationsspiel (Startzustand)</em></p>
<p>Resnick hat das nat√ºrlich in <a href="http://cognitiones.kantel-chaos-team.de/programmierung/starlogo.html">StarLogo</a> programmiert, ich habe ein leicht abgewandeltes Processing.py-Programm geschrieben, mit dem man das Verhalten untersuchen kann. Beim Start verteilen wir zuf√§llig die Schildkr√∂ten und Fr√∂sche zu gleichen Teilen auf einem 40x40-Raster, wobei etwa 30 Prozent leer bleiben, damit sich die Viecher auch bewegen k√∂nnen. In jedem Durchlauf wird zuf√§llig ein Bewohner ausgew√§hlt und er wird gefragt, ob er gl√ºcklich sei. Gl√ºcklich ist er nur, wenn er wenigstens drei Nachbarn hat, die der gleichen Spezies angeh√∂ren. Ist er gl√ºcklich, bleibt er da sitzen wo er ist. Ist er ungl√ºcklich, sucht er zuf√§llig in der Nachbarschaft in seiner Sprungdistanz (ja, in meiner Geschichte k√∂nnen auch Schildkr√∂ten springen) eine Seerose aus. Ist diese Seerose frei, springt er dahin, hoffend, dort gl√ºcklich zu werden. Ist das Feld nicht frei, bleibt er hocken und hofft auf eine neue Chance, wieder ausgew√ºrfelt zu werden.</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/34316764074/"><img src="images/segregation-end.jpg" alt="Segregationsspiel Endzustand" /></a></p>
<p><em>Segregationsspiel (nachdem es ungef√§hr eine halbe Stunde gelaufen ist)</em></p>
<p>L√§√üt man diese Simulation nun laufen, stellt man fest, da√ü sich tats√§chlich Cluster gleicher Spezies bilden. Die kleinste stabile Einheit ist ein Quadrat mit der Kantenl√§nge zwei ‚Äì hier hat jeder mindestens drei Nachbarn. Au√üerdem ist eine Flucht von den R√§ndern weg zu beobachten. Hier habe ich einfach angenommen, da√ü das Wasser so flach ist, da√ü dort keine Seerosen gedeihen ‚Äì die R√§nder werden also nicht periodisch fortgesetzt. Und so hat man an den R√§ndern nat√ºrlich weniger Nachbarn und die Chance, gl√ºcklich zu sein, ist geringer.</p>
<p>Au√üerdem kann es vorkommen, da√ü einzelne Tiere regelrecht von der benachbarten Spezies eingekesselt werden und sie nicht mehr fliehen k√∂nnen. Die Armen sind zu einem ewigen Ungl√ºcklichsein verdammt. Hier hilft nur, die maximale Sprungdistanz zu erh√∂hen.</p>
<p>√úberhaupt: Obige Screenshots stammen von einem Sketch mit einer Sprungdistanz von zwei, nachdem der Sektch etwa eine halbe Stunde gelaufen war. Es passiert nicht mehr viel. Die meisten zuf√§llig ausgew√§hlten in einer Runde sind gl√ºcklich und verharren auf ihren Platz. Nur noch wenige Exemplare einer Gattung irren umher und suchen Anschlu√ü. Andere sind enteder vom Rand des Teiches oder von den Spezies der anderen Art eingekesselt und zu ewigem ungl√ºcklich sein verdammt.</p>
<p>Erh√∂ht man aber den Wert der Sprungdistanz (zum Beispiel auf f√ºnf), dann geht nicht nur die Clusterbildung schneller vonstatten, sondern auch die Zahl der eingekesselten Tiere geht massiv zur√ºck.</p>
<p>Was uns dieses einfache Programm √ºber die tats√§chliche <a href="https://de.wikipedia.org/wiki/Segregation_(Soziologie)">Segregation</a> erz√§hlt, √ºberlasse ich aber der Phantasie meiner Leserinnen und Leser.</p>
<h3 id="der-quellcode-9">Der Quellcode</h3>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> random <span class="ch">as</span> r

empty = <span class="dv">0</span>
frog = <span class="dv">1</span>
turtle = <span class="dv">2</span>

nRows = <span class="dv">40</span>
nCols = <span class="dv">40</span>
w = h = <span class="dv">16</span>

jumpsize = <span class="dv">2</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> grid, frogs, turts
    size(<span class="dv">640</span>, <span class="dv">640</span>)
    frogs = loadImage(<span class="st">&quot;frog.png&quot;</span>)
    turts = loadImage(<span class="st">&quot;turtle.png&quot;</span>)
    grid = []
    <span class="kw">for</span> x in <span class="dt">xrange</span>(nRows):
        grid.append([])
        <span class="kw">for</span> y in <span class="dt">xrange</span>(nCols):
            grid[x].append(r.randint(<span class="dv">0</span>, <span class="dv">2</span>))
    <span class="co"># F√ºr den Screenshot des Anfangszustandes</span>
    <span class="co"># noLoop()</span>
            

<span class="kw">def</span> draw():
    <span class="kw">global</span> grid, frogs, turts
    noStroke()
    background(<span class="dv">0</span>, <span class="dv">80</span>, <span class="dv">125</span>)
    
    <span class="kw">for</span> x in <span class="dt">xrange</span>(nRows):
        <span class="kw">for</span> y in <span class="dt">xrange</span>(nCols):
            <span class="kw">if</span> grid[x][y] == empty:
                fill(<span class="dv">0</span>, <span class="dv">80</span>, <span class="dv">125</span>)
                rect(x*w, y*h, w, h)
            <span class="kw">elif</span> grid[x][y] == frog:
                image(frogs, x*w, y*h, w, h)
            <span class="kw">elif</span> grid[x][y] == turtle:
                image(turts, x*w, y*h, w, h)
            <span class="kw">else</span>:
                println(<span class="st">&quot;Etwas ist falsch im Staate Lilypond!&quot;</span>)
                
    actorX = r.randint(<span class="dv">0</span>, nRows<span class="dv">-1</span>)
    actorY = r.randint(<span class="dv">0</span>, nCols<span class="dv">-1</span>)
    <span class="co"># Lebt hier jemand?</span>
    <span class="kw">if</span> grid[actorX][actorY] &gt; <span class="dv">0</span>:
        <span class="co"># Und ist er gl√ºcklich?</span>
        happy = isHappy(grid[actorX][actorY], actorX, actorY)
        <span class="co"># Wenn nicht, dann m√∂glichst weg von hier</span>
        <span class="kw">if</span> not(happy):
            newX = r.randint(-jumpsize, jumpsize)
            newY = r.randint(-jumpsize, jumpsize)
            newX += actorX
            newY += actorY
            <span class="co"># Liegt mein Ziel noch im Teich?</span>
            <span class="kw">if</span> ((newX &gt;= <span class="dv">0</span>) and (newX &lt; nRows) and (newY &gt;= <span class="dv">0</span>) and (newY &lt; nCols)):
                <span class="kw">if</span> grid[newX][newY] == empty:
                    grid[newX][newY] = grid[actorX][actorY]
                    grid[actorX][actorY] = empty

<span class="kw">def</span> isHappy(animal, x, y):
    happy = <span class="dv">0</span>
    <span class="kw">if</span> (y<span class="dv">-1</span> &gt; <span class="dv">0</span>) and (grid[x][y<span class="dv">-1</span>] == animal):
        happy += <span class="dv">1</span>
    <span class="kw">if</span> (x<span class="dv">+1</span> &lt; nRows) and (y<span class="dv">-1</span> &gt; <span class="dv">0</span>) and (grid[x<span class="dv">+1</span>][y<span class="dv">-1</span>] == animal):
        happy += <span class="dv">1</span>
    <span class="kw">if</span> (x<span class="dv">+1</span> &lt; nRows) and (grid[x<span class="dv">+1</span>][y] == animal):
        happy += <span class="dv">1</span>
    <span class="kw">if</span> (x<span class="dv">+1</span> &lt; nRows) and (y<span class="dv">+1</span> &lt; nCols) and (grid[x<span class="dv">+1</span>][y<span class="dv">+1</span>] == animal):
        happy += <span class="dv">1</span>
    <span class="kw">if</span> (y<span class="dv">+1</span> &lt; nCols) and (grid[x][y<span class="dv">+1</span>] == animal):
        happy += <span class="dv">1</span>
    <span class="kw">if</span> (x<span class="dv">-1</span> &gt; <span class="dv">0</span>) and (y<span class="dv">+1</span> &lt; nCols) and (grid[x<span class="dv">-1</span>][y<span class="dv">+1</span>] == animal):
        happy += <span class="dv">1</span>
    <span class="kw">if</span> (y<span class="dv">+1</span> &lt; nCols) and (grid[x][y<span class="dv">+1</span>] == animal):
        happy += <span class="dv">1</span>
    <span class="kw">if</span> (x<span class="dv">-1</span> &gt; <span class="dv">0</span>) and (grid[x<span class="dv">-1</span>][y] == animal):
        happy += <span class="dv">1</span>
    <span class="kw">if</span> happy &gt;= <span class="dv">3</span>:
        <span class="kw">return</span> <span class="ot">True</span>
    <span class="kw">else</span>:
        <span class="kw">return</span> <span class="ot">False</span></code></pre>
<p>Die Bilder von Frosch und Schildkr√∂te habe ich den <a href="https://github.com/twitter/twemoji">Twitter-Emojis</a> entnommen und hier sind sie noch einmal, damit Ihr das Spiel nachprogrammieren k√∂nnt:</p>
<p><img src="images/turtle.png" /> <img src="images/frog.png" /></p>
<p>In Processing (Java) hatte ich vor Jahren diese Simulation auch schon einmal <a href="http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/froescheundschildkroeten.html">programmiert</a>.</p>
<h3 id="literatur-6">Literatur</h3>
<ul>
<li>Mitchel Resnick: <em><a href="http://www.amazon.de/gp/product/0262680939/ref=as_li_ss_tl?ie=UTF8&amp;camp=1638&amp;creative=19454&amp;creativeASIN=0262680939&amp;linkCode=as2&amp;tag=derschockwell-21">Turtles, Termites, and Traffic Jams: Explorations in Massively Parallel Microworlds</a></em>, Cambridge, MA (MIT Press) 1997, p. 81 - 88</li>
</ul>
<h2 id="der-waldbrand-simulator">Der Waldbrand-Simulator</h2>
<p>Bei dem <a href="waehler.md">Demokratie-Spiel</a> und bei den <a href="segregation.md">Experimenten mit den Fr√∂schen und Schildkr√∂ten</a> √§nderte sich pro Durchlauf jeweils nur das Verhalten einer Zelle in Ab√§nggkeit von ihren direkten Nachbarn und war f√ºr den weiteren Verlauf der Simulation verantwortlich. Bei den meisten Simulationen mit zellul√§ren Automaten jedoch wird der neue Wert <em>aller</em> Zellen in Abh√§ngigkeit von den Nachbarn betrachtet und neu berechnet. Daf√ºr mu√ü man dann zwei Arrays anlegen, eines, das die aktuellen und eines das die zuk√ºnftigen Werte beinhaltet. Ich m√∂chte das mal am Beispiel einer beliebten Simulation zeigen, der Simulation eines Waldbrandes mit einem zellul√§ren Automaten.</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/36833659066"><img src="images/fire01.jpg" alt="Screenshot" /></a></p>
<p>Die Regeln dieser Simulation folgen der Beschreibung, die <em>Daniel Scholz</em> in seinem Buch ¬ªPixelspiele¬´<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a> gegeben hat:</p>
<h3 id="kein-spiel-ohne-regeln">Kein Spiel ohne Regeln</h3>
<p>F√ºr alle Zellen <em>x<sub>ij</sub></em> gelten folgende Regeln:</p>
<ol type="1">
<li>Befindet sich <em>x<sub>ij</sub></em> im Zustand leer <em>(empty)</em>, dann w√§chst auf <em>x<sub>ij</sub></em> mit einer Wahrscheinlichkeit <code>a</code> ein Baum, so da√ü der Zustand von <em>x<sub>ij</sub></em> im n√§chsten Schritt <em>tree</em> ist.</li>
<li>Befindet sich <em>x<sub>ij</sub></em> im Zustand Baum <em>(tree)</em>, und mindestens eine Zelle in der Nachbarschaft ist im Zustand Feuer <em>(burning)</em>, dann brennt auch <em>x<sub>ij</sub></em>, so da√ü der Zustand von <em>x<sub>ij</sub></em> im n√§chsten Schritt auch <em>burning</em> ist.</li>
<li>Automatischer Ablauf: Falls <em>x<sub>ij</sub></em> ein Baum ist und keiner seiner Nachbarn brennt, dann wird <em>x<sub>ij</sub></em> mit einer Wahrscheinlichkeit von <code>g</code> von einem Blitz getroffen, so da√ü <em>x<sub>ij</sub></em> im n√§chsten Schritt ebenfalls <em>burning</em> ist.</li>
<li>Interaktive Version: Wird die Zelle <em>x<sub>ij</sub></em> mit dem Mauszeiger angeklickt, dann wird <em>x<sub>ij</sub></em> von einem Blitz getroffen und der Zustand von <em>x<sub>ij</sub></em> ist im n√§chsten Schritt <em>burning</em>.</li>
<li>Befindet sich die Zelle <em>x<sub>ij</sub></em> im Zustand <em>burning</em>, dann erlischt das Feuer und der Zustand von <em>x<sub>ij</sub></em> ist im n√§chsten Schritt <em>empty</em>.</li>
<li>Trifft keine der obigen Regeln zu, dann ver√§ndert sich der Zustand der Zelle <em>x<sub>ij</sub></em> im n√§chsten Schritt nicht.</li>
</ol>
<p>Als Nachbarschaft wird die <a href="http://cognitiones.kantel-chaos-team.de/programmierung/softcomputing/neumannnb.html">Von-Neumann-Nachbarschaft</a> angenommen, Nachbarn sind also nur die direkten Zellen oben und unten sowie rechts und links, das hei√üt, jede Zelle hat genau vier Nachbarn.</p>
<p>Als Randbedingung wurde ein geschlossener Rand gew√§hlt, da√ü hei√üt die Zellen am Rande des Feldes werden in der Simulation gar nicht ber√ºcksichtigt, sie bleiben auf ewig, wie sie sind. Daher habe ich bei der Initialisierung des Feldes mit</p>
<pre class="sourceCode python"><code class="sourceCode python">            <span class="kw">if</span> (x &gt; <span class="dv">0</span>) and (y &gt; <span class="dv">0</span>) and (x &lt; nRows<span class="dv">-1</span>) and (y &lt; nCols<span class="dv">-1</span>) and randint(<span class="dv">0</span>, <span class="dv">10000</span>) &lt;= <span class="dv">2000</span>:
                grid[x].append(tree)
            <span class="kw">else</span>:
                grid[x].append(empty)</code></pre>
<p>daf√ºr gesorgt, da√ü die Randfelder immer leer sind. Das hat auf den Simulationsverlauf keinen Einflu√ü, aber es st√∂rte mich besonders bei der Darstellung mit den Emojis, da√ü auf den R√§ndern anfangs immer ein paar B√§ume dumm herum standen, wie noch im obigen Screenshot dokumentiert, der w√§hrend einer fr√ºhen Phase der Realisierung dieser Simulation enstand.</p>
<h3 id="die-realisierung">Die Realisierung</h3>
<p>Oben habe ich es schon angesprochen, f√ºr die erste Version der Waldbrandsimulation habe ich wieder <a href="https://github.com/twitter/twemoji">Twitters Twemojis</a> gepl√ºndert und hier sind die Bildchen vom Baum und vom Feuer, damit Ihr die Simulation nachprogrammieren k√∂nnt:</p>
<p><img src="images/tree2.png" alt="tree" /> <img src="images/fire.png" alt="fire" /></p>
<p>Wenn Ihr die Bilder herunterladet, beachtet bitte, da√ü ich, weil es schon ein anderes Baumbildchen gab, dieses hier <code>tree2.png</code> nennen mu√üte. Im Sketch hei√üt es aber <code>tree.png</code>, Ihr m√º√üt also entweder die Bezeichnung im Sketch √§ndern (nicht gut) oder einfach den Namen des Bildchens √§ndern (besser). Es sind winzige, 16x16 Pixel gro√üe Bildchen und das Spielfeld habe ich diesen Ausma√üen angepa√üt:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    <span class="kw">global</span> trees, fire
    size(<span class="dv">640</span>, <span class="dv">640</span>)
    background(<span class="dv">210</span>, <span class="dv">180</span>, <span class="dv">140</span>)
    trees = loadImage(<span class="st">&quot;tree.png&quot;</span>)
    fire  = loadImage(<span class="st">&quot;fire.png&quot;</span>)
    <span class="kw">for</span> x in <span class="dt">range</span>(nRows):
        grid.append([])
        newgrid.append([])
        <span class="kw">for</span> y in <span class="dt">range</span>(nCols):
            <span class="co"># Randbedingungen</span>
            <span class="kw">if</span> (x &gt; <span class="dv">0</span>) and (y &gt; <span class="dv">0</span>) and (x &lt; nRows<span class="dv">-1</span>) and (y &lt; nCols<span class="dv">-1</span>) and randint(<span class="dv">0</span>, <span class="dv">10000</span>) &lt;= <span class="dv">2000</span>:
                grid[x].append(tree)
            <span class="kw">else</span>:
                grid[x].append(empty)
    newgrid[:] = grid[:]
    frameRate(<span class="dv">2</span>)</code></pre>
<p>Eine <code>frameRate()</code> von 2 ist durchaus ausreichend, sonst l√§uft die Simulation so schnell, da√ü Ihr gar nichts nachvollziehen k√∂nnt.</p>
<p>Aber ganz zu Beginn habe ich <code>randint</code> f√ºr die Zufallszahlen importiert, ein paar Konstanten gesetzt und die beiden Arrays initialisiert:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> random <span class="ch">import</span> randint

empty = <span class="dv">0</span>
tree = <span class="dv">1</span>
burning = <span class="dv">20</span>

a = <span class="dv">40</span>
g = <span class="dv">1</span>

nRows = <span class="dv">40</span>
nCols = <span class="dv">40</span>
w = h = <span class="dv">16</span>

grid = []
newgrid = []</code></pre>
<p>Die <code>draw()</code>-Funktion ist in allen Simulationen gleich,</p>
<pre class="sourceCode python"><code class="sourceCode python">draw():
    <span class="kw">global</span> grid, newgrid
    <span class="kw">global</span> trees, fire
    noStroke()
    background(<span class="dv">210</span>, <span class="dv">180</span>, <span class="dv">140</span>)
    
    <span class="kw">for</span> i in <span class="dt">range</span>(nRows):
        <span class="kw">for</span> j in <span class="dt">range</span>(nCols):
            <span class="kw">if</span> grid[i][j] == empty:
                fill(<span class="dv">210</span>, <span class="dv">180</span>, <span class="dv">140</span>)
                rect(i*w, j*h, w, h)
            <span class="kw">elif</span> grid[i][j] == tree:
                image(trees, i*w, j*h, w, h)
            <span class="kw">elif</span> grid[i][j] == burning:
                image(fire, i*w, j*h, w, h)
    calcNext()</code></pre>
<p>der Unterschied f√ºr den per Zufall generierten Blitzeinschlag, respektive den durch Nutzereingabe verursachten Blitz, liegt in der Funktion <code>calcNext()</code>. Hier erst einmal die nicht interaktive Version:</p>
<pre class="sourceCode python"><code class="sourceCode python"> calcNext():
     <span class="kw">global</span> grid, newgrid
     newgrid[:] = grid[:]
     <span class="co"># Next Generation</span>
     <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">1</span>, nRows<span class="dv">-1</span>):
         <span class="kw">for</span> j in <span class="dt">range</span>(<span class="dv">1</span>, nCols<span class="dv">-1</span>):
             <span class="kw">if</span> grid[i][j] == burning:
                 newgrid[i][j] = empty
                 <span class="co"># Brennt ein Nachbar?</span>
                 <span class="kw">if</span> grid[i<span class="dv">-1</span>][j] == tree:
                     newgrid[i<span class="dv">-1</span>][j] = burning
                 <span class="kw">if</span> grid[i][j<span class="dv">-1</span>] == tree:
                     newgrid[i][j<span class="dv">-1</span>] = burning
                 <span class="kw">if</span> grid[i][j<span class="dv">+1</span>] == tree:
                     newgrid[i][j<span class="dv">+1</span>] = burning
                 <span class="kw">if</span> grid[i<span class="dv">+1</span>][j] == tree:
                     newgrid[i<span class="dv">+1</span>][j] = burning
             <span class="kw">elif</span> grid[i][j] == empty:
                 <span class="kw">if</span> randint(<span class="dv">0</span>, <span class="dv">10000</span>) &lt; a:
                     newgrid[i][j] = tree
             <span class="kw">if</span> grid[i][j] == tree:
             <span class="co"># Schl√§gt ein Blitz ein?</span>
                 <span class="kw">if</span> (random(<span class="dv">10000</span>) &lt; g):
                     newgrid[i][j] = burning
     grid[:] = newgrid[:]</code></pre>
<p>Mit <code>for i in range(1, nRows-1)</code> und <code>for j in range(1, nCols-1)</code> habe ich die Randfelder von der Abfrage ausgeschlossen und somit die Randbedingung ¬ªgeschlossener Rand¬´ erf√ºllt.</p>
<p>In den vorletzten zwei Zeilen wird die Wahrscheinlichkeit abgefragt, ob ein Blitz einschl√§gt und wenn diese (geringe) Wahrscheinlichkeit zutrifft, dann wird das Feld <em>x<sub>ij</sub></em> f√ºr den n√§chsten Zustand auf brennend <em>(burning)</em> gesetzt. In der interaktiven Variante entfallen diese beiden Zeilen, daf√ºr kommt noch die Funktion <code>mousePressed()</code> hinzu,</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> mousePressed():
    newgrid[mouseX/<span class="dv">16</span>][mouseY/<span class="dv">16</span>] = burning</code></pre>
<p>die einfach f√ºr die Zelle, in der die Maus klickt, den neuen Zustand auf <em>burning</em> setzt.</p>
<h3 id="der-quellcode-1-1">Der Quellcode (1)</h3>
<p>Bevor ich weitermache, erst einmal den Quellcode des vollst√§ndigen Programmes in der interaktiven Version:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> random <span class="ch">import</span> randint

empty = <span class="dv">0</span>
tree = <span class="dv">1</span>
burning = <span class="dv">20</span>

a = <span class="dv">40</span>
g = <span class="dv">1</span>

nRows = <span class="dv">40</span>
nCols = <span class="dv">40</span>
w = h = <span class="dv">16</span>

grid = []
newgrid = []

<span class="kw">def</span> setup():
    <span class="kw">global</span> trees, fire
    size(<span class="dv">640</span>, <span class="dv">640</span>)
    background(<span class="dv">210</span>, <span class="dv">180</span>, <span class="dv">140</span>)
    trees = loadImage(<span class="st">&quot;tree.png&quot;</span>)
    fire  = loadImage(<span class="st">&quot;fire.png&quot;</span>)
    <span class="kw">for</span> x in <span class="dt">range</span>(nRows):
        grid.append([])
        newgrid.append([])
        <span class="kw">for</span> y in <span class="dt">range</span>(nCols):
            <span class="co"># Randbedingungen</span>
            <span class="kw">if</span> (x &gt; <span class="dv">0</span>) and (y &gt; <span class="dv">0</span>) and (x &lt; nRows<span class="dv">-1</span>) and (y &lt; nCols<span class="dv">-1</span>) and randint(<span class="dv">0</span>, <span class="dv">10000</span>) &lt;= <span class="dv">2000</span>:
                grid[x].append(tree)
            <span class="kw">else</span>:
                grid[x].append(empty)
    newgrid[:] = grid[:]
    frameRate(<span class="dv">2</span>)
    <span class="co"># noLoop()</span>
    
<span class="kw">def</span> draw():
    <span class="kw">global</span> grid, newgrid
    <span class="kw">global</span> trees, fire
    noStroke()
    background(<span class="dv">210</span>, <span class="dv">180</span>, <span class="dv">140</span>)
    
    <span class="kw">for</span> i in <span class="dt">range</span>(nRows):
        <span class="kw">for</span> j in <span class="dt">range</span>(nCols):
            <span class="kw">if</span> grid[i][j] == empty:
                fill(<span class="dv">210</span>, <span class="dv">180</span>, <span class="dv">140</span>)
                rect(i*w, j*h, w, h)
            <span class="kw">elif</span> grid[i][j] == tree:
                image(trees, i*w, j*h, w, h)
            <span class="kw">elif</span> grid[i][j] == burning:
                image(fire, i*w, j*h, w, h)
    calcNext()
 
<span class="kw">def</span> calcNext():
    <span class="kw">global</span> grid, newgrid
    newgrid[:] = grid[:]
    <span class="co"># Next Generation</span>
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">1</span>, nRows<span class="dv">-1</span>):
        <span class="kw">for</span> j in <span class="dt">range</span>(<span class="dv">1</span>, nCols<span class="dv">-1</span>):
            <span class="kw">if</span> grid[i][j] == burning:
                newgrid[i][j] = empty
                <span class="co"># Brennt ein Nachbar?</span>
                <span class="kw">if</span> grid[i<span class="dv">-1</span>][j] == tree:
                    newgrid[i<span class="dv">-1</span>][j] = burning
                <span class="kw">if</span> grid[i][j<span class="dv">-1</span>] == tree:
                    newgrid[i][j<span class="dv">-1</span>] = burning
                <span class="kw">if</span> grid[i][j<span class="dv">+1</span>] == tree:
                    newgrid[i][j<span class="dv">+1</span>] = burning
                <span class="kw">if</span> grid[i<span class="dv">+1</span>][j] == tree:
                    newgrid[i<span class="dv">+1</span>][j] = burning
            <span class="kw">elif</span> grid[i][j] == empty:
                <span class="kw">if</span> randint(<span class="dv">0</span>, <span class="dv">10000</span>) &lt; a:
                    newgrid[i][j] = tree
    grid[:] = newgrid[:]

<span class="kw">def</span> mousePressed():
    newgrid[mouseX/<span class="dv">16</span>][mouseY/<span class="dv">16</span>] = burning</code></pre>
<p>F√ºr die automatisch ablaufende Fassung m√º√üt Ihr einfach nur die oben erw√§hnten zwei Zeilen vor</p>
<pre class="sourceCode python"><code class="sourceCode python">    grid[:] = newgrid[:]</code></pre>
<p>in die Funktion <code>calcNext()</code> einf√ºgen und die Funktion <code>mousePressed()</code> l√∂schen.</p>
<h3 id="ein-gr√∂√üerer-wald">Ein gr√∂√üerer Wald</h3>
<p>Die obige Simulation l√§uft schon sehr zufriedenstellend ab, aber um Muster zu erkennen, mu√ü man den ¬ªWald¬´ doch weiter vergr√∂√üern. Ich habe in einer neuen Version dieser Simulation das Spielfeld daher auf 280x160 Zellen erweitert. Damit mein Monitor nicht gesprengt wird, sind diese Zellen jetzt nur noch 2x2 Pixel gro√ü, was zu einer Fenstergr√∂√üe von 560x320 f√ºhrt.</p>
<p>Die Zellen werden jetzt nicht mehr durch Emojis dargestellt, sondern durch kleine Rechtecke in verschiedenen Farben. Da ich leicht farbenblind bin, habe ich mir die Farben aus einer Tabelle mit Farbnamen zusammengsucht, ein leeres Feld sollte daher ockerfarben dargestellt werden, ein Feld mit einem Baum dunkelgr√ºn und ein brennendes Feld in einem leuchtenden rot. Diese Angaben sind ohne Gew√§hr, aber Ihr k√∂nnt die Farben ja im Zweifelsfalle selber Euren W√ºnschen anpassen.</p>
<h3 id="beispielsimulation">Beispielsimulation</h3>
<figure>
<img src="images/fire-gen-0050.png" alt="Generation 50" /><figcaption>Generation 50</figcaption>
</figure>
<p><em>Generation 50</em></p>
<figure>
<img src="images/fire-gen-0100.png" alt="Generation 100" /><figcaption>Generation 100</figcaption>
</figure>
<p><em>Generation 100</em></p>
<figure>
<img src="images/fire-gen-0150.png" alt="Generation 150" /><figcaption>Generation 150</figcaption>
</figure>
<p><em>Generation 150</em></p>
<figure>
<img src="images/fire-gen-0200.png" alt="Generation 200" /><figcaption>Generation 200</figcaption>
</figure>
<p><em>Generation 200</em></p>
<figure>
<img src="images/fire-gen-0250.png" alt="Generation 250" /><figcaption>Generation 250</figcaption>
</figure>
<p><em>Generation 250</em></p>
<figure>
<img src="images/fire-gen-0300.png" alt="Generation 300" /><figcaption>Generation 300</figcaption>
</figure>
<p><em>Generation 300</em></p>
<p>Wenn Ihr diese Simulation √ºber einen gewissen Zeitraum laufen la√üt, dann erkennt Ihr, da√ü sich im Laufe der Zeit ein gewisses, wenn auch schwankendes Gleichgewicht zwischen Wald und freier Fl√§che einstellt. Dieses Gleichgewicht soll sich sogar relativ unabh√§ngig von den gew√§hlten Parametern einstellen (das ist allerdings in der Literatur umstritten). In den obigen Schreenshots, die ich mit</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">if</span> (frameCount % <span class="dv">50</span>) == <span class="dv">0</span>:
        <span class="dt">print</span>(frameCount)
        saveFrame(<span class="st">&quot;frames/fire-gen-####.png&quot;</span>)</code></pre>
<p>erstellt habe, k√∂nnt Ihr sehen, wie sich die Simulation nach je 50 Schritten ver√§ndert hat und nach einer ruhigen Anfangsphase des Wachstums scheint der Gleichgewichtszustand tats√§chlich erreicht. Generation 150 und Generation 300 sind sich sehr √§hnlich, dazwischen brennt der Wald erst heftiger (Generation 200) und erlebt dann wieder eine Phase des Wachstums (Generation 250).</p>
<h3 id="der-quellcode-2-1">Der Quellcode (2)</h3>
<p>Probiert es -- auch mit anderen Paramtern f√ºr <code>a</code> und <code>g</code> einfach mal aus. Darum hier der komplette Quellcode dieser Version:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> random <span class="ch">import</span> randint

empty = <span class="dv">0</span>
tree = <span class="dv">1</span>
burning = <span class="dv">20</span>

a = <span class="dv">40</span>
g = <span class="dv">1</span>

nRows = <span class="dv">280</span>
nCols = <span class="dv">160</span>
w = h = <span class="dv">2</span>

grid = []
newgrid = []

<span class="kw">def</span> setup():
    <span class="kw">global</span> trees, fire
    size(<span class="dv">560</span>, <span class="dv">320</span>)
    background(<span class="dv">210</span>, <span class="dv">180</span>, <span class="dv">140</span>)
    <span class="kw">for</span> x in <span class="dt">range</span>(nRows):
        grid.append([])
        newgrid.append([])
        <span class="kw">for</span> y in <span class="dt">range</span>(nCols):
            <span class="co"># Randbedingungen</span>
            <span class="kw">if</span> (x &gt; <span class="dv">0</span>) and (y &gt; <span class="dv">0</span>) and (x &lt; nRows<span class="dv">-1</span>) and (y &lt; nCols<span class="dv">-1</span>) and randint(<span class="dv">0</span>, <span class="dv">10000</span>) &lt;= <span class="dv">2000</span>:
                grid[x].append(tree)
            <span class="kw">else</span>:
                grid[x].append(empty)
    newgrid[:] = grid[:]
    frameRate(<span class="dv">10</span>)
    <span class="co"># noLoop()</span>
    
<span class="kw">def</span> draw():
    <span class="kw">global</span> grid, newgrid
    <span class="kw">global</span> trees, fire
    noStroke()
    background(<span class="dv">210</span>, <span class="dv">180</span>, <span class="dv">140</span>)
    <span class="kw">for</span> i in <span class="dt">range</span>(nRows):
        <span class="kw">for</span> j in <span class="dt">range</span>(nCols):
            <span class="kw">if</span> grid[i][j] == empty:
                fill(<span class="dv">210</span>, <span class="dv">180</span>, <span class="dv">140</span>)
                rect(i*w, j*h, w, h)
            <span class="kw">elif</span> grid[i][j] == tree:
                fill(<span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">0</span>)
                rect(i*w, j*h, w, h)
            <span class="kw">elif</span> grid[i][j] == burning:
                fill(<span class="dv">255</span>, <span class="dv">69</span>, <span class="dv">0</span>)
                rect(i*w, j*h, w, h)
    <span class="kw">if</span> (frameCount % <span class="dv">50</span>) == <span class="dv">0</span>:
        <span class="dt">print</span>(frameCount)
        saveFrame(<span class="st">&quot;frames/fire-gen-####.png&quot;</span>)
    calcNext()
 
<span class="kw">def</span> calcNext():
    <span class="kw">global</span> grid, newgrid
    newgrid[:] = grid[:]
    <span class="co"># Next Generation</span>
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">1</span>, nRows<span class="dv">-1</span>):
        <span class="kw">for</span> j in <span class="dt">range</span>(<span class="dv">1</span>, nCols<span class="dv">-1</span>):
            <span class="kw">if</span> grid[i][j] == burning:
                newgrid[i][j] = empty
                <span class="co"># Brennt ein Nachbar?</span>
                <span class="kw">if</span> grid[i<span class="dv">-1</span>][j] == tree:
                    newgrid[i<span class="dv">-1</span>][j] = burning
                <span class="kw">if</span> grid[i][j<span class="dv">-1</span>] == tree:
                    newgrid[i][j<span class="dv">-1</span>] = burning
                <span class="kw">if</span> grid[i][j<span class="dv">+1</span>] == tree:
                    newgrid[i][j<span class="dv">+1</span>] = burning
                <span class="kw">if</span> grid[i<span class="dv">+1</span>][j] == tree:
                    newgrid[i<span class="dv">+1</span>][j] = burning
            <span class="kw">elif</span> grid[i][j] == empty:
                <span class="kw">if</span> randint(<span class="dv">0</span>, <span class="dv">10000</span>) &lt; a:
                    newgrid[i][j] = tree
            <span class="kw">if</span> grid[i][j] == tree:
            <span class="co"># Schl√§gt ein Blitz ein?</span>
                <span class="kw">if</span> (random(<span class="dv">10000</span>) &lt; <span class="dv">1</span>):
                    newgrid[i][j] = burning
    grid[:] = newgrid[:]</code></pre>
<p>Er unterscheidet sich nicht grundlegend von den vorherigen Versionen, daher solltet Ihr ihn durchaus nachvollziehen k√∂nnen.</p>
<h3 id="caveat-2">Caveat</h3>
<p>Ich glaube nicht wirklich, da√ü diese Simualtion ein realistisches Bild von Waldbr√§nden liefert, dazu fehlen zum Beispiel Parameter f√ºr die Windrichtung, manche B√§ume brennen leichter als andere und vieles mehr. Aber es ist eine nette Spielerei und Ihr seid durchaus aufgefordert, die fehlenden Parameter einzuf√ºgen und damit zu spielen. Der Aufsatz ¬ª<a href="http://ncase.me/simulating/">Simulating the World in Emojis</a>¬´ den <em>Nicky Case</em> im Januar 2016 ver√∂ffentlichte, gibt daf√ºr -- aber auch f√ºr weitere Simualtionen -- nette Anregungen.</p>
<h1 id="d-mit-processing.py">3D mit Processing.py</h1>
<h2 id="kugeln-und-kisten">Kugeln und Kisten</h2>
<p>Processing und damit auch Processing.py besitzt die M√∂glichkeit, sehr einfach 3D-Objekte zu erzeugen, allerdings sind als Primitive nur eine Kugel und eine Kiste (<code>sphere()</code> und <code>box()</code>) vorgesehen. Als Erstes m√∂chte ich zeigen, wie man schnell eine sich drehende Kugel damit zaubert:</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32057051544/"><img src="images/kugel3d.jpg" alt="Screenshot" /></a></p>
<p>Um mit Processing in drei Dimensionen zu arbeiten, mu√ü man das bei der Initialisierung des Fensters dem Programm mitteilen:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    size(<span class="dv">200</span>, <span class="dv">200</span>, P3D)</code></pre>
<p>Eigentlich teilt man Processing auch mit, wenn man in zwei Dimensionen hantieren will, nur ist <code>P2D</code> einfach der Default und kann entfallen.</p>
<p>Dann besitzt Processing eine einfache Methode, die 3D-Landschaft auszuleuchten, n√§mlich <code>lights()</code>. Und √§hnlich wie den Kreisen und Ellipsen ist auch bei einer Kugel per Default, der Ursprung der Koordinaten die Mitte. Daher habe ich mit</p>
<pre class="sourceCode python"><code class="sourceCode python">    translate(width/<span class="dv">2</span>, height/<span class="dv">2</span>, <span class="dv">0</span>)</code></pre>
<p>die x- und y-Achsen des Koordinatensystems in die Mitte des Fensters gelegt. Mit <code>sphereDetail(n)</code> wird die Anzahl der Dreiecke bestimmt, aus denen die Kugel zusammengesetzt werden soll. Je mehr Dreiecke, desto ¬ªrunder¬´ die Kugel, aber auch um so gr√∂√üer die Rechenzeit. Bei diesem einfachen Programm spielt das noch keine Rolle, die Zahl <code>30</code> ist eher dem Umstand geschuldet, da√ü die Kugel vor lauter Dreieicken sonst nicht mehr zu erkennen ist.</p>
<p>Und dann kommt wieder das geniale <code>with</code>-Statement zu Einsatz:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">with</span> pushMatrix():
        rotateX(radians(-<span class="dv">10</span>))
        rotateY(a)
        a += <span class="fl">0.01</span>
        sphere(<span class="dv">80</span>)</code></pre>
<p>Mit <code>rotateX()</code> wird die Kugel ein wenig geneigt und mit <code>rotateY()</code> dreht sie sich um die eigene Achse. Einfacher kann man eine sich bewegende Kugel in 3D eigentlich gar nicht programmieren.</p>
<h3 id="der-quellcode-10">Der Quellcode</h3>
<p>Hier noch einmal der komplette Quellcode des Sketches zum Nachbauen:</p>
<pre class="sourceCode python"><code class="sourceCode python">a = <span class="dv">0</span>

<span class="kw">def</span> setup():
    size(<span class="dv">200</span>, <span class="dv">200</span>, P3D)

<span class="kw">def</span> draw():
    <span class="kw">global</span> a
    background(<span class="dv">160</span>)
    lights()
    translate(width/<span class="dv">2</span>, height/<span class="dv">2</span>, <span class="dv">0</span>)
    sphereDetail(<span class="dv">30</span>)
    <span class="kw">with</span> pushMatrix():
        rotateX(radians(-<span class="dv">10</span>))
        rotateY(a)
        a += <span class="fl">0.01</span>
        sphere(<span class="dv">80</span>)</code></pre>
<h3 id="caveat-3">Caveat</h3>
<p>Jetzt kommt aber das Salz in der Suppe: <code>box()</code> wie auch <code>sphere()</code> lassen sich nicht mit Texturen versehen. Daf√ºr mu√ü man sich mit Vertizes seine eigenen 3D-Objekte bauen.</p>
<h2 id="und-es-geht-doch-kugeln-und-texturen">Und es geht doch: Kugeln und Texturen</h2>
<p>Ich hatte doch <a href="http://py.kantel-chaos-team.de/kugel/">hier behauptet</a>, da√ü man die einfachen 3D-Primitive <code>sphere()</code> und <code>box()</code> nicht mit Texturen versehen kann und man darum dann eigene 3D-Objekte bauen m√ºsse. Nun gibt es jedoch einen einfachen Weg, diese Beschr√§nkung zu umgehen. Denn der Befehl <code>createShape()</code> erzeugt nicht nur ein Objekt, sondern er kann auch Parameter √ºbernehmen. Und so kann man mit</p>
<pre class="sourceCode python"><code class="sourceCode python">earth = loadImage(<span class="st">&quot;bluemarble.jpg&quot;</span>)
noStroke()
globe = createShape(SPHERE, <span class="dv">80</span>)
globe.setTexture(earth)</code></pre>
<p>auf einfachste Weise einen <em>Shape</em> erzeugen, den man mit Texturen versehen kann.</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32877987692/"><img src="images/bluemarble.jpg" alt="Blue Marble" /></a></p>
<p>Hier der vollst√§ndige Sketch, der uns diese Erdkugel erzeugt:</p>
<pre class="sourceCode python"><code class="sourceCode python">a = <span class="dv">0</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> globe
    earth = loadImage(<span class="st">&quot;bluemarble.jpg&quot;</span>)
    size(<span class="dv">200</span>, <span class="dv">200</span>, P3D)
    noStroke()
    globe = createShape(SPHERE, <span class="dv">80</span>)
    globe.setTexture(earth)

<span class="kw">def</span> draw():
    <span class="kw">global</span> a, globe
    background(<span class="dv">160</span>)
    lights()
    translate(width/<span class="dv">2</span>, height/<span class="dv">2</span>, <span class="dv">0</span>)
    sphereDetail(<span class="dv">30</span>)
    <span class="kw">with</span> pushMatrix():
        rotateX(radians(-<span class="dv">25</span>))
        rotateY(a)
        a += <span class="fl">0.01</span>
        shape(globe)</code></pre>
<h3 id="und-noch-eine-textur">Und noch eine Textur</h3>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32901118862/"><img src="images/earth.jpg" alt="Die Erde" /></a></p>
<p>Und hier noch einmal die Erdkugel mit einer anderen Textur, die ich <a href="http://www.inf-schule.de/information/informationsdarstellungxml/darstellunginformation/fallstudie_3dgrafiken/exkurs/farben">hier gefunden</a> habe. Schaut man genau hin, entdeckt man, da√ü die Erde an der Datumsgrenze einen Ri√ü aufweist -- ein Ph√§nomen, da√ü ich hin und wieder schon beobachtet, f√ºr da√ü ich allerdings bis jetzt noch keine Erkl√§rung habe.</p>
<p>Der Quellcode wurde nur geringf√ºgig ge√§ndert, aber der Vollst√§ndigkeit halber hier noch einmal:</p>
<pre class="sourceCode python"><code class="sourceCode python">a = <span class="dv">0</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> globe
    earth = loadImage(<span class="st">&quot;earth.jpg&quot;</span>)
    size(<span class="dv">400</span>, <span class="dv">400</span>, P3D)
    noStroke()
    globe = createShape(SPHERE, <span class="dv">160</span>)
    globe.setTexture(earth)

<span class="kw">def</span> draw():
    <span class="kw">global</span> a, globe
    background(<span class="dv">51</span>)
    lights()
    translate(width*.<span class="dv">5</span>, height*.<span class="dv">5</span>, <span class="dv">0</span>)
    <span class="co"># sphereDetail(120)</span>
    <span class="kw">with</span> pushMatrix():
        rotateX(radians(-<span class="dv">25</span>))
        rotateY(a)
        a += <span class="fl">0.01</span>
        shape(globe)</code></pre>
<h2 id="die-erde-ist-eine-kiste">Die Erde ist eine Kiste</h2>
<p>Nat√ºrlich kann man das, was ich <a href="http://py.kantel-chaos-team.de/kugel02/">hier</a> mit einer Kugel angestellt habe, auch mit einer Kiste (in Processing <code>BOX</code> genannt) anstellen. Der einzige Unterschied ist, da√ü die Textur jeweils komplett auf alle sechs Seiten der Box abgebildet wird.</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/33011293496/"><img src="images/kiste.jpg" alt="Screenshot" /></a></p>
<p>Aber dann hat man den Beweis: Die Erde ist eine Kiste!</p>
<h3 id="quellcode-2">Quellcode</h3>
<pre class="sourceCode python"><code class="sourceCode python">a = <span class="dv">0</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> chest
    earth = loadImage(<span class="st">&quot;bluemarble.jpg&quot;</span>)
    size(<span class="dv">400</span>, <span class="dv">400</span>, P3D)
    noStroke()
    chest = createShape(BOX, <span class="dv">180</span>)
    chest.setTexture(earth)

<span class="kw">def</span> draw():
    <span class="kw">global</span> a, chest
    background(<span class="dv">51</span>)
    lights()
    translate(width*.<span class="dv">5</span>, height*.<span class="dv">5</span>, <span class="dv">0</span>)
    sphereDetail(<span class="dv">30</span>)
    <span class="kw">with</span> pushMatrix():
        rotateZ(radians(frameCount))
        rotateX(radians(frameCount*.<span class="dv">5</span>))
        rotateY(radians(a))
        a += <span class="fl">0.01</span>
        shape(chest)</code></pre>
<h2 id="licht-und-schatten">Licht und Schatten</h2>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32593587580/"><img src="images/lichtundschatten.jpg" alt="Screenshot" /></a></p>
<p>Bei dreidimensionalen Applikationen gilt f√ºr jede Software genau wie im wirklichen Leben: ¬ªOhne Licht sehen Sie nichts!¬´ Das ist bei den spezialisierten Programmen wie <a href="http://cognitiones.kantel-chaos-team.de/multimedia/computergraphik/3d/blender.html">Blender</a> oder <a href="http://cognitiones.kantel-chaos-team.de/multimedia/computergraphik/3d/povray.html">PoVRay</a> genau so, wie auch in Processing.py. Daher m√∂chte ich in folgendem Skript zeigen, welche M√∂glichkeiten der Beleuchtung es in Processing gibt und welche Auswirkung sie auf die Szene haben.</p>
<p>Dazu habe ich eine Kugel verschachtelt in einer Box erzeugt und sie in ein 3D-Fenster gesetzt. Sie ist im Grunde farblos, nur f√ºr eine Belichtung (<code>lights()</code>) habe ich der Kugel eine hell- und der Box eine dunkelblaue Farbe verpa√üt.</p>
<p>Bevor ich die Kugel und die Box zeichnen lasse, √ºberpr√ºfe ich, welche Beleuchtungsfunktion aktuell angew√§hlt ist. Processing kennt sechs Beleuchtungfunktionen. Diese sind</p>
<ol type="1">
<li><code>noLights()</code>: Diese schaltet alle Beleuchtung aus und die dreidimensionalen Objekte wirken zweidimensional. Diese Funktion kann benutzt werden, um dreidimensionale Objekte mit zweidimensionalen Zeichnungen zu kombinieren.</li>
<li><code>lights()</code>: Das ist die einfachste Beleuchtungsfunktion, die die Umgebung in ein neutrales, ambientes Licht taucht. Sie kann immer erst einmal f√ºr den Test der dreidiemnsionalen Objekte eingesetzt verwendet werden, bevor man sich an spektakul√§rere Beleuchtungsmodelle wagt.</li>
<li><code>directionalLight(v1, v2, v3, nx, ny, nz)</code>: Diese Beleuchtungsfunktion besitzt sechs Parameter. Die ersten drei geben die Farbwerte an (es k√∂nnen je nach gew√§hltem Farbmode entweder RGB- oder HSB-Werte sein). Die letzten drei Werte geben jeweils die Richtung des Lichtes aus der x-, y, und/oder z-Richtung an. Direkte Richtungen sind <code>0, -1, 0</code> nach oben, <code>0, 1, 0</code> nach unten, <code>1, 0, 0</code> nach rechts und <code>-1, 0, 0</code> nach links. Analog sind die Werte f√ºr ¬ªLicht von vorne¬´ und ¬ªLicht von hinten¬´ einzustellen und durch Kombinationen der drei Parameter bekommt man auch Licht aus beliebigen Richtungen.</li>
<li><code>ambientLight(v1, v2, v3)</code> taucht die Umgebung in ein ambientes Licht in der mit <code>v1, v2, v3</code> spezifizierten Farbe (RGB oder HSB). Ambientes Licht wird meist mit anderen Lichtquellen kombiniert, um zum Beispiel die Schlagschatten der anderen, gerichteten Lichtquellen aufzuhellen.</li>
<li><code>pointLight(v1, v2, v3, x, y, z)</code> setzt ein punktf√∂rmiges Licht in den Farben <code>v1, v2, v3</code> aus der Position <code>x, y, z</code>.</li>
<li><code>spotLight(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration)</code> ergibt ein kegelf√∂rmiges Licht in den Varben <code>v1, v2, v3</code> von der Quelle <code>x, y, z</code> in die Richtung <code>nx, ny, nz</code> mit dem Winkel <code>angle</code> und der Intensit√§t <code>concentration</code>.</li>
</ol>
<p>Alle Beleuchtungsfunktionen m√ºssen innerhalb der <code>draw()</code>-Funktion aufgerufen werden. Werden sie stattdessen in der <code>setup</code>-Funktion aufgerufen, sind sie nur beim ersten Durchlauf wirksam. Daher habe ich das auch im Sketch so gehalten, wobei je nach gew√§hltem <code>lightMode</code> die Beleuchtung gesetzt wird.</p>
<h3 id="licht-aus----spot-an">Licht aus -- Spot an!</h3>
<p>Die Beleuchtung kann man w√§hrend der Sketch l√§uft mit der Tastatur ausw√§hlen. Die Tasten sind sprechend gew√§hlt:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> keyPressed():
    <span class="kw">global</span> lightMode, lightDirection
    <span class="kw">if</span> key == <span class="st">&quot;n&quot;</span>:
        lightMode = <span class="dv">0</span>            <span class="co"># no lights</span>
    <span class="kw">elif</span> key == <span class="st">&quot;l&quot;</span>:
        lightMode = <span class="dv">1</span>            <span class="co"># lights</span>
    <span class="kw">elif</span> key == <span class="st">&quot;d&quot;</span>:
        lightMode = <span class="dv">2</span>            <span class="co"># directional light</span>
    <span class="kw">elif</span> key == <span class="st">&quot;a&quot;</span>:
        lightMode = <span class="dv">3</span>            <span class="co"># ambient light</span>
    <span class="kw">elif</span> key == <span class="st">&quot;p&quot;</span>:
        lightMode = <span class="dv">4</span>            <span class="co"># point light</span>
    <span class="kw">elif</span> key == <span class="st">&quot;s&quot;</span>:
        lightMode = <span class="dv">5</span>            <span class="co"># spot light</span></code></pre>
<p>!!! warning &quot;Warnung&quot; Bevor man die Tasten dr√ºckt, sollte man darauf achten, da√ü das Graphikfenster von Processing.py im Vordergrund ist, also den Fokus besitzt. Denn sonst tippt man versehentlich gnadenlos Buchstaben in sein Skript und wundert sich, warum es anschlie√üend nicht mehr l√§uft. Ich verstehe nicht ganz, warum im Python-Mode das Ausgabefenster beim Start des Programmes nicht automatisch den Fokus bekommt, wie das im Java-Mode von Processing der Fall ist?</p>
<p>Ist das direktionale Licht ausgew√§hlt kann man zus√§tzlich noch mit den Pfeiltasten die Richtung des Lichtes bestimmen.</p>
<h3 id="quellcode-3">Quellcode</h3>
<p>Wenn man bedenkt, da√ü in diesem Programm doch einiges passiert, ist der Quellcode immer noch sehr kurz. Das Nachvollziehen sollte auch keine besondere M√ºhe machen, schlie√ülich wird Python ja oft und zu Recht als lauff√§higer Pseudocode bezeichnet.</p>
<pre class="sourceCode python"><code class="sourceCode python">lightMode = <span class="dv">0</span>
lightDirection = <span class="dv">0</span>

<span class="kw">def</span> setup():
    size(<span class="dv">640</span>, <span class="dv">480</span>, P3D)
    frame.setTitle(<span class="st">&quot;Licht und Schatten&quot;</span>)

<span class="kw">def</span> draw():
    <span class="kw">global</span> lightMode, lightDirection
    background(<span class="dv">0</span>)
    
    <span class="co"># Lichter setzen</span>
    <span class="kw">if</span> lightMode == <span class="dv">0</span>:
        noLights()
    <span class="kw">elif</span> lightMode == <span class="dv">1</span>:
        lights()
    <span class="kw">elif</span> lightMode == <span class="dv">2</span>:
        <span class="kw">if</span> lightDirection == <span class="dv">0</span>:
            directionalLight(<span class="dv">255</span>, <span class="dv">128</span>, <span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">0</span>) <span class="co"># up</span>
        <span class="kw">elif</span> lightDirection == <span class="dv">1</span>:
            directionalLight(<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>)    <span class="co"># right</span>
        <span class="kw">elif</span> lightDirection == <span class="dv">2</span>:
            directionalLight(<span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>)  <span class="co"># down</span>
        <span class="kw">elif</span> lightDirection == <span class="dv">3</span>:
            directionalLight(<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">255</span>, -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>) <span class="co"># left</span>
    <span class="kw">elif</span> lightMode == <span class="dv">3</span>:
        ambientLight(<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">255</span>)
    <span class="kw">elif</span> lightMode == <span class="dv">4</span>:
        pointLight(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">100</span>, height*<span class="fl">0.3</span>, <span class="dv">100</span>)
    <span class="kw">elif</span> lightMode == <span class="dv">5</span>:
        spotLight(<span class="dv">128</span>, <span class="dv">255</span>, <span class="dv">128</span>, <span class="dv">800</span>, <span class="dv">20</span>, <span class="dv">300</span>, -<span class="dv">1</span>, .<span class="dv">25</span>, <span class="dv">0</span>, PI, <span class="dv">2</span>)
    <span class="kw">else</span>:
        noLights()
    
    <span class="co"># Kugel und Box zeichnen</span>
    <span class="kw">with</span> pushMatrix():
        translate(width/<span class="dv">2</span>, height/<span class="dv">2</span>)
        <span class="kw">with</span> pushMatrix():
            rotateY(radians(frameCount))
            fill(<span class="dv">255</span>)
            <span class="kw">if</span> lightMode == <span class="dv">1</span>:
                fill(<span class="dv">151</span>, <span class="dv">255</span>, <span class="dv">255</span>)
            noStroke()
            sphere(<span class="dv">160</span>)
        <span class="kw">with</span> pushMatrix():
            rotateZ(radians(frameCount))
            rotateX(radians(frameCount/<span class="fl">2.0</span>))
            fill(<span class="dv">255</span>)
            <span class="kw">if</span> lightMode == <span class="dv">1</span>:
                fill(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">139</span>)
            noStroke()
            box(<span class="dv">240</span>)
            
<span class="kw">def</span> keyPressed():
    <span class="kw">global</span> lightMode, lightDirection
    <span class="kw">if</span> key == <span class="st">&quot;n&quot;</span>:
        lightMode = <span class="dv">0</span>            <span class="co"># no lights</span>
    <span class="kw">elif</span> key == <span class="st">&quot;l&quot;</span>:
        lightMode = <span class="dv">1</span>            <span class="co"># lights</span>
    <span class="kw">elif</span> key == <span class="st">&quot;d&quot;</span>:
        lightMode = <span class="dv">2</span>            <span class="co"># directional light</span>
    <span class="kw">elif</span> key == <span class="st">&quot;a&quot;</span>:
        lightMode = <span class="dv">3</span>            <span class="co"># ambient light</span>
    <span class="kw">elif</span> key == <span class="st">&quot;p&quot;</span>:
        lightMode = <span class="dv">4</span>            <span class="co"># point light</span>
    <span class="kw">elif</span> key == <span class="st">&quot;s&quot;</span>:
        lightMode = <span class="dv">5</span>            <span class="co"># spot light</span>
    
    <span class="kw">if</span> key == CODED:
        <span class="kw">if</span> keyCode == UP:
            lightDirection = <span class="dv">0</span>
        <span class="kw">elif</span> keyCode == RIGHT:
            lightDirection = <span class="dv">1</span>
        <span class="kw">elif</span> keyCode == DOWN:
            lightDirection = <span class="dv">2</span>
        <span class="kw">elif</span> keyCode == LEFT:
           lightDirection = <span class="dv">3</span></code></pre>
<div style="float:right;">
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//ws-eu.amazon-adsystem.com/widgets/q?ServiceVersion=20070822&amp;OneJS=1&amp;Operation=GetAdHtml&amp;MarketPlace=DE&amp;source=ss&amp;ref=as_ss_li_til&amp;ad_type=product_link&amp;tracking_id=derschockwell-21&amp;marketplace=amazon&amp;region=DE&amp;placement=1849517940&amp;asins=1849517940&amp;linkId=f158448c6496c6a5a0b1be0bfe476017&amp;show_border=true&amp;link_opens_in_new_window=true">
</iframe>
</div>
<h3 id="credits-5">Credits</h3>
<p>Dieses Beispielprogramm folgt einer Idee aus dem Bucn ¬ª<a href="https://www.amazon.de/Processing-2-Creative-Programming-Cookbook/dp/1849517940/ref=as_li_ss_tl?ie=UTF8&amp;qid=1487506788&amp;sr=8-1&amp;keywords=processing+2:+creative+programming+cookbook&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=e9ce248db424f20cd29c824841add824">Processing 2: Creative Programming Cookbook</a>¬´ von <em>Jan Vantomme</em>. Ich habe sie geringf√ºgig √ºberarbeitet und vom Processing 2 Java-Mode in den Python-Mode von Processing 3 umgeschrieben.</p>
<h3 id="literatur-7">Literatur</h3>
<ul>
<li>Jan Vantomme: <em><a href="https://www.amazon.de/Processing-2-Creative-Programming-Cookbook/dp/1849517940/ref=as_li_ss_tl?ie=UTF8&amp;qid=1487506788&amp;sr=8-1&amp;keywords=processing+2:+creative+programming+cookbook&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=e9ce248db424f20cd29c824841add824">Processing 2: Creative Programming Cookbook</a></em>, Birmingham <em>(Packt Publishing)</em>, 2012</li>
</ul>
<h2 id="einen-globus-basteln">Einen Globus basteln</h2>
<p>Wenn ich -- wie im <a href="http://py.kantel-chaos-team.de/kugel/">vorletzten Beispiel</a> -- eine dreidimensionale Kugel programmiere, denke ich immer an den Leuchtglobus, der vor Jahrzehnten auf meinem Kinderzimmerschreibtisch stand und dem ich die Liebe zur Geographie verdanke. Es war ein Leuchtglobus, ausgeschaltet zeigte er eine topographische Weltkarte und eingeschaltet wurde er bunt und zeigte jeden Staat in einer anderen Farbe. So etwas √§hnliches, n√§mlich einen Globus mit wechselnden Darstellungen m√∂chte ich nun in Processing.py programmieren.</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32934837855/"><img src="images/globe0102.jpg" alt="Globe 01 und 02" /></a></p>
<p>Um das zu erreichen, m√ºssen Texturen √ºber eine Kugel gelegt werden und das ist bei den einfachen, mit <code>sphere()</code> erzeugten Kugeln leider nicht m√∂glich, wir m√ºssen uns schon eine eigene Kugel aus <a href="https://de.wikipedia.org/wiki/Vertex#Computergrafik">Vertices</a> (Eckpunkten) selber basteln. Wir entwickeln sie in der Funktion <code>makeSphere()</code> aus einzelnen, aus Rechtecken zusammengesetzten Streifen in Polarkoordinaten, die dann mit Hilfe der Sinus- und Cosinus-Funktion in kartesische Koordinaten umgerechnet werden.</p>
<p>Um die einzelnen Rechteckst√ºcke zu bekommen, m√ºssen wir dem <code>beginShape()</code> den Modus <code>QUAD_STRIP</code> mitgeben. Eine anderer m√∂glicher Modus w√§re <code>TRIANGLE_STRIP</code>, Ihr k√∂nnt das ja mal testweise in den Sketch unten einsetzen, statt aus Streifen wird dann die Kugel aus Dreiecken zusammengesetzt.</p>
<h3 id="quellcode-globe-01">Quellcode Globe 01</h3>
<pre class="sourceCode python"><code class="sourceCode python">a = <span class="fl">0.0</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> globe
    size(<span class="dv">400</span>, <span class="dv">400</span>, P3D)
    globe = makeSphere(<span class="dv">150</span>, <span class="dv">10</span>)

<span class="kw">def</span> draw():
    <span class="kw">global</span> globe, a
    background(<span class="dv">0</span>)
    translate(width/<span class="dv">2</span>, height/<span class="dv">2</span>)
    <span class="kw">with</span> pushMatrix():
        <span class="co"># rotateX(radians(0))</span>
        rotateY(a)
        a += <span class="fl">0.01</span>
        shape(globe)

<span class="kw">def</span> makeSphere(r, step):
    s = createShape()
    s.beginShape(QUAD_STRIP)
    s.noFill()
    s.stroke(<span class="dv">255</span>)
    s.strokeWeight(<span class="dv">1</span>)
    i = <span class="dv">0</span>
    <span class="kw">while</span> i &lt; <span class="dv">180</span>:
        sini = sin(radians(i))
        cosi = cos(radians(i))
        sinip = sin(radians(i + step))
        cosip = cos(radians(i + step))
        j = <span class="dv">0</span>
        <span class="kw">while</span> j &lt;= <span class="dv">360</span>:
            sinj = sin(radians(j))
            cosj = cos(radians(j))
            s.vertex(r*cosj*sini, r*-cosi, r*sinj*sini)
            s.vertex(r*cosj*sinip, r*-cosip, r*sinj*sinip)
            j += step
        i += step
    s.endShape()
    <span class="kw">return</span> s</code></pre>
<p>Der n√§chste Schritt w√§re dann, dieser Kugel eine Farbe zu verpassen. Ich habe dies in dem Sketch unten mit <code>fill(135, 206, 250)</code> versucht, das ein leichtes Blau erzeugt. Au√üerdem habe ich mit <code>pointLight(255, 255, 255, -250, -250, 500)</code> eine dramatische Beleuchtung gesetzt, die aber in den weiteren Fassungen wieder durch das einfache <code>lights()</code>, das f√ºr eine gleichm√§√üige Ausleuchtung sorgt, wieder ersetzt wird.</p>
<p>Doch das alleine reicht nicht aus. Wenn Ihr den Sketch so laufen la√üt, werdet Ihr feststellen, da√ü die Kugel irgendwie ¬ªeckig¬´ wirkt. Die √úberg√§nge zwischen den einzelnen Quads sind deutlich zu erkennen. Und au√üerdem scheint sie sich an dem 0¬∞- respektive 360¬∞-Linie zu √ºberlappen oder eine kleine L√ºcke zu klaffen. Um dies zu √§ndern, benutzt man in der Computergraphik den <a href="https://de.wikipedia.org/wiki/Normalenvektor">Normalenvektor</a> zur Gl√§ttung von Kanten und auch in Processing ist dies mit der Methode <code>normal()</code> schon vorgesehen. Die Normalen sind Vektoren, die senkrecht auf einem Punk stehen und diese m√ºssen vor dem <code>vertex()</code>-Aufruf gesetzt werden.</p>
<h3 id="quellcode-globe-02">Quellcode Globe 02</h3>
<pre class="sourceCode python"><code class="sourceCode python">a = <span class="fl">0.0</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> globe
    size(<span class="dv">400</span>, <span class="dv">400</span>, P3D)
    globe = makeSphere(<span class="dv">150</span>, <span class="dv">5</span>)

<span class="kw">def</span> draw():
    <span class="kw">global</span> globe, a
    background(<span class="dv">0</span>)
    translate(width/<span class="dv">2</span>, height/<span class="dv">2</span>)
    pointLight(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>, -<span class="dv">250</span>, -<span class="dv">250</span>, <span class="dv">500</span>)
    <span class="co"># lights()</span>
    <span class="kw">with</span> pushMatrix():
        rotateX(radians(-<span class="dv">30</span>))
        rotateY(a)
        a += <span class="fl">0.01</span>
        shape(globe)

<span class="kw">def</span> makeSphere(r, step):
    s = createShape()
    s.beginShape(QUAD_STRIP)
    s.fill(<span class="dv">135</span>, <span class="dv">206</span>, <span class="dv">250</span>)
    s.noStroke()
    s.strokeWeight(<span class="dv">1</span>)
    i = <span class="dv">0</span>
    <span class="kw">while</span> i &lt; <span class="dv">180</span>:
        sini = sin(radians(i))
        cosi = cos(radians(i))
        sinip = sin(radians(i + step))
        cosip = cos(radians(i + step))
        j = <span class="dv">0</span>
        <span class="kw">while</span> j &lt;= <span class="dv">360</span>:
            sinj = sin(radians(j))
            cosj = cos(radians(j))
            s.normal(cosj*sini, -cosi, sinj*sini)
            s.vertex(r*cosj*sini, r*-cosi, r*sinj*sini)
            s.normal(cosj*sinip, -cosip, sinj*sinip)
            s.vertex(r*cosj*sinip, r*-cosip, r*sinj*sinip)
            j += step
        i += step
    s.endShape()
    <span class="kw">return</span> s</code></pre>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/32894074766/"><img src="images/globe0304.jpg" alt="Globe 03 und 04" /></a></p>
<p>Nun ist aber alles sch√∂n glatt und es k√∂nnen aus den Kugeln Globen werden. F√ºr den ersten Globus habe ich mir eine der legend√§ren <a href="https://de.wikipedia.org/wiki/Blue_Marble#Die_Blue-Marble-Serie_der_NASA">Blue-Marble-Karten der NASA</a> in der Gr√∂√üe von 640x320 Pixeln von den Seiten der Wikipedia gezogen (<a href="https://commons.wikimedia.org/wiki/File:Equirectangular-projection.jpg">Download-Link</a>) und sie <code>bluemarble01.jpg</code> genannt. Diese Bilder sind in einer <a href="https://de.wikipedia.org/wiki/Plattkarte#Quadratische_Plattkarte">Projektion</a>, die noch am ehesten das Aufziehen auf eine Kugel erlauben.</p>
<p>Die Funktion <code>vertex()</code> kann nun nicht nur in der Form</p>
<pre class="sourceCode python"><code class="sourceCode python">vertex(x, y, z)</code></pre>
<p>sondern auch in der Form</p>
<pre class="sourceCode python"><code class="sourceCode python">vertext(x, y, z, u, v)</code></pre>
<p>aufgerufen werden, wobei dann <code>u</code> und <code>v</code> die horizontalen respektive vertikalen Koordinaten f√ºr das Texture-Mapping sind. Und so wird aus der Kugel tats√§chlich ein Globus mit einem Abbild unseres wundersch√∂nen blauen Planeten.</p>
<h3 id="quellcode-globe-03">Quellcode Globe 03</h3>
<pre class="sourceCode python"><code class="sourceCode python">a = <span class="fl">0.0</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> globe
    size(<span class="dv">400</span>, <span class="dv">400</span>, P3D)
    world = loadImage(<span class="st">&quot;bluemarble01.jpg&quot;</span>)
    globe = makeSphere(<span class="dv">150</span>, <span class="dv">5</span>, world)
    frameRate(<span class="dv">30</span>)

<span class="kw">def</span> draw():
    <span class="kw">global</span> globe, a
    background(<span class="dv">0</span>)
    translate(width/<span class="dv">2</span>, height/<span class="dv">2</span>)
    lights()
    <span class="kw">with</span> pushMatrix():
        rotateX(radians(-<span class="dv">25</span>))
        rotateY(a)
        a += <span class="fl">0.01</span>
        shape(globe)

<span class="kw">def</span> makeSphere(r, step, tex):
    s = createShape()
    s.beginShape(QUAD_STRIP)
    s.texture(tex)
    s.noStroke()
    i = <span class="dv">0</span>
    <span class="kw">while</span> i &lt; <span class="dv">180</span>:
        sini = sin(radians(i))
        cosi = cos(radians(i))
        sinip = sin(radians(i + step))
        cosip = cos(radians(i + step))
        j = <span class="dv">0</span>
        <span class="kw">while</span> j &lt;= <span class="dv">360</span>:
            sinj = sin(radians(j))
            cosj = cos(radians(j))
            s.normal(cosj*sini, -cosi, sinj*sini)
            s.vertex(r*cosj*sini, r*-cosi, r*sinj*sini,
                     tex.width-j*tex.width/<span class="fl">360.0</span>, i*tex.height/<span class="fl">180.0</span>)
            s.normal(cosj*sinip, -cosip, sinj*sinip)
            s.vertex(r*cosj*sinip, r*-cosip, r*sinj*sinip,
                     tex.width-j*tex.width/<span class="fl">360.0</span>, (i+step)*tex.height/<span class="fl">180.0</span>)
            j += step
        i += step
    s.endShape()
    <span class="kw">return</span> s</code></pre>
<figure>
<img src="images/world-map-1910.jpg" alt="Eine Weltkarte aus dem Jahre 1910" /><figcaption>Eine Weltkarte aus dem Jahre 1910</figcaption>
</figure>
<p>Zum Schlu√ü bin ich dann √ºberm√ºtig geworden und habe eine Weltkarte aus dem Jahre 1910 genommen und sie als Texture auf den Globus gelegt. Wie Ihr leicht erkennen k√∂nnt, eignet sich die in dieser Karte verwendete, sehr eurozentrische Projektion nicht besonders, um sie gerecht auf eine Kugel zu projizieren (Gr√∂nland besitzt in etwa die Fl√§che von Afrika). Um wenigstens den Schein zu wahren, habe ich die Kugel mit <code>rotateX(radians(5))</code> so geneigt, da√ü der Effekt in den Hintergrund tritt. Nordeuropa, Gr√∂nland und Kanada verschwinden dadurch ein bi√üchen hinter dem Horizont und durch den Bauch der Kugel erscheint dann auch Afrika wieder gr√∂√üer.</p>
<h3 id="quellcode-globe-04">Quellcode Globe 04</h3>
<pre class="sourceCode python"><code class="sourceCode python">a = <span class="fl">0.0</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> globe
    size(<span class="dv">400</span>, <span class="dv">400</span>, P3D)
    world = loadImage(<span class="st">&quot;world-map-1910.jpg&quot;</span>)
    globe = makeSphere(<span class="dv">150</span>, <span class="dv">5</span>, world)
    frameRate(<span class="dv">30</span>)

<span class="kw">def</span> draw():
    <span class="kw">global</span> globe, a
    background(<span class="dv">0</span>)
    translate(width/<span class="dv">2</span>, height/<span class="dv">2</span>)
    lights()
    <span class="kw">with</span> pushMatrix():
        rotateX(radians(<span class="dv">5</span>))
        rotateY(a)
        a += <span class="fl">0.01</span>
        shape(globe)

<span class="kw">def</span> makeSphere(r, step, tex):
    s = createShape()
    s.beginShape(QUAD_STRIP)
    s.texture(tex)
    s.noStroke()
    i = <span class="dv">0</span>
    <span class="kw">while</span> i &lt; <span class="dv">180</span>:
        sini = sin(radians(i))
        cosi = cos(radians(i))
        sinip = sin(radians(i + step))
        cosip = cos(radians(i + step))
        j = <span class="dv">0</span>
        <span class="kw">while</span> j &lt;= <span class="dv">360</span>:
            sinj = sin(radians(j))
            cosj = cos(radians(j))
            s.normal(cosj*sini, -cosi, sinj*sini)
            s.vertex(r*cosj*sini, r*-cosi, r*sinj*sini,
                     tex.width-j*tex.width/<span class="fl">360.0</span>, i*tex.height/<span class="fl">180.0</span>)
            s.normal(cosj*sinip, -cosip, sinj*sinip)
            s.vertex(r*cosj*sinip, r*-cosip, r*sinj*sinip,
                     tex.width-j*tex.width/<span class="fl">360.0</span>, (i+step)*tex.height/<span class="fl">180.0</span>)
            j += step
        i += step
    s.endShape()
    <span class="kw">return</span> s</code></pre>
<h3 id="credits-6">Credits</h3>
<p>Noch mehr mit Globen stellt <em>Nikolaus Gradwohl</em> in seinem lesenswerten, von kreativen Ideen geradezu √ºberlaufenden Buch ¬ª<a href="https://www.amazon.de/Processing-2-Creative-Coding-Hotshot/dp/1782166726/ref=as_li_ss_tl?ie=UTF8&amp;qid=1487608123&amp;sr=8-1&amp;keywords=processing+2+creative+coding+hotshot&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=d122ec0e5725e0177a740b9d07e524b4">Processing 2: Creative Coding Hotshot</a>¬´ auf den Seiten 163 bis 215 an. Er l√§√üt sie in Neonfarben leuchten und projiziert die Daten von Logfiles darauf. Ich habe in Teilen von seinem Code und seinen Ideen profitiert, ihn ver√§ndert und ihn von Processings Java-Mode in den Python-Mode √ºberf√ºhrt.</p>
<h3 id="literatur-8">Literatur</h3>
<ul>
<li>Nikolaus Gradwohl: <em><a href="https://www.amazon.de/Processing-2-Creative-Coding-Hotshot/dp/1782166726/ref=as_li_ss_tl?ie=UTF8&amp;qid=1487608123&amp;sr=8-1&amp;keywords=processing+2+creative+coding+hotshot&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=d122ec0e5725e0177a740b9d07e524b4">Processing 2: Creative Coding Hotshot</a></em>, Birmingham <em>(Packt Publishing)</em> 2013</li>
</ul>
<h1 id="einen-eigenen-wetterbericht-mit-openweathermap">Einen eigenen Wetterbericht mit OpenWeatherMap</h1>
<figure>
<img src="images/OpenWeatherMapLogo.png" alt="OpenWeatherMap Logo" /><figcaption>OpenWeatherMap Logo</figcaption>
</figure>
<h2 id="openweathermap">OpenWeatherMap</h2>
<p><a href="http://openweathermap.org/">OpenWeatherMap</a> bietet aktuelle und freie (<a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>) Wetterdaten von mehr als 200.000 Stationen weltweit (sagt die <a href="https://de.wikipedia.org/wiki/OpenWeatherMap">Wikipedia</a>), die √ºber eine frei nutzbare <a href="http://openweathermap.org/api">JSON-API</a> abgefragt werden k√∂nnen -- allerdings wird eine Registrierung und ein API-Key ben√∂tigt und um einen R√ºcklink auf OpenWeastherMap gebeten. Mit dem freien API-Key darf man 60 Anfragen in der Minute stellen und es stehen einem die</p>
<ul>
<li>Current Weather API, die</li>
<li>5 day/3 hour forecast API und die</li>
<li>Weather maps API</li>
</ul>
<p>zur Verf√ºgung. Ben√∂tigt man mehr, mu√ü man eine der kommerziellen Lizenzen nutzen. Man kann die APIs nach St√§dtenamen, Geo-Koordinaten oder St√§dte-IDs abfragen. Ich habe f√ºr mich mal ein paar relevante Orte herausgesucht:</p>
<ul>
<li>Berlin Tempelhof,DE -- Geo-Koordinaten [52.4769, 13.4103] (das ist die n√§chste Station an meinem Wohnort)</li>
<li>Berlin Steglitz Zehlendorf,DE -- Geo-Koordinaten [52.4348, 13.2418]</li>
<li>Schmargendorf,DE -- Geo-Koordinaten [52.4752, 13.2907] (ich wei√ü nicht, welche von den beiden n√§her an meiner Arbeitsstelle stationiert sind, Schmargendorf steht √ºbrigens f√ºr Berlin Dahlem)</li>
<li>Berlin Koepenick,DE -- Geo-Koordinaten [52.4425, 13.5823] (da ist ¬ªunser¬´ Hundeplatz) und</li>
<li>Berlin,DE -- Geo-Koordinaten [52.5244, 13.4105] (Berlin Mitte)</li>
</ul>
<p>Per Default kommen die Antwort in Englisch und die Temperaturangaben in Kelvin. Will man sie in Deutsch und ¬∞Celsius haben, mu√ü man der URL noch die Parameter <code>&amp;lang=de</code> und <code>&amp;units=metric</code> mitgeben. Ein Aufruf f√ºr Berlin-Tempelhof s√§he dann so aus:</p>
<pre><code>http://api.openweathermap.org/data/2.5/weather?q=Berlin%20Tempelhof,DE&amp;units=metric&amp;lang=de&amp;APPID=0815</code></pre>
<p>Die APPID habe ich mir ausgedacht, Ihr m√º√üt Euch schon selber eine besorgen (die dann auch viel komplizierter und l√§nger ist). Wird die Anfrage mit einer g√ºltigen APPID abgeschickt, bekommt Ihr eine Antwort der Art:</p>
<pre class="sourceCode json"><code class="sourceCode json"><span class="fu">{</span><span class="dt">&quot;coord&quot;</span><span class="fu">:</span>
    <span class="fu">{</span><span class="dt">&quot;lon&quot;</span><span class="fu">:</span><span class="fl">13.41</span><span class="fu">,</span><span class="dt">&quot;lat&quot;</span><span class="fu">:</span><span class="fl">52.48</span><span class="fu">},</span>
    <span class="dt">&quot;weather&quot;</span><span class="fu">:</span><span class="ot">[</span><span class="fu">{</span><span class="dt">&quot;id&quot;</span><span class="fu">:</span><span class="dv">500</span><span class="fu">,</span><span class="dt">&quot;main&quot;</span><span class="fu">:</span><span class="st">&quot;Rain&quot;</span><span class="fu">,</span><span class="dt">&quot;description&quot;</span><span class="fu">:</span><span class="st">&quot;leichter Regen&quot;</span><span class="fu">,</span><span class="dt">&quot;icon&quot;</span><span class="fu">:</span><span class="st">&quot;10d&quot;</span><span class="fu">}</span><span class="ot">]</span><span class="fu">,</span>
    <span class="dt">&quot;base&quot;</span><span class="fu">:</span><span class="st">&quot;stations&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;main&quot;</span><span class="fu">:</span>
        <span class="fu">{</span><span class="dt">&quot;temp&quot;</span><span class="fu">:</span><span class="dv">8</span><span class="fu">,</span><span class="dt">&quot;pressure&quot;</span><span class="fu">:</span><span class="dv">992</span><span class="fu">,</span><span class="dt">&quot;humidity&quot;</span><span class="fu">:</span><span class="dv">93</span><span class="fu">,</span><span class="dt">&quot;temp_min&quot;</span><span class="fu">:</span><span class="dv">8</span><span class="fu">,</span><span class="dt">&quot;temp_max&quot;</span><span class="fu">:</span><span class="dv">8</span>
    <span class="fu">},</span>
    <span class="dt">&quot;visibility&quot;</span><span class="fu">:</span><span class="dv">9000</span><span class="fu">,</span>
    <span class="dt">&quot;wind&quot;</span><span class="fu">:{</span><span class="dt">&quot;speed&quot;</span><span class="fu">:</span><span class="fl">5.7</span><span class="fu">,</span><span class="dt">&quot;deg&quot;</span><span class="fu">:</span><span class="dv">210</span><span class="fu">},</span><span class="dt">&quot;clouds&quot;</span><span class="fu">:{</span><span class="dt">&quot;all&quot;</span><span class="fu">:</span><span class="dv">90</span><span class="fu">},</span>
    <span class="dt">&quot;dt&quot;</span><span class="fu">:</span><span class="dv">1487857800</span><span class="fu">,</span>
    <span class="dt">&quot;sys&quot;</span><span class="fu">:</span>
        <span class="fu">{</span><span class="dt">&quot;type&quot;</span><span class="fu">:</span><span class="dv">1</span><span class="fu">,</span><span class="dt">&quot;id&quot;</span><span class="fu">:</span><span class="dv">4892</span><span class="fu">,</span><span class="dt">&quot;message&quot;</span><span class="fu">:</span><span class="fl">0.0029</span><span class="fu">,</span><span class="dt">&quot;country&quot;</span><span class="fu">:</span><span class="st">&quot;DE&quot;</span><span class="fu">,</span><span class="dt">&quot;sunrise&quot;</span><span class="fu">:</span><span class="dv">1487829867</span><span class="fu">,</span><span class="dt">&quot;sunset&quot;</span><span class="fu">:</span><span class="dv">1487867737</span>
    <span class="fu">},</span>
    <span class="dt">&quot;id&quot;</span><span class="fu">:</span><span class="dv">7290253</span><span class="fu">,</span><span class="dt">&quot;name&quot;</span><span class="fu">:</span><span class="st">&quot;Berlin Tempelhof&quot;</span><span class="fu">,</span><span class="dt">&quot;cod&quot;</span><span class="fu">:</span><span class="dv">200</span>
<span class="fu">}</span></code></pre>
<p>Die Antwort kommt in einer Zeile, ich habe sie nur der besseren Lesbarkeit wegen umgebrochen. Die Bedeutung der einzelnen Paramter bekommt Ihr auf <a href="http://openweathermap.org/current">dieser Seite</a> erkl√§rt und die <em>Weather Condition Codes</em> und Icons sind auf <a href="http://openweathermap.org/weather-conditions">dieser Seite</a> aufgef√ºhrt.</p>
<figure>
<img src="images/wetterstation.jpg" alt="Screenshot Wetterstation" /><figcaption>Screenshot Wetterstation</figcaption>
</figure>
<h2 id="die-wetterstation-mit-processing.py">Die Wetterstation mit Processing.py</h2>
<p>Um diese JSON-Daten nun mit Processing.py lesen zu k√∂nnen, kann man auf die Standardbibliothek zur√ºckgreifen, die einmal mit <code>urllib2</code> einen einfachen Umgang mit dem Laden von Daten aus dem Netz erlaubt und zum anderen mit <code>json</code> ein Modul mitbringt, das den Umgang mit den JSON-Dateien vereinfacht.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> json
<span class="ch">import</span> urllib2
weatherUrl = <span class="st">&quot;http://api.openweathermap.org/data/2.5/weather?q=Berlin%20Tempelhof,DE&amp;units=metric&amp;lang=de&amp;APPID=4711&quot;</span>
weatherData = json.load(urllib2.urlopen(weatherUrl))</code></pre>
<p>Noch einmal: Den API-Key (<code>APPID</code>) habe ich mir ausgedacht, um den Code-Schnipsel oben zum Laufen zu bekommen, m√º√üt Ihr Euch auf den Seiten von OpenWeatherMap schon einen eigenen API-Key besorgen.</p>
<pre class="pyton"><code>{
    u&#39;visibility&#39;: 10000,
    u&#39;main&#39;: {
        u&#39;temp&#39;: 3,
        u&#39;pressure&#39;: 1007,
        u&#39;temp_max&#39;: 3,
        u&#39;temp_min&#39;: 3,
        u&#39;humidity&#39;: 74
    },
    u&#39;clouds&#39;: {u&#39;all&#39;: 40},
    u&#39;sys&#39;: {
        u&#39;country&#39;:
        u&#39;DE&#39;,
        u&#39;sunrise&#39;: 1487916142,
        u&#39;type&#39;: 1,
        u&#39;message&#39;: 0.0025,
        u&#39;sunset&#39;: 1487954244,
        u&#39;id&#39;: 4892
    },
    u&#39;dt&#39;: 1487940600,
    u&#39;coord&#39;: {u&#39;lon&#39;: 13.41, u&#39;lat&#39;: 52.48},
    u&#39;weather&#39;: [{
        u&#39;icon&#39;: u&#39;13d&#39;, u&#39;description&#39;: u&#39;m\xe4\xdfiger Schnee&#39;, u&#39;main&#39;: u&#39;Snow&#39;, u&#39;id&#39;: 600
    }],
    u&#39;name&#39;: u&#39;Berlin Tempelhof&#39;,
    u&#39;cod&#39;: 200,
    u&#39;id&#39;: 7290253,
    u&#39;base&#39;: u&#39;stations&#39;,
    u&#39;wind&#39;: {u&#39;deg&#39;: 310, u&#39;speed&#39;: 4.6}
}</code></pre>
<p>La√üt Ihr Euch die <code>weatherData</code> aus obigem Codeschnipsel mal anzeigen (ich habe sie wieder der besseren Lesbarkeit wegen umgebrochen), dann seht Ihr, da√ü die JSON-Bibliothek die Antwort als <em>Dictionary</em> behandelt und Ihr damit nicht mehr auf die Reihenfolge bauen k√∂nnt. Es ist zwar alles vorhanden, was Ihr auch ganz oben in der ersten Anwort seht, aber in einer v√∂llig anderen Reihenfolge. Au√üerdem hat die Bibliothek alle Strings als UTF-8-Strings gekennzeichnet.</p>
<p>Nun lassen sich aber die Werte in <em>Dictionaries</em> in Python mit Ihrem Key abfragen und die Keys k√∂nnen miteinander verkettet werden. Wollt Ihr zum Beispiel den Wert des Dictionaries <code>&quot;temp&quot;</code>, das Teil des Dictionaries <code>&quot;main&quot;</code> ist, abfragen, so ist dies mit</p>
<pre class="sourceCode python"><code class="sourceCode python">temp = weatherData[<span class="st">&quot;main&quot;</span>][<span class="st">&quot;temp&quot;</span>]</code></pre>
<p>m√∂glich. In einigen F√§llen beinhalten die JSON-Objekte aber auch Listen. Diese k√∂nnen aber ebenfalls verkettet werden und werden √ºber ihren Index aufgerufen. Wollt Ihr zum Beispiel die Wetterbeschreibung (<code>&quot;description&quot;</code>) aus dem Dictionary <code>&quot;weather&quot;</code> haben, so m√º√üt Ihr folgendes programmieren:</p>
<pre class="sourceCode python"><code class="sourceCode python">wetter = weatherData[<span class="st">&quot;weather&quot;</span>][<span class="dv">0</span>][<span class="st">&quot;description&quot;</span>]</code></pre>
<p>So habe ich mir St√ºck f√ºr St√ºck alle Daten, die ich f√ºr mein kleines Wetterfenster haben wollte, zusammengeklaubt.</p>
<p>Schaut Ihr Euch die Daten, die eine Datums- und Zeitangabe betreffen, genauer an, werdet Ihr feststellen (oder in der Dokumentation nachlesen), da√ü diese -- wie international √ºblich -- als UTC-Timestamp kommen. Um dieses zu konvertieren, bildet das Modul <code>datetime</code> Hilfe an, zum Beispiel:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> datetime
sunrise = weatherData[<span class="st">&quot;sys&quot;</span>][<span class="st">&quot;sunrise&quot;</span>]
lokalsunrise = datetime.datetime.fromtimestamp(sunrise).ctime()</code></pre>
<p>Mit <code>fromtimestamp</code> wird der UTC-Stempel in eine lesbare Zeit verwandelt und das anschlie√üende <code>ctime</code> sorgt daf√ºr, da√ü dies in die lokale Rechnerzeit umgewandelt wird (in meinem Fall in UTC+1 oder w√§hrend der Sommerzeit in UTC+2). Um die Sommerzeit k√ºmmert sich <code>ctime</code> automatisch, da mu√ü sich der Programmierer nicht weiter sorgen.</p>
<p>Das Wetter-Icon kommt nat√ºrlich auch von OpenWeatherMap und kann so geladen und angezeigt werden:</p>
<pre class="sourceCode python"><code class="sourceCode python">icon = weatherData[<span class="st">&quot;weather&quot;</span>][<span class="dv">0</span>][<span class="st">&quot;icon&quot;</span>]
weatherIcon = loadImage(<span class="st">&quot;http://openweathermap.org/img/w/&quot;</span> + icon + <span class="st">&quot;.png&quot;</span>)
image(weatherIcon, <span class="dv">10</span>, <span class="dv">260</span>)</code></pre>
<p>Das ist eigentlich alles, was der Programmierer wissen mu√ü. F√ºr die aktuelle Zeit habe ich ebenfalls das Modul <code>datetime</code> genutzt und die Berechnungen durchgef√ºhrt, die ich auch schon in dem Programm zur <a href="http://py.kantel-chaos-team.de/rentenuhr/">Rentenuhr</a> genutzt hatte.</p>
<p>Um den Hauptsketch √ºbersichtlich zu halten, habe ich die beiden Funktionen <code>getWeatherData()</code> und <code>getNow()</code> in ein eigenes Modul <code>getWeatherData.py</code> ausgelagert, das wie folgt aussieht:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># coding=utf-8</span>
<span class="ch">import</span> json
<span class="ch">import</span> urllib2
<span class="ch">import</span> datetime

<span class="kw">def</span> getWeatherData():
    weatherUrl = <span class="st">&quot;http://api.openweathermap.org/data/2.5/weather?q=Berlin%20Tempelhof,DE&amp;units=metric&amp;lang=de&amp;APPID=4711&quot;</span>
    weatherData = json.load(urllib2.urlopen(weatherUrl))
    
    <span class="co"># Temperatur</span>
    temp = weatherData[<span class="st">&quot;main&quot;</span>][<span class="st">&quot;temp&quot;</span>]
    myTemperatur = <span class="st">u&quot;Temperatur: &quot;</span> + <span class="dt">str</span>(temp) + <span class="st">u&quot;¬∞C.&quot;</span>
    text(myTemperatur, <span class="dv">10</span>, <span class="dv">20</span>)
    
    <span class="co"># Wetter-Beschreibung</span>
    wetter = weatherData[<span class="st">&quot;weather&quot;</span>][<span class="dv">0</span>][<span class="st">&quot;description&quot;</span>]
    myWetter = <span class="st">u&quot;Wetter: &quot;</span> + wetter + <span class="st">&quot;.&quot;</span>
    text(myWetter, <span class="dv">10</span>, <span class="dv">42</span>)
    
    <span class="co"># Sonnenauf- und -untergang</span>
    sunrise = weatherData[<span class="st">&quot;sys&quot;</span>][<span class="st">&quot;sunrise&quot;</span>]
    sunset = weatherData[<span class="st">&quot;sys&quot;</span>][<span class="st">&quot;sunset&quot;</span>]
    mySunrise = <span class="st">&quot;Sonnenaufgang: &quot;</span> + datetime.datetime.fromtimestamp(sunrise).ctime() + <span class="st">&quot;.&quot;</span>
    mySunset =  <span class="st">&quot;Sonnenuntergang: &quot;</span> + datetime.datetime.fromtimestamp(sunset).ctime() + <span class="st">&quot;.&quot;</span>                             
    text(mySunrise, <span class="dv">10</span>, <span class="dv">80</span>)
    text(mySunset, <span class="dv">10</span>, <span class="dv">102</span>)
    
    <span class="co"># Luftdruck und -feuchtigkeit</span>
    pressure = weatherData[<span class="st">&quot;main&quot;</span>][<span class="st">&quot;pressure&quot;</span>]
    myPressure = <span class="st">&quot;Luftdruck: &quot;</span> + <span class="dt">str</span>(pressure) + <span class="st">&quot; hPa.&quot;</span>
    text(myPressure, <span class="dv">10</span>, <span class="dv">140</span>)
    humidity = weatherData[<span class="st">&quot;main&quot;</span>][<span class="st">&quot;humidity&quot;</span>]
    myHumidity = <span class="st">&quot;Luftfeuchtigkeit: &quot;</span> + <span class="dt">str</span>(humidity) + <span class="st">&quot; %.&quot;</span>
    text(myHumidity, <span class="dv">10</span>, <span class="dv">162</span>)
    
    <span class="co"># Windgeschwindigkeit und Bew√∂lkung</span>
    wind = weatherData[<span class="st">&quot;wind&quot;</span>][<span class="st">&quot;speed&quot;</span>]
    myWind = <span class="st">&quot;Windgeschwindigkeit: &quot;</span> + <span class="dt">str</span>(wind) + <span class="st">&quot; m/s.&quot;</span>
    text(myWind, <span class="dv">10</span>, <span class="dv">200</span>)
    clouds = weatherData[<span class="st">&quot;clouds&quot;</span>][<span class="st">&quot;all&quot;</span>]
    myClouds = <span class="st">u&quot;Bew√∂lkung: &quot;</span> + <span class="dt">str</span>(clouds) + <span class="st">&quot; %.&quot;</span>
    text(myClouds, <span class="dv">10</span>, <span class="dv">222</span>)
    
    <span class="co"># Wetter-Icon</span>
    icon = weatherData[<span class="st">&quot;weather&quot;</span>][<span class="dv">0</span>][<span class="st">&quot;icon&quot;</span>]
    weatherIcon = loadImage(<span class="st">&quot;http://openweathermap.org/img/w/&quot;</span> + icon + <span class="st">&quot;.png&quot;</span>)
    image(weatherIcon, <span class="dv">10</span>, <span class="dv">260</span>)
    
    <span class="co"># Abfragezeit und -ort</span>
    dt = weatherData[<span class="st">&quot;dt&quot;</span>]
    station = weatherData[<span class="st">&quot;name&quot;</span>]
    myDt = <span class="st">&quot;Stand: &quot;</span> + datetime.datetime.fromtimestamp(dt).ctime() + <span class="st">&quot; aus &quot;</span> + station + <span class="st">&quot;.&quot;</span>
    text(myDt, <span class="dv">10</span>, <span class="dv">360</span>)

<span class="kw">def</span> getNow():
    myNow = datetime.datetime.now()
    myHour = <span class="dt">str</span>(myNow.hour)
    myMinute = <span class="dt">str</span>(myNow.minute).rjust(<span class="dv">2</span>, <span class="st">&quot;0&quot;</span>)
    mySecond = <span class="dt">str</span>(myNow.second).rjust(<span class="dv">2</span>, <span class="st">&quot;0&quot;</span>)
    myTime = myHour + <span class="st">&quot;:&quot;</span> + myMinute + <span class="st">&quot;:&quot;</span> + mySecond              
    text(<span class="st">u&quot;Update: &quot;</span> + myTime, <span class="dv">10</span>, <span class="dv">382</span>)</code></pre>
<p>Zum letzten Mal: Die APPID habe ich mir ausgedacht, mit dieser bekommt Ihr keine Daten von OpenWeatherMap.</p>
<p>Das Modul wirkt auf den ersten Blick schlimmer als es ist, denn eigentlich ist alles <em>straigforward</em>: Die Daten werden aus dem JSON-Objekt ausgelesen, dann wird ein String erzeugt und zum Schlu√ü wird dieser String mit Hilfe der <code>text()</code>-Funktion angezeigt.</p>
<p>So ist das Hauptprogramm wieder sehr kurz geraten:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> getWeatherData <span class="ch">import</span> getWeatherData, getNow

<span class="kw">def</span> setup():
    size(<span class="dv">600</span>, <span class="dv">400</span>)
    background(<span class="dv">0</span>)
    frame.setTitle (<span class="st">u&quot;J√∂rgs Wetterstation&quot;</span>)
    font = createFont(<span class="st">&quot;American Typewriter&quot;</span>, <span class="dv">18</span>)
    textFont(font)
    getWeatherData()
    getNow()
    frameRate(<span class="dv">1</span>)

<span class="kw">def</span> draw():
    <span class="kw">if</span>(second() == <span class="dv">0</span>):
        background(<span class="dv">0</span>)
        getWeatherData()
        getNow()</code></pre>
<p>In der <code>setup()</code>-Funktion rufe ich zu Initialisierung genau einmal die Wetterdaten ab. Nun darf man in der kostenlosen Lizenz die Daten maximal 60 mal in der Minute abrufen. Mit <code>frameRate(1)</code> alleine schafft man das nicht (ich habe sie auch nur darauf gesetzt, um den Rechner nicht unn√∂tig zu belasten). Darum werden die weiteren Abfragen nur gestartet, wenn die Sekunde auf Null steht, das hei√üt es gibt nur einen Aufruf in der Minute. Damit habe ich die Lizenz der API mehr als eingehalten.</p>
<p>Eigentlich k√∂nnte man die Daten noch seltener abrufen: Die von mir angefragte Station <em>Berlin Tempelhof</em> gibt nur jede halbe Stunde (um x:20 Uhr und um x:50 Uhr) ihre Daten weiter und es kann noch bis zu einer weiteren halben Stunde dauern, bis die Daten bei OpenWeatherMap eingepflegt und abrufbar sind. Im schlimmsten Fall kann es zu Verz√∂gerungen bis zu einer Stunde kommen, manchmal sind die neuen Daten aber auch √ºberraschend schnell da.</p>
<p>Sicher kann man die Wetterstation optisch noch ein wenig aufpeppen und man kann auch mehrere Wetterstationen abfragen oder die API zur Wettervorhersage nutzen, aber als Beispiel, wie man JSON-Daten per API aus dem Netz holt und aufbereitet, ist dieser Sketch v√∂llig ausreichend. Alles weitere bleibt der Phantasie meiner Leserinnen und Leser √ºberlassen.</p>
<h1 id="wordcram-processing.py-und-eine-processing-java-bibliothek">WordCram: Processing.py und eine Processing (Java) Bibliothek</h1>
<figure>
<img src="images/wordcram.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Wie man eine Python-Bibliothek in Processing.py nutzt, <a href="weather.md">hatte ich ja schon gezeigt</a>. Das geht so einfach, wie man es auch von ¬ªnormalen¬´ Python-Programmen gewohnt ist -- solange die Pakete <em>pure Python</em> sind. Doch wie sieht es aus, wenn man eine Bibliothek nutzen will, die f√ºr den Java-Mode von Processing in Java geschrieben wurde? Um dies zu testen, hatte ich mir die Bibliothek <a href="http://wordcram.org/">WordCram</a>, die die beliebten Wortwolken <em>(Word Clouds)</em> erzeugt, ausgesucht und heruntergeladen. Bevor man damit irgendetwas anstellen kann, mu√ü man die Bibliothek entpacken und in den <code>libraries</code>-Ordner im Processing-Verzeichnis ablegen. Falls Ihr nicht mehr wi√üt, wo Euer Processing-Verzeichnis liegt, findet Ihr es im Processing-Men√º unter <code>Einstellungen -&gt; Sketchbook Pfad</code>.</p>
<figure>
<img src="images/sketchbookpfad.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Da ich von mehreren Rechnern an mehreren Standorten meine Processing.py-Sketche bearbeite, liegt dieser Ordner bei mir in der Dropbox. Das ist nicht unbedingt immer eine gute Idee, manche Libraries bestehen aus Tausenden von Dateien und da kann das Synchronisieren schon mal eine gewisse Zeit in Anspruch nehmen.</p>
<figure>
<img src="images/libraryhinzufuegen.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Wenn Ihr dies erledigt habt, findet die Processing-IDE unter <code>Sketch -&gt; Library importieren</code> die Bibliothek und sie kann mit einem Klick in Euren Sketch eingef√ºgt werden:</p>
<pre class="sourceCode python"><code class="sourceCode python">add_library(<span class="st">&#39;WordCram&#39;</span>)</code></pre>
<p>Nat√ºrlich k√∂nnt Ihr diese Zeile auch einfach selber eintippen.</p>
<p>Um das Teil zu testen, habe ich diesen kleinen Sketch geschrieben:</p>
<pre class="sourceCode python"><code class="sourceCode python">add_library(<span class="st">&#39;WordCram&#39;</span>)

<span class="kw">def</span> setup():
    size(<span class="dv">700</span>, <span class="dv">400</span>)
    background(<span class="dv">255</span>)
    
    wordcram = WordCram(this
        ).fromWebPage(<span class="st">&quot;http://blog.schockwellenreiter.de/2017/04/2017040404.html&quot;</span>
        ).sizedByWeight(<span class="dv">0</span>, <span class="dv">150</span>
        ).withFont(<span class="st">&quot;Copse&quot;</span>
        )
    wordcram.drawAll()</code></pre>
<p>Der ruft <a href="http://blog.schockwellenreiter.de/2017/04/2017040404.html">diese Seite</a> auf und stellt ihren Inhalt -- wie obiger Screenshot zeigt -- als Wortwolke dar.</p>
<p>Zwei Dinge sind noch zu beachten: Erstens verlangen viele Processing (Java) Bibliotheken eine Referenz auf das aktuelle PApplet-Objekt -- so auch WordCram. Im Java-Mode f√ºr Processing wird daf√ºr das eingebaute <code>this</code>-Keyword verwendet. Python allerdings kennt kein <code>this</code>-Schl√ºsselwort, aber Processing.py stellt automatisch eine globale Variable namens <code>this</code> zur Verf√ºgung, die f√ºr diese Zwecke verwendet werden kann.</p>
<p>Zweitens kann man in Python wegen der besonderen Bedeutung der Einr√ºckung nicht so, wie es in Java √ºblich ist, die fortlaufende Punkt-Notierung an dem Punkt umbrechen, wenn Ihr es so versucht</p>
<pre class="sourceCode python"><code class="sourceCode python">    wordcram = WordCram(this)
        .fromWebPage(<span class="st">&quot;http://blog.schockwellenreiter.de/2017/04/2017040404.html&quot;</span>)
        .sizedByWeight(<span class="dv">0</span>, <span class="dv">150</span>)
        .withFont(<span class="st">&quot;Copse&quot;</span>)</code></pre>
<p>bekommt Ihr eine Fehlermeldung. Ich habe daher √ºberall die schlie√üende Klammer aus der dar√ºberliegenden Zeile weggenommen und vor den Punkt gestellt. Das ist nicht wirklich eine sch√∂ne L√∂sung, funktioniert aber und h√§lt den Code einigerma√üen leserlich. Vielleicht f√§llt mir daf√ºr noch eine sch√∂nere L√∂sung ein.</p>
<p>Die WordCram-Bibliothek ist ziemlich m√§chtig, aber leider nicht besonders gut dokumentiert. Sie erkennt zum Beispiel selbstst√§ndig, da√ü mein Text auf Deutsch geschrieben ist und ist auch UTF-8-fest. Zudem scheint sie f√ºr viele Sprachen schon eine eingebaute Liste von Stopw√∂rtern mitzubringen. Und man kann auch irgendwie die W√∂rter der Cloud einf√§rben, aber das ist nicht sehr intuitiv und die bisher erzielten Ergebnisse hatten mir nicht gefallen, so da√ü ich es bei der schwarz-wei√ü-Darstellung belassen habe. <em>Still digging!</em></p>
<h1 id="running-orc-mit-processing.py">Running Orc mit Processing.py</h1>
<p>Nach den vier Tutorials mit den Figuren aus <em>Cute Planet</em> zu Processing.py, dem Python-Mode f√ºr Processing, wurde mir das allm√§hlich zu niedlich und ich beschlo√ü, endlich mal wieder einen Ork durch das Bildschirmfenster wuseln zu lassen.</p>
<figure>
<img src="images/runningorcpy-s.jpg" alt="Schon wieder ein rennender Ork" /><figcaption>Schon wieder ein rennender Ork</figcaption>
</figure>
<p>Daf√ºr habe ich erst einmal die Klasse <code>orc()</code> definiert und nach der Initialisierung -- wie in den anderen Tutorials auch schon -- die Methoden <code>loadPics()</code>, <code>move()</code> und <code>display()</code> implementiert:</p>
<pre class="{python}"><code>class Orc():

    def __init__(self, posX, posY):
        self.x = posX
        self.y = posY
        self.dy = 0

    def loadPics(self):
        self.orc1 = loadImage(&quot;orc1.png&quot;)
        self.orc2 = loadImage(&quot;orc2.png&quot;)
        self.orc3 = loadImage(&quot;orc3.png&quot;)
    
    def move(self):
        self.y += self.dy
        if self.y &gt;= height + 48:
            self.y = -48
            self.x = random(width-48)
    
    def display(self):
        if frameCount % 4 == 1:
            image(self.orc1, self.x, self.y)
        elif frameCount % 4 == 3:
            image(self.orc3, self.x, self.y)
        else:
            image(self.orc2, self.x, self.y)</code></pre>
<p>Die Figur des <em>Orcs</em> hatte ich ja schon h√§ufiger verwendet, die Zeichnungen stammen aus dem freien (<a href="https://github.com/silveira/openpixels/blob/master/LICENSE">CC-BY-SA</a>) <a href="https://github.com/silveira/openpixels">OpenPixels</a>-Projekt von <a href="http://silveiraneto.net/tag/pixelart/">Silveira Neto</a>. Der Einfachheit halber und damit Ihr das nachprogrammieren k√∂nnt, habe ich die drei animierten Bildchen hier noch einmal eingebunden:</p>
<p><img src="images/orc1.png" alt="Ork 1" /> <img src="images/orc2.png" alt="Ork 2" /> <img src="images/orc3.png" alt="Ork 3" /></p>
<p>Das Hauptskript war dank des Klasse <code>Orc()</code> dann wieder von erfrischender K√ºrze:</p>
<pre class="{python}"><code>from orcs import Orc

orc = Orc(160, -48)

def setup():
    global bg
    bg = loadImage(&quot;field.png&quot;)
    frameRate(15)
    size(320, 320)
    orc.loadPics()
    orc.dy = 5
    
def draw():
    background(bg)
    orc.move()
    orc.display()</code></pre>
<p>In <code>setup()</code> habe ich zuerst das Hintergrundbild eingebunden (es ist ebenfalls aus dem oben erw√§hnten OpenPixels-Projekt -- Ihr k√∂nnt alternativ aber auch einfach einen gr√ºnen Hintergrund zeichnen) und dann den Orc angewiesen, seine Bilder zu laden. Und wie in den vorhergegangenen Tutorials auch wird in <code>draw()</code> zuerst der Hintergrund gezeichnet, dann der Ork bewegt und schlie√ülich an seiner neuen Position angezeigt. <em>That's all!</em></p>
<p>Wie es damit weitergeht, wei√ü ich noch nicht so genau. Zum einen habe ich die Idee, ganz viele Instanzen der Orks √ºber das Spielfeld zu bewegem, eine andere Idee ist es, den Ork mittels der Pfeiltasten in alle vier Himmelsrichtungen laufen und auf Hindernisse reagieren zu lassen. Schauen wir mal ‚Ä¶</p>
<h2 id="running-orc-in-vier-richtungen">Running Orc in vier Richtungen</h2>
<p>Heute m√∂chte ich meine kleine Einf√ºhrung in Processing.py, dem Python-Mode f√ºr Processing, damit fortsetzen, da√ü ich einen kleinen Ork unter Benutzerf√ºhrung und mit Hilfe der Pfeiltasten in allen vier Himmelsrichtungen √ºber die Spielwiese wuseln lasse. Die Grundlagen hatte ich daf√ºr ja schon im [hier][4] gelegt, der Unterschied aber ist, da√ü der kleine Ork sich tats√§chlich bewegt und auch in alle Richtungen dreht. Daf√ºr brauchte ich erst einmal diese acht Bildchen des kleinen Monsters:</p>
<p><img src="images/orcbk1.gif" alt="Ork" /> <img src="images/orcbk2.gif" alt="Ork" /> <img src="images/orcfr1.gif" alt="Ork" /> <img src="images/orcfr2.gif" alt="Ork" /> <img src="images/orclf1.gif" alt="Ork" /> <img src="images/orclf2.gif" alt="Ork" /> <img src="images/orcrt1.gif" alt="Ork" /> <img src="images/orcrt2.gif" alt="Ork" /></p>
<p>Im Gegensatz zu dem Ork aus dem letzten Tutorial stammen diese Bildchen (bis auf die Hintergrund-Wiese) nicht aus dem <a href="https://github.com/silveira/openpixels">OpenPixels</a>-Fundus von <a href="http://silveiraneto.net/tag/pixelart/">Silveira Neto</a>, sondern aus der ebenfalls freien (<a href="https://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>) <a href="http://blogoscoped.com/archive/2006-08-08-n51.html">Sprite-Sammlung</a> von <em>Philipp Lenssen</em> (√ºber 700 animierte Avatare in der klassischen Gr√∂√üe von 32x32 Pixeln). Und die Animationen setzen sich auch nur aus je zwei verschiedenen Bildchen zusammen, was zum einen Code und Speicher spart und zum anderen den Charakteren einen besonders wuseligen Eindruck verschafft, der an die Fr√ºhzeit der Computerspiele erinnert (aus der die Bilder auch stammen). üòá Man ben√∂tigt so f√ºr jede der vier Himmelsrichtungen nur zwei Bilder, was dann zusammen obige acht Bildchen ergibt.</p>
<p>Als erstes habe ich dem Ork nat√ºrlich wieder eine eigene Klasse spendiert (in dem Tab/der Datei <code>orc2.py</code>), deren Quellcode nun schon bedeutend umfangreicher geworden ist:</p>
<pre class="{python}"><code>class Orc():

    def __init__(self, posX, posY):
        self.x = posX
        self.y = posY
        self.dir = 1
        self.dx = 0
        self.dy = 0

    def loadPics(self):
        self.orcrt1 = loadImage(&quot;orcrt1.gif&quot;)
        self.orcrt2 = loadImage(&quot;orcrt2.gif&quot;)
        self.orcfr1 = loadImage(&quot;orcfr1.gif&quot;)
        self.orcfr2 = loadImage(&quot;orcfr2.gif&quot;)
        self.orclf1 = loadImage(&quot;orclf1.gif&quot;)
        self.orclf2 = loadImage(&quot;orclf2.gif&quot;)
        self.orcbk1 = loadImage(&quot;orcbk1.gif&quot;)
        self.orcbk2 = loadImage(&quot;orcbk2.gif&quot;)
    
    def move(self):
        if self.dir == 0:
            if self.x &gt;= width - 32:
                self.x = width - 32
                self.image1 = self.orcrt2
                self.image2 = self.orcrt2
            else:
                self.x += self.dx
                self.image1 = self.orcrt1
                self.image2 = self.orcrt2
        elif self.dir == 1:
            if self.y &gt;= height - 32:
                self.y = height - 32
                self.image1 = self.orcfr2
                self.image2 = self.orcfr2
            else:
                self.y += self.dy
                self.image1 = self.orcfr1
                self.image2 = self.orcfr2
        elif self.dir == 2:
            if self.x &lt;= 0:
                self.x = 0
                self.image1 = self.orclf2
                self.image2 = self.orclf2
            else:
                self.x -= self.dx
                self.image1 = self.orclf1
                self.image2 = self.orclf2
        elif self.dir == 3:
            if self.y &lt;= 0:
                self.y = 0
                self.image1 = self.orcbk2
                self.image2 = self.orcbk2
            else:
                self.y -= self.dy
                self.image1 = self.orcbk1
                self.image2 = self.orcbk2
    
    def display(self):
        if frameCount % 8 &gt;= 4:
            image(self.image1, self.x, self.y)
        else:
            image(self.image2, self.x, self.y)</code></pre>
<p>Im Konstruktor werden nur die Startposition festgelegt und ein paar Variblen initialisiert und mit Default-Werten versehen. Danach werden die acht Bildchen geladen. Die eigentliche Logik liegt in der Funktion <code>move()</code>: Erreicht der Orc einer der Fensterr√§nder, bleibt er einfach stehen. Der visuelle Eindruck wird dadurch erreicht, da√ü die beiden zu swappenden Bilder identisch sind. Ansonsten bewegt er sich in der angesagten Richtung weiter, indem <code>dx</code> oder <code>dy</code> zu der akutellen Position addiert oder abgezogen werden.</p>
<p>Die Funktion <code>display()</code> ist dann f√ºr die Darstellung zust√§ndig: Ist der <code>frameCount % 8 &gt;= 4</code>, dann wird das erste Bild gezeichnet, ansonsten das zweite Bild. Durch diesen Modulo-Trick bin ich noch einmal daran vorbeigekommen, einen Timer implementieren zu m√ºssen, aber irgendwann wird kein Weg mehr daran vorbeif√ºhren.</p>
<figure>
<img src="images/runningorcs6.jpg" alt="Running Orc 4" /><figcaption>Running Orc 4</figcaption>
</figure>
<p>Das Hauptprogramm ist immer noch vergleichsweise kurz und √ºbersichtlich geraten:</p>
<pre class="{python}"><code>from orc2 import Orc

orc = Orc(160, -32)


def setup():
    global bg
    bg = loadImage(&quot;field.png&quot;)
    frameRate(30)
    size(320, 320)
    orc.loadPics()
    orc.dx = 2
    orc.dy = 2
    
def draw():
    background(bg)
    orc.move()
    orc.display()
    
def keyPressed():
    if keyPressed and key == CODED:
        if keyCode == RIGHT:
            orc.dir = 0
        elif keyCode == DOWN:
            orc.dir = 1
        elif keyCode == LEFT:
            orc.dir = 2
        elif keyCode == UP:
            orc.dir = 3</code></pre>
<p>Die Klasse <code>Orc</code> wird importiert und initialisiert. Danach wird das Hintergrundbild geladen (Ihr k√∂nnt auch hier wieder alternativ einfach einen gr√ºnen Hintergrund zeichnen) und die Fenstergr√∂√üe festgelegt. Dann wird die Funktion <code>orc.loadPics()</code> aufgerufen und die horizontale und vertikale Geschwindigkeit auf je zwei Pixel pro Frame-Durchlauf bestimmt.</p>
<p>Die <code>draw()</code>-Routine ist immer noch einfach: Erst wird der Hintergrund gezeichnet, dann der Ork bewegt und danach ebenfalls in das Fenster gezeichnet.</p>
<p>Neu ist die Funktion <code>keyPressed()</code>, die w√§hrend des gesamten Programmablaufs die Tastatur √ºberwacht. Sie √ºberpr√ºft, welche der Pfeiltasten gedr√ºckt wurden und weist ihnen dementsrpechend eine Himmelsrichtung zu. Per Konvention f√§ngt man normalerweise im Osten an (<code>orc.dir = 0</code>), um dann √ºber den S√ºden (<code>orc.dir = 1</code>) und den Westen (<code>orc.dir = 2</code>) zum Norden (<code>orc.dir = 3</code>) zu gelangen.</p>
<p>Beachtet bitte, da√ü die Abfrage der Tastatur erst greift, wenn das Programmfenster den Fokus besitzt. Leider passiert das bei Processing.py nicht automatisch beim Programmstart, Ihr m√º√üt einmal mit der Maus in das Fenster klicken.</p>
<p>Das ist alles. Erfreut Euch auch an dem kleinen Gag, den <em>Philipp Lenssen</em> seinem Ork verpa√üt hat: Das Haarschw√§nzchen wedelt fr√∂hlich hin und her.</p>
<h2 id="ork-mit-kollisionserkennung">Ork mit Kollisionserkennung</h2>
<p>Nachdem ich im letzten Abschnitt gezeigt hatte, wie man einen kleinen Ork mit Hilfe der Pfeiltasten in allen vier Himmelsrichtungen √ºber das Bildschirmfenster jagen kann, bis er am Fensterrand stehenbleibt, m√∂chte ich Euch nun zeigen, wie man eine generelle Kollisionserkennung implementiert. Daf√ºr habe ich erst einmal eine Oberklasse namens <code>Sprite</code> eingef√ºhrt, die das Verhalten, das allen <em>Sprites</em> gemein ist, festlegt und von der alle Sprites erben sollen (zur Bedeutung und Herkunft des Begriffs <a href="https://de.wikipedia.org/wiki/Sprite_(Computergrafik)">Sprite</a> informiert die Wikipedia).</p>
<figure>
<img src="images/orkmitkollisionserkennung.png" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Die Klasse <code>Sprite</code> sieht in <a href="cp^processingpy">Processing.py</a> erst einmal so aus:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Sprite(<span class="dt">object</span>):

    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY
        <span class="ot">self</span>.<span class="dt">dir</span> = <span class="dv">1</span>
        <span class="ot">self</span>.dx = <span class="dv">0</span>
        <span class="ot">self</span>.dy = <span class="dv">0</span>
    
    <span class="kw">def</span> checkCollision(<span class="ot">self</span>, otherSprite):
        <span class="kw">if</span> (<span class="ot">self</span>.x &lt; otherSprite.x + tw and otherSprite.x &lt; <span class="ot">self</span>.x + tw
            and <span class="ot">self</span>.y &lt; otherSprite.y + th and otherSprite.y &lt; <span class="ot">self</span>.y + th):
            println(<span class="st">&quot;Kollision&quot;</span>)
            <span class="kw">return</span> <span class="ot">True</span>
        <span class="kw">else</span>:
            <span class="kw">return</span> <span class="ot">False</span></code></pre>
<p>Das Objekt wird initialisiert und die Startposition festgelegt. Dann werden noch ein paar Variablen mit Defaultwerten besetzt. Da es durchaus Sprites geben kann, die sich gar nicht bewegen, sind <code>dx</code> und <code>dy</code> mit <code>0</code> vorbelegt.</p>
<p>Momentan die wichtigste Funktion ist die Funktion <code>checkCollision(self, otherSprite)</code>. Darin wird gepr√ºft, ob sich die umgebenden Rechtecke der Sprites (in diesem Falle ist das die Bildgr√∂√üe (<code>tw</code> und <code>th</code> sind jeweils 32 Pixel) √ºberlappen, denn dann liegt eine Kollision vor. Dazu ist es f√ºr eine einigerma√üen ¬ªrealistische¬´ Darstellung nat√ºrlich wichtig, da√ü die Sprite-Zeichnung das Rechteck m√∂glichst vollst√§ndig ausf√ºllt. In diesem Falle nehme ich das einfach mal an (mehr dazu weiter unten). Die Klasse <code>Orc</code> erbt nun nat√ºrlich von <code>Sprite</code>:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Orc(Sprite):

    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.orcrt1 = loadImage(<span class="st">&quot;orcrt1.gif&quot;</span>)
        <span class="ot">self</span>.orcrt2 = loadImage(<span class="st">&quot;orcrt2.gif&quot;</span>)
        <span class="ot">self</span>.orcfr1 = loadImage(<span class="st">&quot;orcfr1.gif&quot;</span>)
        <span class="ot">self</span>.orcfr2 = loadImage(<span class="st">&quot;orcfr2.gif&quot;</span>)
        <span class="ot">self</span>.orclf1 = loadImage(<span class="st">&quot;orclf1.gif&quot;</span>)
        <span class="ot">self</span>.orclf2 = loadImage(<span class="st">&quot;orclf2.gif&quot;</span>)
        <span class="ot">self</span>.orcbk1 = loadImage(<span class="st">&quot;orcbk1.gif&quot;</span>)
        <span class="ot">self</span>.orcbk2 = loadImage(<span class="st">&quot;orcbk2.gif&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="kw">if</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">0</span>:
            <span class="kw">if</span> <span class="ot">self</span>.x &gt;= width - tileSize:
                <span class="ot">self</span>.x = width - tileSize
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcrt2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcrt2
            <span class="kw">else</span>:
                <span class="ot">self</span>.x += <span class="ot">self</span>.dx
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcrt1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcrt2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">1</span>:
            <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height - tileSize:
                <span class="ot">self</span>.y = height - tileSize
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcfr2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcfr2
            <span class="kw">else</span>:
                <span class="ot">self</span>.y += <span class="ot">self</span>.dy
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcfr1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcfr2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">2</span>:
            <span class="kw">if</span> <span class="ot">self</span>.x &lt;= <span class="dv">0</span>:
                <span class="ot">self</span>.x = <span class="dv">0</span>
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orclf2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orclf2
            <span class="kw">else</span>:
                <span class="ot">self</span>.x -= <span class="ot">self</span>.dx
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orclf1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orclf2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">3</span>:
            <span class="kw">if</span> <span class="ot">self</span>.y &lt;= <span class="dv">0</span>:
                <span class="ot">self</span>.y = <span class="dv">0</span>
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcbk2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcbk2
            <span class="kw">else</span>:
                <span class="ot">self</span>.y -= <span class="ot">self</span>.dy
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcbk1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcbk2
                
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> frameCount % <span class="dv">8</span> &gt;= <span class="dv">4</span>:
            image(<span class="ot">self</span>.image1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">else</span>:
            image(<span class="ot">self</span>.image2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)</code></pre>
<p>hat sich aber ansonsten gegen√ºber dem letzten Tutorial nicht ver√§ndert. Da ja nun die Kollisions√ºberpr√ºfung getestet werden mu√ü, habe ich ein weiteres, unbewegliches Sprite konstruiert, das ich aus naheliegenden Gr√ºnden <code>Wall</code> genannt habe. Auch <code>Wall</code> erbt nat√ºrlich von <code>Sprite</code>:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Wall(Sprite):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.pic = loadImage(<span class="st">&quot;wall.png&quot;</span>)
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.pic, <span class="ot">self</span>.x, <span class="ot">self</span>.y)</code></pre>
<p>Da sich die Mauer nicht bewegt, besitzt <code>Wall</code> bat√ºrlich auch keine <code>move()</code>-Methode, sondern wird nur angezeigt. Ganz oben in die ersten drei Zeilen des Tabs <code>sprites.py</code> habe noch ein paar Konstanten initialisiert:</p>
<pre class="sourceCode python"><code class="sourceCode python">tw = <span class="dv">32</span>
th = <span class="dv">32</span>
tileSize = <span class="dv">32</span></code></pre>
<p>Das war erst einmal das Modul <code>sprites.py</code>. Das Hauptprogramm, das ich <code>obstacles</code> genannt habe, ist immer noch von erfrischender K√ºrze und dank der Objekte kaum ver√§ndert:</p>
<pre class="sourceCode python"><code class="sourceCode python">tileSize = <span class="dv">32</span>

<span class="ch">from</span> sprites <span class="ch">import</span> Orc, Wall

<span class="kw">def</span> setup():
    <span class="kw">global</span> bg
    bg = loadImage(<span class="st">&quot;field.png&quot;</span>)
    frameRate(<span class="dv">30</span>)
    size(<span class="dv">320</span>, <span class="dv">320</span>)
    <span class="kw">global</span> orc
    orc = Orc(<span class="dv">8</span>*tileSize, <span class="dv">0</span>)
    orc.loadPics()
    orc.dx = <span class="dv">2</span>
    orc.dy = <span class="dv">2</span>
    <span class="kw">global</span> wall1
    wall1 = Wall(<span class="dv">5</span>*tileSize, <span class="dv">3</span>*tileSize)
    wall1.loadPics()

<span class="kw">def</span> draw():
    <span class="kw">global</span> moving
    background(bg)
    wall1.display()
    orc.move()
    orc.display()
    orc.checkCollision(wall1)
         
    
<span class="kw">def</span> keyPressed():
    <span class="kw">if</span> keyPressed and key == CODED:
        <span class="kw">if</span> keyCode == RIGHT:
            orc.<span class="dt">dir</span> = <span class="dv">0</span>
        <span class="kw">elif</span> keyCode == DOWN:
            orc.<span class="dt">dir</span> = <span class="dv">1</span>
        <span class="kw">elif</span> keyCode == LEFT:
            orc.<span class="dt">dir</span> = <span class="dv">2</span>
        <span class="kw">elif</span> keyCode == UP:
            orc.<span class="dt">dir</span> = <span class="dv">3</span></code></pre>
<p>Neu ist lediglich das Mauerfragment <code>wall1</code> und das nun als letztes in der <code>draw()</code>-Funktion mit <code>orc.checkCollision(wall1)</code> √ºberpr√ºft wird, ob unser Ork mit der Mauer kollidiert. Im Falle einer Kollision wird bisher allerdings lediglich ¬ªKollision¬´ in das Terminalfenster geschrieben. Das zeigt, da√ü der Algorithmus funktioniert, mehr aber noch nicht.</p>
<p>Um dies zu √§ndern, habe ich erst einmal das <code>println(&quot;Kollision&quot;)</code> in der Klasse <code>Sprite</code> gel√∂scht und -- um auf ein Problem aufmerksam zu machen -- die Klasse <code>Tree</code> als weiteres, unbewegliches Objekt hinzugef√ºgt:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Tree(Sprite):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.pic = loadImage(<span class="st">&quot;tree.png&quot;</span>)
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.pic, <span class="ot">self</span>.x, <span class="ot">self</span>.y)</code></pre>
<p>Bis auf das andere Bildchen unterscheidet sie sich nicht von der Klasse <code>Wall</code>. Baum und Mauer (sowie die neue Hintergrundkachel) habe ich dem freien (<a href="https://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>) Angband-Tilesets von <a href="http://pousse.rapiere.free.fr/tome/">dieser Site</a> entnommen und mit dem Editor <a href="cp^Tiled">Tiled</a> zurechtgeschnitten. Hier die Bildchen auch f√ºr Euch, damit Ihr das Beispiel nachprogrammieren k√∂nnt:</p>
<p><img src="images/grass.png" alt="Gras" /> <img src="images/tree.png" alt="Baum" /> <img src="images/wall.png" alt="Mauer" /></p>
<p>Das Hintergrundbild habe ich in <em>Tiled</em> aus der Graskachel erzeugt. Die Bilder des Orks k√∂nnt Ihr im letzten Abschnitt finden.</p>
<p>Die Datei im Tab <code>sprites.py</code> hat sich sonst nicht weiter ver√§ndert, aber eine wesentliche Ver√§nderung hat im Hauptprogramm stattgefunden. Hier hei√üt es nun zwischen <code>orc.move()</code> und <code>orc.display()</code>:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">if</span> orc.checkCollision(wall1) or orc.checkCollision(tree1):
        <span class="kw">if</span> orc.<span class="dt">dir</span> == <span class="dv">0</span>:
            orc.x -= orc.dx
        <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">1</span>:
            orc.y -= orc.dy
        <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">2</span>:
            orc.x += orc.dx
        <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">3</span>:
            orc.y += orc.dy
        orc.image1 = orc.image2</code></pre>
<p>Jetzt wird also √ºberpr√ºft, ob eine Kollision mit dem Mauerfragment oder mit dem Baum stattgefunden hat. Hat eine stattgefunden, wird der Orc einfach auf die vorherige Position zur√ºckgesetzt und die beiden Bilder -- wie wir es schon mit der Kollision mit den R√§ndern hatten -- auf ein Bild gesetzt, so da√ü es aussieht, als ob der Ork stehen bleiben w√ºrde und auf Eure n√§chste Eingabe wartet.</p>
<p>Hier nun den kompletten Sketch zum Nachbauen. Erst einmal das Hauptprogramm <code>obstacles02</code>:</p>
<pre class="sourceCode python"><code class="sourceCode python">tileSize = <span class="dv">32</span>
<span class="ch">from</span> sprites <span class="ch">import</span> Orc, Wall, Tree

<span class="kw">def</span> setup():
    <span class="kw">global</span> bg
    bg = loadImage(<span class="st">&quot;ground0.png&quot;</span>)
    frameRate(<span class="dv">30</span>)
    size(<span class="dv">320</span>, <span class="dv">320</span>)
    <span class="kw">global</span> orc
    orc = Orc(<span class="dv">8</span>*tileSize, <span class="dv">0</span>)
    orc.loadPics()
    orc.dx = <span class="dv">2</span>
    orc.dy = <span class="dv">2</span>
    <span class="kw">global</span> wall1
    wall1 = Wall(<span class="dv">5</span>*tileSize, <span class="dv">3</span>*tileSize)
    wall1.loadPics()
    <span class="kw">global</span> tree1
    tree1 = Tree(<span class="dv">3</span>*tileSize, <span class="dv">7</span>*tileSize)
    tree1.loadPics()

<span class="kw">def</span> draw():
    background(bg)
    wall1.display()
    tree1.display()
    orc.move()
    <span class="kw">if</span> orc.checkCollision(wall1) or orc.checkCollision(tree1):
        <span class="kw">if</span> orc.<span class="dt">dir</span> == <span class="dv">0</span>:
            orc.x -= orc.dx
        <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">1</span>:
            orc.y -= orc.dy
        <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">2</span>:
            orc.x += orc.dx
        <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">3</span>:
            orc.y += orc.dy
        orc.image1 = orc.image2
        
    orc.display()
         
    
<span class="kw">def</span> keyPressed():
    <span class="kw">if</span> keyPressed and key == CODED:
        <span class="kw">if</span> keyCode == RIGHT:
            orc.<span class="dt">dir</span> = <span class="dv">0</span>
        <span class="kw">elif</span> keyCode == DOWN:
            orc.<span class="dt">dir</span> = <span class="dv">1</span>
        <span class="kw">elif</span> keyCode == LEFT:
            orc.<span class="dt">dir</span> = <span class="dv">2</span>
        <span class="kw">elif</span> keyCode == UP:
            orc.<span class="dt">dir</span> = <span class="dv">3</span></code></pre>
<p>Und dann das Modul <code>sprites.py</code>, das ich in einem separaten Tab untergebracht habe:</p>
<pre class="sourceCode python"><code class="sourceCode python">tw = <span class="dv">32</span>
th = <span class="dv">32</span>
tileSize = <span class="dv">32</span>

<span class="kw">class</span> Sprite(<span class="dt">object</span>):

    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY
        <span class="ot">self</span>.<span class="dt">dir</span> = <span class="dv">1</span>
        <span class="ot">self</span>.dx = <span class="dv">0</span>
        <span class="ot">self</span>.dy = <span class="dv">0</span>
    
    <span class="kw">def</span> checkCollision(<span class="ot">self</span>, otherSprite):
        <span class="kw">if</span> (<span class="ot">self</span>.x &lt; otherSprite.x + tw and otherSprite.x &lt; <span class="ot">self</span>.x + tw
            and <span class="ot">self</span>.y &lt; otherSprite.y + th and otherSprite.y &lt; <span class="ot">self</span>.y + th):
            <span class="kw">return</span> <span class="ot">True</span>
        <span class="kw">else</span>:
            <span class="kw">return</span> <span class="ot">False</span>

<span class="kw">class</span> Orc(Sprite):

    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.orcrt1 = loadImage(<span class="st">&quot;orcrt1.gif&quot;</span>)
        <span class="ot">self</span>.orcrt2 = loadImage(<span class="st">&quot;orcrt2.gif&quot;</span>)
        <span class="ot">self</span>.orcfr1 = loadImage(<span class="st">&quot;orcfr1.gif&quot;</span>)
        <span class="ot">self</span>.orcfr2 = loadImage(<span class="st">&quot;orcfr2.gif&quot;</span>)
        <span class="ot">self</span>.orclf1 = loadImage(<span class="st">&quot;orclf1.gif&quot;</span>)
        <span class="ot">self</span>.orclf2 = loadImage(<span class="st">&quot;orclf2.gif&quot;</span>)
        <span class="ot">self</span>.orcbk1 = loadImage(<span class="st">&quot;orcbk1.gif&quot;</span>)
        <span class="ot">self</span>.orcbk2 = loadImage(<span class="st">&quot;orcbk2.gif&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="kw">if</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">0</span>:
            <span class="kw">if</span> <span class="ot">self</span>.x &gt;= width - tileSize:
                <span class="ot">self</span>.x = width - tileSize
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcrt2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcrt2
            <span class="kw">else</span>:
                <span class="ot">self</span>.x += <span class="ot">self</span>.dx
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcrt1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcrt2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">1</span>:
            <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height - tileSize:
                <span class="ot">self</span>.y = height - tileSize
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcfr2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcfr2
            <span class="kw">else</span>:
                <span class="ot">self</span>.y += <span class="ot">self</span>.dy
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcfr1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcfr2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">2</span>:
            <span class="kw">if</span> <span class="ot">self</span>.x &lt;= <span class="dv">0</span>:
                <span class="ot">self</span>.x = <span class="dv">0</span>
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orclf2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orclf2
            <span class="kw">else</span>:
                <span class="ot">self</span>.x -= <span class="ot">self</span>.dx
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orclf1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orclf2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">3</span>:
            <span class="kw">if</span> <span class="ot">self</span>.y &lt;= <span class="dv">0</span>:
                <span class="ot">self</span>.y = <span class="dv">0</span>
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcbk2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcbk2
            <span class="kw">else</span>:
                <span class="ot">self</span>.y -= <span class="ot">self</span>.dy
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcbk1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcbk2
                
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> frameCount % <span class="dv">8</span> &gt;= <span class="dv">4</span>:
            image(<span class="ot">self</span>.image1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">else</span>:
            image(<span class="ot">self</span>.image2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
            
<span class="kw">class</span> Wall(Sprite):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.pic = loadImage(<span class="st">&quot;wall.png&quot;</span>)
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.pic, <span class="ot">self</span>.x, <span class="ot">self</span>.y)

<span class="kw">class</span> Tree(Sprite):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.pic = loadImage(<span class="st">&quot;tree.png&quot;</span>)
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.pic, <span class="ot">self</span>.x, <span class="ot">self</span>.y)</code></pre>
<p>Wenn Ihr nun ein wenig damit herumspielt, werdet Ihr eine kleine Ungenauigkeit bemerken. N√§hert sich der Ork von rechts oder von links der Tanne, dann sieht es so aus, als ob er ziemlich weit davor stehenbleiben w√ºrde. Das liegt daran, da√ü sowohl die Seitenansichten des Ork wie auch die der Tanne die 32-Pixel Breite nicht besonders gut ausf√ºllen. Abhilfe k√∂nnte man schaffen, indem man die umgebenden Rechtecke schmaler macht. Das ist noch relativ einfach zu implementieren, macht den Quellcode aber dennoch komplizierter und un√ºbersichtlicher. Da ich aber erst einmal nur das Prinzip der Kollisionserkennung mit √ºberlappenden Rechtecken deutlich machen wollte, dachte ich, da√ü man im Sinne der Klarheit mit diesem kleinen Handicap leben kann.</p>
<h2 id="ein-ork-im-labyrinth">Ein Ork im Labyrinth</h2>
<p>Nachdem ich im letzten Abschnitt erfolgreich eine Kollisionserkennung implementiert hatte, wollte ich nun das alles auf die Spitze treiben und den kleinen Ork durch ein Labyrinth (genauer: einen Irrgarten) bewegen. Und nat√ºrlich sollte er nur dort laufen k√∂nnen, wo es keine Hindernisse gab. Im Endeffekt sollte das Ergebnis so aussehen:</p>
<figure>
<img src="images/labyrinthork.jpg" alt="Ein Ork im Labyrinth" /><figcaption>Ein Ork im Labyrinth</figcaption>
</figure>
<p>Die einzelnen Klassen im zweiten Reiter (<code>sprites2.py</code>) blieben gegen√ºber dem letzten Abschnitt nahezu unver√§ndert. Lediglich die Klasse <code>Tree</code> habe ich durch die Klasse <code>Lava</code> ersetzt und der Klasse <code>Wall</code> ein anderes Kachelbild verpa√üt, was aber beides nur kosmetische Gr√ºnde hat. Hier die notwendigen Kacheln:</p>
<p><img src="images/wall2.png" alt="Wall 2" /> <img src="images/lava.png" alt="Lava" /> <img src="images/grass.png" alt="Gras" /></p>
<p>Das Labyrinth habe ich in <a href="http://cognitiones.kantel-chaos-team.de/multimedia/spieleprogrammierung/tiled.html">Tiled</a> entworfen und die Bilder daf√ºr wieder dem freien (<a href="https://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>) Angband-Tilesets von <a href="http://pousse.rapiere.free.fr/tome/">dieser Site</a> entnommen.</p>
<p>Die gr√∂√üten √Ñnderungen gab es im Hauptprogramm. Zu den √ºblichen Vorbelegungen kam ein zweidimensionales Array <code>obstacles</code> hinzu. Dies habe ich mir zurechtgebastelt, in dem ich in <em>Tiled</em> das Tileset als CSV exportiert habe und dann in dem <a href="http://cognitiones.kantel-chaos-team.de/produktivitaet/textmate.html">Text-Editor meines Vertrauens</a> mit <em>Suchen und Ersetzen</em> die Zahlen ein wenig vereinfacht hatte:</p>
<pre class="sourceCode python"><code class="sourceCode python">obstacles = [[<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">9</span>],
             [<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>],
             [<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>],
             [<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>],
             [<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>],
             [<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>],
             [<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>],
             [<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">8</span>],
             [<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">8</span>],
             [<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">8</span>]]</code></pre>
<p>Wenn Ihr das mit dem Screenshot oben vergleicht, vermutet Ihr sicher sehr schnell, da√ü die 9 f√ºr ein Mauerst√ºck und die 8 f√ºr Lava steht, w√§hrend Null einfach der Fu√üboden ist. Dann habe ich den Ork und zwei leere Listen, die Mauer und Lava aufnehmen sollen, initialisiert:</p>
<pre class="sourceCode python"><code class="sourceCode python">orc = Orc(<span class="dv">8</span>*tilesize, <span class="dv">0</span>)
wall = []
lava = []</code></pre>
<p>Die <code>setup()</code>-Funktion sieht nun so aus:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    <span class="kw">global</span> bg
    bg = loadImage(<span class="st">&quot;ground0.png&quot;</span>)
    loadObstaclesData()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(wall)):
        wall[i].loadPics()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(lava)):
        lava[i].loadPics()
    frameRate(<span class="dv">30</span>)
    size(<span class="dv">320</span>, <span class="dv">320</span>)
    orc.loadPics()
    orc.dx = <span class="dv">2</span>
    orc.dy = <span class="dv">2</span></code></pre>
<p>Sie ruft die Funktion <code>loadObstaclesData()</code> auf, die f√ºr die Belegung der beiden Listen <code>wall</code> und <code>lava</code> zust√§ndig ist</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> loadObstaclesData():
    <span class="kw">for</span> y in <span class="dt">range</span>(<span class="dv">10</span>):
        <span class="kw">for</span> x in <span class="dt">range</span>(<span class="dv">10</span>):
            <span class="kw">if</span> obstacles[y][x] == <span class="dv">9</span>:
                wall.append(Wall(x*tilesize, y*tilesize))
            <span class="kw">elif</span> obstacles[y][x] == <span class="dv">8</span>:
                lava.append(Lava(x*tilesize, y*tilesize))</code></pre>
<p>und l√§dt anschlie√üend die entsprechenden Bilder f√ºr die Hindernisse.</p>
<p>In der <code>draw()</code>-Funktion wird erst das Hintergrundbild geladen, das nur aus einer gr√ºnen Grasfl√§che belegt und dann werden die einzelnen <em>Obstacles</em> eingezeichnet:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> draw():
    background(bg)
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(wall)):
        wall[i].display()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(lava)):
        lava[i].display()
    orc.move()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(wall)):
        <span class="kw">if</span> orc.checkCollision(wall[i]):
            <span class="kw">if</span> orc.<span class="dt">dir</span> == <span class="dv">0</span>:
                orc.x -= orc.dx
            <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">1</span>:
                orc.y -= orc.dy
            <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">2</span>:
                orc.x += orc.dx
            <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">3</span>:
                orc.y += orc.dy
            orc.image1 = orc.image2                            
    orc.display()</code></pre>
<p>Die Bewegung des Orcs wurde aus dem letzten Tutorial unver√§ndert √ºbernommen. Da der Ork niemals mit einem Lava-Feld kollidieren kann (er trifft immer vorher auf eine Mauer) reichte es, die Kollisions√ºberpr√ºfung auf die Mauerteile zu beschr√§nken.</p>
<p>Damit ist das Prinzip erkl√§rt, doch es geht noch einfacher. Denn man kann sich das Neuzeichnen der einzelnen Hindernisse bei jedem Durchlauf nat√ºrlich ersparen, wenn man sie in dem Hintergrundbild mit aufgenommen hat. Also habe ich das Hintergrundbild mit allen Mauern und dem Lava aus <em>Tiled</em> exportiert und als Hintergrund geladen. Dann sieht die Funktion <code>setup()</code> so aus:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setup():
    <span class="kw">global</span> bg
    bg = loadImage(<span class="st">&quot;ground.png&quot;</span>)
    loadObstaclesData()
    frameRate(<span class="dv">30</span>)
    size(<span class="dv">320</span>, <span class="dv">320</span>)
    orc.loadPics()
    orc.dx = <span class="dv">2</span>
    orc.dy = <span class="dv">2</span></code></pre>
<p>Statt <code>ground0.png</code> hei√üt das Hintergrundbild nun nur noch <code>ground.png</code> und enth√§lt nicht nur den Rasen, sondern das gesamte Labyrinth. Auch die <code>draw()</code>-Funktion ist um vier Zeilen k√ºrzer geworden:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> draw():
    background(bg)
    orc.move()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(wall)):
        <span class="kw">if</span> orc.checkCollision(wall[i]):
            <span class="kw">if</span> orc.<span class="dt">dir</span> == <span class="dv">0</span>:
                orc.x -= orc.dx
            <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">1</span>:
                orc.y -= orc.dy
            <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">2</span>:
                orc.x += orc.dx
            <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">3</span>:
                orc.y += orc.dy
            orc.image1 = orc.image2                            
    orc.display()</code></pre>
<p>Man erspart sich so die <code>laodPics()</code> wie auch die <code>display()</code>-Aufrufe der <em>Obstacle Sprites</em>, was auch einiges an Rechenzeit spart.</p>
<p>Zum Abschlu√ü das vollst√§ndige Programm. Zuerst das Paket <code>sprite2.py</code>, das ich in einem separaten Tab untergebracht habe:</p>
<pre class="sourceCode python"><code class="sourceCode python">tw = <span class="dv">32</span>
th = <span class="dv">32</span>
tileSize = <span class="dv">32</span>

<span class="kw">class</span> Sprite(<span class="dt">object</span>):

    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY
        <span class="ot">self</span>.<span class="dt">dir</span> = <span class="dv">1</span>
        <span class="ot">self</span>.dx = <span class="dv">0</span>
        <span class="ot">self</span>.dy = <span class="dv">0</span>
    
    <span class="kw">def</span> checkCollision(<span class="ot">self</span>, otherSprite):
        <span class="kw">if</span> (<span class="ot">self</span>.x &lt; otherSprite.x + tw and otherSprite.x &lt; <span class="ot">self</span>.x + tw
            and <span class="ot">self</span>.y &lt; otherSprite.y + th and otherSprite.y &lt; <span class="ot">self</span>.y + th):
            <span class="kw">return</span> <span class="ot">True</span>
        <span class="kw">else</span>:
            <span class="kw">return</span> <span class="ot">False</span>

<span class="kw">class</span> Orc(Sprite):

    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.orcrt1 = loadImage(<span class="st">&quot;orcrt1.gif&quot;</span>)
        <span class="ot">self</span>.orcrt2 = loadImage(<span class="st">&quot;orcrt2.gif&quot;</span>)
        <span class="ot">self</span>.orcfr1 = loadImage(<span class="st">&quot;orcfr1.gif&quot;</span>)
        <span class="ot">self</span>.orcfr2 = loadImage(<span class="st">&quot;orcfr2.gif&quot;</span>)
        <span class="ot">self</span>.orclf1 = loadImage(<span class="st">&quot;orclf1.gif&quot;</span>)
        <span class="ot">self</span>.orclf2 = loadImage(<span class="st">&quot;orclf2.gif&quot;</span>)
        <span class="ot">self</span>.orcbk1 = loadImage(<span class="st">&quot;orcbk1.gif&quot;</span>)
        <span class="ot">self</span>.orcbk2 = loadImage(<span class="st">&quot;orcbk2.gif&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="kw">if</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">0</span>:
            <span class="kw">if</span> <span class="ot">self</span>.x &gt;= width - tileSize:
                <span class="ot">self</span>.x = width - tileSize
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcrt2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcrt2
            <span class="kw">else</span>:
                <span class="ot">self</span>.x += <span class="ot">self</span>.dx
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcrt1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcrt2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">1</span>:
            <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height - tileSize:
                <span class="ot">self</span>.y = height - tileSize
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcfr2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcfr2
            <span class="kw">else</span>:
                <span class="ot">self</span>.y += <span class="ot">self</span>.dy
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcfr1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcfr2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">2</span>:
            <span class="kw">if</span> <span class="ot">self</span>.x &lt;= <span class="dv">0</span>:
                <span class="ot">self</span>.x = <span class="dv">0</span>
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orclf2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orclf2
            <span class="kw">else</span>:
                <span class="ot">self</span>.x -= <span class="ot">self</span>.dx
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orclf1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orclf2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">3</span>:
            <span class="kw">if</span> <span class="ot">self</span>.y &lt;= <span class="dv">0</span>:
                <span class="ot">self</span>.y = <span class="dv">0</span>
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcbk2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcbk2
            <span class="kw">else</span>:
                <span class="ot">self</span>.y -= <span class="ot">self</span>.dy
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcbk1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcbk2
                
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> frameCount % <span class="dv">8</span> &gt;= <span class="dv">4</span>:
            image(<span class="ot">self</span>.image1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">else</span>:
            image(<span class="ot">self</span>.image2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
            
<span class="kw">class</span> Wall(Sprite):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.pic = loadImage(<span class="st">&quot;wall2.png&quot;</span>)
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.pic, <span class="ot">self</span>.x, <span class="ot">self</span>.y)

<span class="kw">class</span> Lava(Sprite):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.pic = loadImage(<span class="st">&quot;lava.png&quot;</span>)
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.pic, <span class="ot">self</span>.x, <span class="ot">self</span>.y)</code></pre>
<p>Es hat jetzt schon einiges an L√§nge angenommen, daf√ºr ist aber das Hauptprogramm immer noch recht kurz:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> sprite2 <span class="ch">import</span> Orc, Wall, Lava
tilesize = <span class="dv">32</span>


obstacles = [[<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">9</span>],
             [<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>],
             [<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>],
             [<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>],
             [<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>],
             [<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>],
             [<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>],
             [<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">8</span>],
             [<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">8</span>],
             [<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">8</span>]]

orc = Orc(<span class="dv">8</span>*tilesize, <span class="dv">0</span>)
wall = []
lava = []

<span class="kw">def</span> setup():
    <span class="kw">global</span> bg
    bg = loadImage(<span class="st">&quot;ground.png&quot;</span>)
    loadObstaclesData()
    frameRate(<span class="dv">30</span>)
    size(<span class="dv">320</span>, <span class="dv">320</span>)
    orc.loadPics()
    orc.dx = <span class="dv">2</span>
    orc.dy = <span class="dv">2</span>
    
<span class="kw">def</span> draw():
    background(bg)
    orc.move()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(wall)):
        <span class="kw">if</span> orc.checkCollision(wall[i]):
            <span class="kw">if</span> orc.<span class="dt">dir</span> == <span class="dv">0</span>:
                orc.x -= orc.dx
            <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">1</span>:
                orc.y -= orc.dy
            <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">2</span>:
                orc.x += orc.dx
            <span class="kw">elif</span> orc.<span class="dt">dir</span> == <span class="dv">3</span>:
                orc.y += orc.dy
            orc.image1 = orc.image2
    orc.display()
    
<span class="kw">def</span> keyPressed():
    <span class="kw">if</span> keyPressed and key == CODED:
        <span class="kw">if</span> keyCode == RIGHT:
            orc.<span class="dt">dir</span> = <span class="dv">0</span>
        <span class="kw">elif</span> keyCode == DOWN:
            orc.<span class="dt">dir</span> = <span class="dv">1</span>
        <span class="kw">elif</span> keyCode == LEFT:
            orc.<span class="dt">dir</span> = <span class="dv">2</span>
        <span class="kw">elif</span> keyCode == UP:
            orc.<span class="dt">dir</span> = <span class="dv">3</span>
            
<span class="kw">def</span> loadObstaclesData():
    <span class="kw">for</span> y in <span class="dt">range</span>(<span class="dv">10</span>):
        <span class="kw">for</span> x in <span class="dt">range</span>(<span class="dv">10</span>):
            <span class="kw">if</span> obstacles[y][x] == <span class="dv">9</span>:
                wall.append(Wall(x*tilesize, y*tilesize))
            <span class="kw">elif</span> obstacles[y][x] == <span class="dv">8</span>:
                lava.append(Lava(x*tilesize, y*tilesize))</code></pre>
<p>Wenn Ihr das Programm laufen la√üt, werdet Ihr feststellen, da√ü ich kurz vor dem Ausgang unten eine kleine Gemeinheit eingebaut habe und es gar nicht so einfach ist, den Ork dorthin zu lotsen. Er will partout 32 Pixel breit sein und macht sich nicht schmaler, daher mu√ü man die Drehung nach unten genau abpassen. Aber es ist nicht unm√∂glich, ich habe es probiert und geschafft. üòõ</p>
<p>Die Bilder des Orks stammen aus der ebenfalls freien (<a href="https://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>) <a href="http://blogoscoped.com/archive/2006-08-08-n51.html">Sprite-Sammlung von Philipp Lenssen</a> (√ºber 700 animierte Avatare in der klassischen Gr√∂√üe von 32x32 Pixeln) und Ihr k√∂nnt sie in [diesem Tutorial][rorc415] finden.</p>
<p>Alle Quelltexte und Bilder gibt es √ºbrigens auch immer aktuell im <a href="https://github.com/kantel/processingpy">GitHub-Repo</a> zu dieser kleinen Tutorial-Reihe.</p>
<h2 id="der-autonome-ork">Der autonome Ork</h2>
<p>Nun sind Orks, wie ich sie in den letzten Beitr√§gen √ºber den Bildschirm habe wuseln lassen, normalerweise nicht die Figuren, mit denen der Spieler spielt. Er leitet seinen Held, einen <em>Hero</em> durch die Spielewelt. Orks und andere Monster hingegen sind meist computergesteuerte Spielfiguren, sogenannte NPCs <em>(Non Player Characters)</em>. Daher habe ich in dieser Folge einen spielbaren Helden eingebaut und der Ork bewegt sich mehr oder weniger autonom durch das Spielfenster.</p>
<figure>
<img src="images/hero01.jpg" />
</figure>
<p>Daf√ºr habe ich dann erst einmal die Klasse Hero in den zweiten Tab (den ich dieses Mal <code>sprite3.py</code> genannt habe) eingef√ºgt:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Hero(Sprite):

    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.mnv1rt1 = loadImage(<span class="st">&quot;mnv1rt1.gif&quot;</span>)
        <span class="ot">self</span>.mnv1rt2 = loadImage(<span class="st">&quot;mnv1rt2.gif&quot;</span>)
        <span class="ot">self</span>.mnv1fr1 = loadImage(<span class="st">&quot;mnv1fr1.gif&quot;</span>)
        <span class="ot">self</span>.mnv1fr2 = loadImage(<span class="st">&quot;mnv1fr2.gif&quot;</span>)
        <span class="ot">self</span>.mnv1lf1 = loadImage(<span class="st">&quot;mnv1lf1.gif&quot;</span>)
        <span class="ot">self</span>.mnv1lf2 = loadImage(<span class="st">&quot;mnv1lf2.gif&quot;</span>)
        <span class="ot">self</span>.mnv1bk1 = loadImage(<span class="st">&quot;mnv1bk1.gif&quot;</span>)
        <span class="ot">self</span>.mnv1bk2 = loadImage(<span class="st">&quot;mnv1bk2.gif&quot;</span>)
    
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="kw">if</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">0</span>:
            <span class="kw">if</span> <span class="ot">self</span>.x &gt;= width - tileSize:
                <span class="ot">self</span>.x = width - tileSize
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1rt2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1rt2
            <span class="kw">else</span>:
                <span class="ot">self</span>.x += <span class="ot">self</span>.dx
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1rt1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1rt2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">1</span>:
            <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height - tileSize:
                <span class="ot">self</span>.y = height - tileSize
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1fr2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1fr2
            <span class="kw">else</span>:
                <span class="ot">self</span>.y += <span class="ot">self</span>.dy
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1fr1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1fr2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">2</span>:
            <span class="kw">if</span> <span class="ot">self</span>.x &lt;= <span class="dv">0</span>:
                <span class="ot">self</span>.x = <span class="dv">0</span>
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1lf2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1lf2
            <span class="kw">else</span>:
                <span class="ot">self</span>.x -= <span class="ot">self</span>.dx
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1lf1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1lf2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">3</span>:
            <span class="kw">if</span> <span class="ot">self</span>.y &lt;= <span class="dv">0</span>:
                <span class="ot">self</span>.y = <span class="dv">0</span>
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1bk2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1bk2
            <span class="kw">else</span>:
                <span class="ot">self</span>.y -= <span class="ot">self</span>.dy
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1bk1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1bk2
                
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> frameCount % <span class="dv">8</span> &gt;= <span class="dv">4</span>:
            image(<span class="ot">self</span>.image1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">else</span>:
            image(<span class="ot">self</span>.image2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)</code></pre>
<p>Sie unterscheidet sich -- bis auf die Bildchen -- kaum von der bisherigen <code>Orc</code>-Klasse. Auch diese Bildchen stammen aus der ebenfalls freien (<a href="https://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>) <a href="http://blogoscoped.com/archive/2006-08-08-n51.html">Sprite-Sammlung von Philipp Lenssen</a> (√ºber 700 animierte Avatare in der klassischen Gr√∂√üe von 32x32 Pixeln) und hier sind sie, damit Ihr sie herunterladen und verwenden k√∂nnt:</p>
<p><img src="images/mnv1bk1.gif" /> <img src="images/mnv1bk2.gif" /> <img src="images/mnv1fr1.gif" /> <img src="images/mnv1fr2.gif" /> <img src="images/mnv1lf1.gif" /> <img src="images/mnv1lf2.gif" /> <img src="images/mnv1rt1.gif" /> <img src="images/mnv1rt2.gif" /></p>
<p>Den Hintergrund habe ich wieder mit Tiled erstellt und die Bilder daf√ºr wieder dem ebenfalls freien (<a href="https://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>) Angband-Tilesets von <a href="http://pousse.rapiere.free.fr/tome/">dieser Site</a> entnommen. Nach einem Export als CSV-Datei und ein wenig <em>Suchen und Ersetzen</em> kamm dann dieses Terrain zustande:</p>
<pre class="sourceCode python"><code class="sourceCode python">terrain = [[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">7</span>],
           [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">7</span>,<span class="dv">7</span>],
           [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">7</span>],
           [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],
           [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">6</span>,<span class="dv">6</span>],
           [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">0</span>],
           [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">0</span>,<span class="dv">0</span>],
           [<span class="dv">6</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],
           [<span class="dv">9</span>,<span class="dv">6</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],
           [<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]]</code></pre>
<p>Wie man leicht sieht, haben alle Hindernisse einen Wert <code>&gt; 5</code>, wodurch man sie recht einfach in einer Liste zusammenfassen kann, was im Anschlu√ü auch die Kollisionserkennung erleichtert:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> loadObstaclesData():
    <span class="kw">for</span> y in <span class="dt">range</span>(<span class="dv">10</span>):
        <span class="kw">for</span> x in <span class="dt">range</span>(<span class="dv">20</span>):
            <span class="kw">if</span> terrain[y][x] &gt; <span class="dv">5</span>:
                obstacles.append(Obstacle(x*tilesize, y*tilesize))</code></pre>
<p>Und da alle Hindernisse ja schon im Hintergrundbild eingezeichnet sind, braucht man sie auch nicht mehr einzeln zu zeichnen und zu lokalisieren. Es reicht, wenn man die Position eines Hindernisses kennt, egal ob es ein Sumpf, ein Fels, ein Baum, eine Tanne oder eine Mauer ist.</p>
<p>Die Funktion <code>keyPressed()</code> √§ndert jetzt nicht mehr die Laufrichtung des Orks, sondern die unseres Helden. Der Ork bewegt sich selbstst√§ndig und √§ndert die Richtung, sobald er auf ein Hindernis trifft</p>
<pre class="sourceCode python"><code class="sourceCode python">    orc.move()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(obstacles)):
        <span class="kw">if</span> orc.checkCollision(obstacles[i]):
            <span class="kw">if</span> orc.<span class="dt">dir</span> == <span class="dv">0</span>:
                orc.x -= orc.dx
                orc.<span class="dt">dir</span> = <span class="dt">int</span>(random(<span class="dv">4</span>))
            <span class="kw">elif</span> hero.<span class="dt">dir</span> == <span class="dv">1</span>:
                orc.y -= orc.dy
                orc.<span class="dt">dir</span> = <span class="dt">int</span>(random(<span class="dv">4</span>))
            <span class="kw">elif</span> hero.<span class="dt">dir</span> == <span class="dv">2</span>:
                orc.x += orc.dx
                orc.<span class="dt">dir</span> = <span class="dt">int</span>(random(<span class="dv">4</span>))
            <span class="kw">elif</span> hero.<span class="dt">dir</span> == <span class="dv">3</span>:
                orc.y += orc.dy
                orc.<span class="dt">dir</span> = <span class="dt">int</span>(random(<span class="dv">4</span>))
            orc.image1 = orc.image2</code></pre>
<p>oder eines der Fensterr√§nder erreicht hat.</p>
<p>Jetzt der Vollst√§ndigkeit halber das ganze Skript. Erst einmal alles, was ich in dem Reiter <code>sprites3.py</code> eingetippt habe:</p>
<pre class="sourceCode python"><code class="sourceCode python">tw = <span class="dv">32</span>
th = <span class="dv">32</span>
tileSize = <span class="dv">32</span>

<span class="kw">class</span> Sprite(<span class="dt">object</span>):

    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY
        <span class="ot">self</span>.<span class="dt">dir</span> = <span class="dv">1</span>
        <span class="ot">self</span>.dx = <span class="dv">0</span>
        <span class="ot">self</span>.dy = <span class="dv">0</span>
    
    <span class="kw">def</span> checkCollision(<span class="ot">self</span>, otherSprite):
        <span class="kw">if</span> (<span class="ot">self</span>.x &lt; otherSprite.x + tw and otherSprite.x &lt; <span class="ot">self</span>.x + tw
            and <span class="ot">self</span>.y &lt; otherSprite.y + th and otherSprite.y &lt; <span class="ot">self</span>.y + th):
            <span class="kw">return</span> <span class="ot">True</span>
        <span class="kw">else</span>:
            <span class="kw">return</span> <span class="ot">False</span>
<span class="kw">class</span> Hero(Sprite):

    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.mnv1rt1 = loadImage(<span class="st">&quot;mnv1rt1.gif&quot;</span>)
        <span class="ot">self</span>.mnv1rt2 = loadImage(<span class="st">&quot;mnv1rt2.gif&quot;</span>)
        <span class="ot">self</span>.mnv1fr1 = loadImage(<span class="st">&quot;mnv1fr1.gif&quot;</span>)
        <span class="ot">self</span>.mnv1fr2 = loadImage(<span class="st">&quot;mnv1fr2.gif&quot;</span>)
        <span class="ot">self</span>.mnv1lf1 = loadImage(<span class="st">&quot;mnv1lf1.gif&quot;</span>)
        <span class="ot">self</span>.mnv1lf2 = loadImage(<span class="st">&quot;mnv1lf2.gif&quot;</span>)
        <span class="ot">self</span>.mnv1bk1 = loadImage(<span class="st">&quot;mnv1bk1.gif&quot;</span>)
        <span class="ot">self</span>.mnv1bk2 = loadImage(<span class="st">&quot;mnv1bk2.gif&quot;</span>)
    
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="kw">if</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">0</span>:
            <span class="kw">if</span> <span class="ot">self</span>.x &gt;= width - tileSize:
                <span class="ot">self</span>.x = width - tileSize
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1rt2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1rt2
            <span class="kw">else</span>:
                <span class="ot">self</span>.x += <span class="ot">self</span>.dx
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1rt1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1rt2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">1</span>:
            <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height - tileSize:
                <span class="ot">self</span>.y = height - tileSize
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1fr2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1fr2
            <span class="kw">else</span>:
                <span class="ot">self</span>.y += <span class="ot">self</span>.dy
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1fr1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1fr2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">2</span>:
            <span class="kw">if</span> <span class="ot">self</span>.x &lt;= <span class="dv">0</span>:
                <span class="ot">self</span>.x = <span class="dv">0</span>
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1lf2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1lf2
            <span class="kw">else</span>:
                <span class="ot">self</span>.x -= <span class="ot">self</span>.dx
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1lf1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1lf2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">3</span>:
            <span class="kw">if</span> <span class="ot">self</span>.y &lt;= <span class="dv">0</span>:
                <span class="ot">self</span>.y = <span class="dv">0</span>
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1bk2
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1bk2
            <span class="kw">else</span>:
                <span class="ot">self</span>.y -= <span class="ot">self</span>.dy
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.mnv1bk1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.mnv1bk2
                
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> frameCount % <span class="dv">8</span> &gt;= <span class="dv">4</span>:
            image(<span class="ot">self</span>.image1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">else</span>:
            image(<span class="ot">self</span>.image2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
            
<span class="kw">class</span> Orc(Sprite):

    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.orcrt1 = loadImage(<span class="st">&quot;orcrt1.gif&quot;</span>)
        <span class="ot">self</span>.orcrt2 = loadImage(<span class="st">&quot;orcrt2.gif&quot;</span>)
        <span class="ot">self</span>.orcfr1 = loadImage(<span class="st">&quot;orcfr1.gif&quot;</span>)
        <span class="ot">self</span>.orcfr2 = loadImage(<span class="st">&quot;orcfr2.gif&quot;</span>)
        <span class="ot">self</span>.orclf1 = loadImage(<span class="st">&quot;orclf1.gif&quot;</span>)
        <span class="ot">self</span>.orclf2 = loadImage(<span class="st">&quot;orclf2.gif&quot;</span>)
        <span class="ot">self</span>.orcbk1 = loadImage(<span class="st">&quot;orcbk1.gif&quot;</span>)
        <span class="ot">self</span>.orcbk2 = loadImage(<span class="st">&quot;orcbk2.gif&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="kw">if</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">0</span>:
            <span class="kw">if</span> <span class="ot">self</span>.x &gt;= width - tileSize:
                <span class="ot">self</span>.x = width - tileSize
                <span class="ot">self</span>.<span class="dt">dir</span> = <span class="dt">int</span>(random(<span class="dv">4</span>))
            <span class="kw">else</span>:
                <span class="ot">self</span>.x += <span class="ot">self</span>.dx
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcrt1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcrt2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">1</span>:
            <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height - tileSize:
                <span class="ot">self</span>.y = height - tileSize
                <span class="ot">self</span>.y -= <span class="ot">self</span>.dy
                <span class="ot">self</span>.<span class="dt">dir</span> = <span class="dt">int</span>(random(<span class="dv">4</span>))
            <span class="kw">else</span>:
                <span class="ot">self</span>.y += <span class="ot">self</span>.dy
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcfr1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcfr2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">2</span>:
            <span class="kw">if</span> <span class="ot">self</span>.x &lt;= <span class="dv">0</span>:
                <span class="ot">self</span>.x = <span class="dv">0</span>
                <span class="ot">self</span>.<span class="dt">dir</span> = <span class="dt">int</span>(random(<span class="dv">4</span>))
            <span class="kw">else</span>:
                <span class="ot">self</span>.x -= <span class="ot">self</span>.dx
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orclf1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orclf2
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">3</span>:
            <span class="kw">if</span> <span class="ot">self</span>.y &lt;= <span class="dv">0</span>:
                <span class="ot">self</span>.y = <span class="dv">0</span>
                <span class="ot">self</span>.<span class="dt">dir</span> = <span class="dt">int</span>(random(<span class="dv">4</span>))
            <span class="kw">else</span>:
                <span class="ot">self</span>.y -= <span class="ot">self</span>.dy
                <span class="ot">self</span>.image1 = <span class="ot">self</span>.orcbk1
                <span class="ot">self</span>.image2 = <span class="ot">self</span>.orcbk2
                
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> frameCount % <span class="dv">8</span> &gt;= <span class="dv">4</span>:
            image(<span class="ot">self</span>.image1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">else</span>:
            image(<span class="ot">self</span>.image2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)


<span class="kw">class</span> Obstacle(Sprite):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.pic = loadImage(<span class="st">&quot;wall.png&quot;</span>)
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.pic, <span class="ot">self</span>.x, <span class="ot">self</span>.y)</code></pre>
<p>Es ist noch umfangreicher geworden, aber eigentlich ist alles aus den vorherigen Tutorials bekannt. Die Klasse <code>Obstacle()</code> ist eigentlich √ºberfl√ºssig, da ihre Methoden nicht ben√∂tigt werden, man k√∂nnte stattdessen direkt die Klasse <code>Sprite()</code> nutzen. Sie schafft in meinen Augen aber mehr Klarheit und daher habe ich sie dennoch -- mit Dummy-Methoden -- stehen lassen.</p>
<p>Auch das Hauptprogramm wird langsam umfangreicher, ist aber immer noch √ºbersichtlich. Es sieht nun so aus:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Hero 01</span>
<span class="ch">from</span> sprites3 <span class="ch">import</span> Hero, Orc, Obstacle
tilesize = <span class="dv">32</span>

terrain = [[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">7</span>],
           [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">7</span>,<span class="dv">7</span>],
           [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">7</span>],
           [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],
           [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">6</span>,<span class="dv">6</span>],
           [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">0</span>],
           [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">0</span>,<span class="dv">0</span>],
           [<span class="dv">6</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],
           [<span class="dv">9</span>,<span class="dv">6</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],
           [<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]]

hero = Hero(<span class="dv">16</span>*tilesize, <span class="dv">0</span>)
orc  = Orc(<span class="dv">4</span>*tilesize, <span class="dv">0</span>)
obstacles = []           

<span class="kw">def</span> setup():
    <span class="kw">global</span> bg
    bg = loadImage(<span class="st">&quot;terrain.png&quot;</span>)
    loadObstaclesData()
    frameRate(<span class="dv">30</span>)
    size(<span class="dv">640</span>, <span class="dv">320</span>)
    hero.loadPics()
    orc.loadPics()
    hero.dx = <span class="dv">2</span>
    hero.dy = <span class="dv">2</span>
    orc.dx = <span class="dv">2</span>
    orc.dy = <span class="dv">2</span>

<span class="kw">def</span> draw():
    background(bg)
    hero.move()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(obstacles)):
        <span class="kw">if</span> hero.checkCollision(obstacles[i]):
            <span class="kw">if</span> hero.<span class="dt">dir</span> == <span class="dv">0</span>:
                hero.x -= hero.dx
            <span class="kw">elif</span> hero.<span class="dt">dir</span> == <span class="dv">1</span>:
                hero.y -= hero.dy
            <span class="kw">elif</span> hero.<span class="dt">dir</span> == <span class="dv">2</span>:
                hero.x += hero.dx
            <span class="kw">elif</span> hero.<span class="dt">dir</span> == <span class="dv">3</span>:
                hero.y += hero.dy
            hero.image1 = hero.image2
    hero.display()
    orc.move()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(obstacles)):
        <span class="kw">if</span> orc.checkCollision(obstacles[i]):
            <span class="kw">if</span> orc.<span class="dt">dir</span> == <span class="dv">0</span>:
                orc.x -= orc.dx
                orc.<span class="dt">dir</span> = <span class="dt">int</span>(random(<span class="dv">4</span>))
            <span class="kw">elif</span> hero.<span class="dt">dir</span> == <span class="dv">1</span>:
                orc.y -= orc.dy
                orc.<span class="dt">dir</span> = <span class="dt">int</span>(random(<span class="dv">4</span>))
            <span class="kw">elif</span> hero.<span class="dt">dir</span> == <span class="dv">2</span>:
                orc.x += orc.dx
                orc.<span class="dt">dir</span> = <span class="dt">int</span>(random(<span class="dv">4</span>))
            <span class="kw">elif</span> hero.<span class="dt">dir</span> == <span class="dv">3</span>:
                orc.y += orc.dy
                orc.<span class="dt">dir</span> = <span class="dt">int</span>(random(<span class="dv">4</span>))
            orc.image1 = orc.image2
    orc.display()

<span class="kw">def</span> keyPressed():
    <span class="kw">if</span> keyPressed and key == CODED:
        <span class="kw">if</span> keyCode == RIGHT:
            hero.<span class="dt">dir</span> = <span class="dv">0</span>
        <span class="kw">elif</span> keyCode == DOWN:
            hero.<span class="dt">dir</span> = <span class="dv">1</span>
        <span class="kw">elif</span> keyCode == LEFT:
            hero.<span class="dt">dir</span> = <span class="dv">2</span>
        <span class="kw">elif</span> keyCode == UP:
            hero.<span class="dt">dir</span> = <span class="dv">3</span>

<span class="kw">def</span> loadObstaclesData():
    <span class="kw">for</span> y in <span class="dt">range</span>(<span class="dv">10</span>):
        <span class="kw">for</span> x in <span class="dt">range</span>(<span class="dv">20</span>):
            <span class="kw">if</span> terrain[y][x] &gt; <span class="dv">5</span>:
                obstacles.append(Obstacle(x*tilesize, y*tilesize)</code></pre>
<h3 id="caveat-4">Caveat</h3>
<p>Wenn Ihr das Programm laufen la√üt, werdet Ihr feststellen, da√ü der Ork manchmal kleine T√§nzchen veranstaltet oder sogar durch Mauern gehen kann. Und aus der linken, oberen Ecke findet er auch manchmal schwer wieder heraus. Das erste liegt daran, da√ü ich nicht verhindert habe, da√ü er nach einer Kollisionserkennung zuf√§llig die gleiche Richtung noch einmal ausw√§hlt. Das kann man zum Beispiel verhindern, in dem man bei jeder Kollisionserkennung jeweils eine Liste der ¬ªzul√§ssigen¬´ Richtungen erstellt und nur daraus die neue Richtung heraussuchen l√§√üt.</p>
<p>F√ºr das zweite Problem br√§uchte der Ork einfach mehr ¬ªIntelligenz¬´. Bisher wechselt er die Richtung nur, wenn er auf einer Hindernis trifft. Anders s√§he es aus, wenn man zufallsgeseteuert nach etwa jedem 20. Schritt eine Richtungs√§nderung vornimmt. Die Laufrichtungen des Ork w√ºrden dann noch unvorhersehbarer.</p>
<h2 id="drei-orks-und-ein-held">Drei Orks und ein Held</h2>
<figure>
<img src="images/dreiorksundeinheld.jpg" alt="Drei Orks" /><figcaption>Drei Orks</figcaption>
</figure>
<p>In diesem Tutorial, in dem erstmalig auch mehrere Orks auftreten, habe ich die Unstimmigkeiten aus dem <a href="runningorc5.md">letzten Teil dieser Reihe</a> beseitigt. Die R√§nder-Behandlung habe ich dadurch vereinfacht, da√ü nun die ganze Spielwelt eingez√§unt ist<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a> und die T√§nzchen vor Hindernissen habe ich dadurch eliminiert, da√ü ich Listen der zul√§ssigen Richtungs√§nderungen angelegt habe und nur diese per Zufall ausw√§hlen lasse:</p>
<pre class="{python}"><code>for i in range(len(orc)):
        orc[i].move()
        for j in range(len(wall)):
            if orc[i].checkCollision(wall[j]):
                if orc[i].dir == 0:
                    orc[i].x -= orc[i].dx
                    legalMove = [1, 2, 3]
                    orc[i].dir = legalMove[int(random(3))]
                elif orc[i].dir == 1:
                    orc[i].y -= orc[i].dy
                    legalMove = [0, 2, 3]
                    orc[i].dir = legalMove[int(random(3))]
                elif orc[i].dir == 2:
                    orc[i].x += orc[i].dx
                    legalMove = [0, 1, 3]
                    orc[i].dir = legalMove[int(random(3))]
                elif orc[i].dir == 3:
                    orc[i].y += orc[i].dy
                    legalMove = [0, 1, 2]
                    orc[i].dir = legalMove[int(random(3))
        orc[i].display()</code></pre>
<p>Au√üerdem habe ich in der Klasse <code>Orc</code> (im Modul <code>sprite2.py</code>) den Orks einen zuf√§lligen Richtungswechsel verpa√üt, damit sie nicht nur bei einer Kollision mit Hindernissen ihre Richtung √§ndern und so ihre Bewegungen unvorhersehbarer werden.</p>
<pre class="{python}"><code>    def move(self):
        if frameCount % int(random(30, 120)) == 0:
            if self.dir == 0:
                legalMove = [1, 2, 3]
                self.dir = legalMove[int(random(3))]
            elif self.dir == 1:
                legalMove = [0, 2, 3]
                self.dir = legalMove[int(random(3))]
            elif self.dir == 2:
                legalMove = [0, 1, 3]
                self.dir = legalMove[int(random(3))]
            elif self.dir == 3:
                legalMove = [0, 1, 2]
                self.dir = legalMove[int(random(3))]</code></pre>
<p>Fragt mich nicht, wie ich auf die Werte <code>30, 120</code> gekommen bin. Ich habe einfach ein wenig experimentiert und diese brachten in meinen Augen das ansprechendste Ergebnis.</p>
<p>Das einzige sonstige neue ist, da√ü ich die drei Orks in einer Liste zusammengefa√üt habe, so da√ü sie -- wie das Code-Fragment ganz oben zeigt -- in einer Schleife abgehandelt werden k√∂nnen.</p>
<h3 id="der-quellcode-11">Der Quellcode</h3>
<p>Daher erst einmal der vollst√§ndige Quellcode, damit Ihr das Beispiel auch nachvollziehen und -programmieren k√∂nnt. Erst einmal das Modul <code>sprite2.py</code>, das ich wieder in einem separaten Tab in der Processing-IDE untergebracht habe:</p>
<pre class="{python}"><code>tw = 32
th = 32
tileSize = 32

class Sprite(object):

    def __init__(self, posX, posY):
        self.x = posX
        self.y = posY
        self.dir = 1
        self.dx = 0
        self.dy = 0
    
    def checkCollision(self, otherSprite):
        if (self.x &lt; otherSprite.x + tw and otherSprite.x &lt; self.x + tw
            and self.y &lt; otherSprite.y + th and otherSprite.y &lt; self.y + th):
            return True
        else:
            return False

class Hero(Sprite):

    def loadPics(self):
        self.mnv1rt1 = loadImage(&quot;mnv1rt1.gif&quot;)
        self.mnv1rt2 = loadImage(&quot;mnv1rt2.gif&quot;)
        self.mnv1fr1 = loadImage(&quot;mnv1fr1.gif&quot;)
        self.mnv1fr2 = loadImage(&quot;mnv1fr2.gif&quot;)
        self.mnv1lf1 = loadImage(&quot;mnv1lf1.gif&quot;)
        self.mnv1lf2 = loadImage(&quot;mnv1lf2.gif&quot;)
        self.mnv1bk1 = loadImage(&quot;mnv1bk1.gif&quot;)
        self.mnv1bk2 = loadImage(&quot;mnv1bk2.gif&quot;)
    
    def move(self):
        if self.dir == 0:
            self.x += self.dx
            self.image1 = self.mnv1rt1
            self.image2 = self.mnv1rt2
        elif self.dir == 1:
            self.y += self.dy
            self.image1 = self.mnv1fr1
            self.image2 = self.mnv1fr2
        elif self.dir == 2:
            self.x -= self.dx
            self.image1 = self.mnv1lf1
            self.image2 = self.mnv1lf2
        elif self.dir == 3:
            self.y -= self.dy
            self.image1 = self.mnv1bk1
            self.image2 = self.mnv1bk2
                
    def display(self):
        if frameCount % 8 &gt;= 4:
            image(self.image1, self.x, self.y)
        else:
            image(self.image2, self.x, self.y)

class Orc(Sprite):

    def loadPics(self):
        self.orcrt1 = loadImage(&quot;orcrt1.gif&quot;)
        self.orcrt2 = loadImage(&quot;orcrt2.gif&quot;)
        self.orcfr1 = loadImage(&quot;orcfr1.gif&quot;)
        self.orcfr2 = loadImage(&quot;orcfr2.gif&quot;)
        self.orclf1 = loadImage(&quot;orclf1.gif&quot;)
        self.orclf2 = loadImage(&quot;orclf2.gif&quot;)
        self.orcbk1 = loadImage(&quot;orcbk1.gif&quot;)
        self.orcbk2 = loadImage(&quot;orcbk2.gif&quot;)
        
    def move(self):
        if frameCount % int(random(30, 120)) == 0:
            if self.dir == 0:
                legalMove = [1, 2, 3]
                self.dir = legalMove[int(random(3))]
            elif self.dir == 1:
                legalMove = [0, 2, 3]
                self.dir = legalMove[int(random(3))]
            elif self.dir == 2:
                legalMove = [0, 1, 3]
                self.dir = legalMove[int(random(3))]
            elif self.dir == 3:
                legalMove = [0, 1, 2]
                self.dir = legalMove[int(random(3))]
        if self.dir == 0:
            self.x += self.dx
            self.image1 = self.orcrt1
            self.image2 = self.orcrt2
        elif self.dir == 1:
            self.y += self.dy
            self.image1 = self.orcfr1
            self.image2 = self.orcfr2
        elif self.dir == 2:
            self.x -= self.dx
            self.image1 = self.orclf1
            self.image2 = self.orclf2
        elif self.dir == 3:
            self.y -= self.dy
            self.image1 = self.orcbk1
            self.image2 = self.orcbk2
                
    def display(self):
        if frameCount % 8 &gt;= 4:
            image(self.image1, self.x, self.y)
        else:
            image(self.image2, self.x, self.y)
            
class Wall(Sprite):
    
    def loadPics(self):
        self.pic = loadImage(&quot;wall.png&quot;)
        
    def display(self):
        image(self.pic, self.x, self.y)</code></pre>
<p>Es ist gegen√ºber dem letzten Mal ein wenig einfacher geworden, weil die R√§nderbehandlung entfallen ist. Das Hauptprogramm hat allerdings an Komplexit√§t deutlich zugenommen:</p>
<pre class="{python}"><code>from sprite2 import Hero, Orc, Wall
tilesize = 32

dungeon = [[9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,7,7,9],
           [8,9,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,9],
           [8,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9],
           [9,9,9,9,9,9,0,0,0,0,0,0,0,0,0,9,9,9,9,9],
           [9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,0,9],
           [9,0,0,0,0,0,0,0,9,9,0,0,0,0,0,9,0,0,0,9],
           [9,0,0,0,0,0,0,0,9,0,0,0,0,0,0,9,0,0,0,9],
           [9,9,9,9,9,9,9,9,9,0,0,0,0,0,0,9,0,0,0,9],
           [8,9,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,9],
           [8,9,0,0,0,0,0,0,9,0,0,0,0,0,0,9,0,0,0,9],
           [8,9,0,0,0,0,0,0,9,0,0,9,9,9,9,9,9,9,9,9],
           [9,9,0,0,0,0,0,0,9,0,0,9,0,0,0,0,0,0,0,9],
           [9,0,0,0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,9],
           [9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5],
           [8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9]]

wall = []
hero = Hero(18*tilesize, 13*tilesize)
orc  = []
orc.append(Orc(2*tilesize, 12*tilesize))
orc.append(Orc(3*tilesize, 2*tilesize))
orc.append(Orc(16*tilesize, 4*tilesize))

def setup():
    global bg
    bg = loadImage(&quot;dungeon.png&quot;)
    loadDungeonData()
    frameRate(30)
    size(640, 480)
    hero.loadPics()
    hero.dx = 2
    hero.dy = 2
    hero.dir = 2
    for i in range(len(orc)):
        orc[i].loadPics()
        orc[i].dx = 2
        orc[i].dy = 2
        orc[i].dir = 0
    

def draw():
    background(bg)
    hero.move()
    for j in range(len(wall)):
        if hero.checkCollision(wall[j]):
            if hero.dir == 0:
                hero.x -= hero.dx
            elif hero.dir == 1:
                hero.y -= hero.dy
            elif hero.dir == 2:
                hero.x += hero.dx
            elif hero.dir == 3:
                hero.y += hero.dy
            hero.image1 = hero.image2
    hero.display()

    for i in range(len(orc)):
        orc[i].move()
        for j in range(len(wall)):
            if orc[i].checkCollision(wall[j]):
                if orc[i].dir == 0:
                    orc[i].x -= orc[i].dx
                    legalMove = [1, 2, 3]
                    orc[i].dir = legalMove[int(random(3))]
                elif orc[i].dir == 1:
                    orc[i].y -= orc[i].dy
                    legalMove = [0, 2, 3]
                    orc[i].dir = legalMove[int(random(3))]
                elif orc[i].dir == 2:
                    orc[i].x += orc[i].dx
                    legalMove = [0, 1, 3]
                    orc[i].dir = legalMove[int(random(3))]
                elif orc[i].dir == 3:
                    orc[i].y += orc[i].dy
                    legalMove = [0, 1, 2]
                    orc[i].dir = legalMove[int(random(3))]
        orc[i].display()

def loadDungeonData():
    for y in range(15):
        for x in range(20):
            if dungeon[y][x] &gt;= 5:
                wall.append(Wall(x*tilesize, y*tilesize))

def keyPressed():
    if keyPressed and key == CODED:
        if keyCode == RIGHT:
            hero.dir = 0
        elif keyCode == DOWN:
            hero.dir = 1
        elif keyCode == LEFT:
            hero.dir = 2
        elif keyCode == UP:
            hero.dir = 3</code></pre>
<p>Den Raum habe ich wieder in <a href="http://cognitiones.kantel-chaos-team.de/multimedia/spieleprogrammierung/tiled.html">Tiled</a> erstellt und einmal als Bild und einmal als CSV-Datei exportiert. Aus dieser CSV-Datei habe ich dann obiges Array gebastelt, aus dem man die Struktur des <em>Dungeon</em> ziemlich gut ablesen kann. Damit das mit dem Ablesen aber auch wirklich funktioniert, mu√üte ich gegen√ºber dem gewohnten Brauch <code>x</code> und <code>y</code> vertauschen (weil man sonst den Kopf immer schr√§g legen m√º√üte). üòá</p>
<h3 id="meditieren-mit-den-orks">Meditieren mit den Orks</h3>
<p>Ich habe mir bei der Platzierung der Orks beim Programmstart etwas gedacht. L√§√üt man das Progr√§mmchen n√§mlich eine Weile laufen, dann werdet Ihr feststellen, da√ü die beiden Orks unten kaum Probleme haben, ihrem urspr√ºnglichen Raum zu entkommen, w√§hrend der Ork in dem kleinen Zimmerchen rechts wie ein im Zoo eingesperrter Tiger meist ziemlich lange dort auf und ab tigert, bis er endlich entkommen kann (irgendwann entkommt aber jeder). Um mir das anzuschauen, man√∂vriere ich den Helden gerne in das kleine R√§umchen oben links und lasse ihn dort einfach stehen (noch passiert ja nichts, wenn er von einem Ork entdeckt wird).</p>
<p>Wenn man den Sketch dann lange genug laufen l√§√üt, verirrt sich hin und wieder auch ein Ork zur√ºck in das Gef√§ngniszimmer und braucht nat√ºrlich ebenfalls seine Zeit, bis er wieder entkommt. Ein chinesisches Restaurant in der N√§he meines Arbeitsplatzes hat kleine Aquarien mit Guppies im Gastraum. Wenn ich dort essen gehe, setze ich mich gerne in die N√§he der Aquarien und schaue den Fischen beim Umherwieseln zu. Ihre Bewegungen sind denen der Orks in diesem Skript ziemlich √§hnlich und daher wirkt dieser Sketch √§hnlich meditativ auf mich. Glaubt mir, ich habe gestern abend fast eine Stunde vor dem Rechner gesessen und den Orks ganz entspannt beim Wuseln zugesehen.</p>
<h3 id="credits-7">Credits</h3>
<p>Die Bilder des Helden und der Orks entstammen wieder der freien (<a href="https://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>) <a href="http://blogoscoped.com/archive/2006-08-08-n51.html">Sprite-Sammlung von Philipp Lenssen</a> (√ºber 700 animierte Avatare in der klassischen Gr√∂√üe von 32x32 Pixeln). Den Hintergrund habe ich wie bei den anderen Beispielen auch mit <a href="http://cognitiones.kantel-chaos-team.de/multimedia/spieleprogrammierung/tiled.html">Tiled</a> erstellt und die Tiles dem ebenfalls freien (<a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a>) [Dungeon Crawl Tileset][6] entnommen.</p>
<p>Alle Skripte und Assets zu dieser kleinen [Processing.py-Serie][7] k√∂nnt Ihr nat√ºrlich [auf GitHub][8] finden. Also habt Spa√ü damit.</p>
<h1 id="exkurs-rauhn√§chte-spa√ü-mit-processing.py">Exkurs Rauhn√§chte: Spa√ü mit Processing.py</h1>
<p>Jeden Winter in den <a href="https://de.wikipedia.org/wiki/Rauhnacht">Rauhn√§chten</a> treffen sich die Geister mit den Engeln, um gemeinsam zu tanzen und ihrer Freude Ausdruck zu verleihen, da√ü die Tage nun wieder l√§nger werden. Ich habe das mal in einem kleinen Processing.py-Sketch nachempfunden.</p>
<figure>
<img src="images/rauhnacht.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Hier treffen sich Geist und Engelchen vor dem Tor einer Waldkirche oder -kapelle um anmutig Euren Mauszeiger zu umtanzen. Dabei habe ich eine Technik verwendet, die <em><a href="https://processing.org/examples/easing.html">Easing</a></em> genannt wird. Dabei folgt zwar der <em>Sprite</em> dem Mauszeiger, doch bei jedem Durchlauf wird die Distanz zwischen dem Mauszeiger und dem Sprite berechnet und mit einer kleinen Konstante (zum Beispiel 0.05) multipliziert.</p>
<pre class="sourceCode python"><code class="sourceCode python">easing1 = <span class="fl">0.01</span>
easing2 = <span class="fl">0.05</span>

[‚Ä¶]

targetX = mouseX
targetY = mouseY

[‚Ä¶]

engelX += (targetX - engelX) * easing1
engelY += (targetY - engelY) * easing1

[‚Ä¶]

ghostX += (targetX - ghostX) * easing2
ghostY += (targetY - ghostY) * easing2</code></pre>
<p>Durch die beiden unterschiedlichen Konstanten <code>easing1</code> und <code>easing2</code> habe ich erreicht, da√ü die beiden Sprites in unterschiedlichen Geschwindigkeiten und Abst√§nden den Mauszeiger umtanzen.</p>
<h2 id="das-vollst√§ndige-programm">Das vollst√§ndige Programm</h2>
<pre class="sourceCode python"><code class="sourceCode python">easing1 = <span class="fl">0.01</span>
easing2 = <span class="fl">0.05</span>
ghostX = <span class="dv">240</span>
ghostY = <span class="dv">200</span>
engelX = <span class="dv">200</span>
engelY = <span class="dv">240</span>

<span class="kw">def</span> setup():
    <span class="kw">global</span> bg, ghost, engel
    bg = loadImage(<span class="st">&quot;koken.jpg&quot;</span>)
    ghost = loadImage(<span class="st">&quot;ghost.png&quot;</span>)
    engel = loadImage(<span class="st">&quot;engel.png&quot;</span>)
    frameRate(<span class="dv">30</span>)
    size(<span class="dv">560</span>, <span class="dv">320</span>)
  
<span class="kw">def</span> draw():
    <span class="kw">global</span> ghostX, ghostY, engelX, engelY
    background(bg)
    targetX = mouseX
    targetY = mouseY
    
    engelX += (targetX - engelX) * easing1
    <span class="kw">if</span> engelX &gt;= (width - <span class="dv">36</span>):
        engelX = width - <span class="dv">36</span>
    <span class="kw">elif</span> engelX &lt;= <span class="dv">0</span>:
        engelX = <span class="dv">0</span>;
    engelY += (targetY - engelY) * easing1
    <span class="kw">if</span> engelY &gt;= (height - <span class="dv">36</span>):
        engelY = height - <span class="dv">36</span>
    <span class="kw">elif</span> engelY &lt;= <span class="dv">0</span>:
        engelY = <span class="dv">0</span>
    image(engel, engelX, engelY)
    
    ghostX += (targetX - ghostX) * easing2
    <span class="kw">if</span> ghostX &gt;= (width - <span class="dv">36</span>):
        ghostX = width - <span class="dv">36</span>
    <span class="kw">elif</span> ghostX &lt;= <span class="dv">0</span>:
        ghostX = <span class="dv">0</span>;
    ghostY += (targetY - ghostY) * easing2
    <span class="kw">if</span> ghostY &gt;= (height - <span class="dv">36</span>):
        ghostY = height - <span class="dv">36</span>
    <span class="kw">elif</span> ghostY &lt;= <span class="dv">0</span>:
        ghostY = <span class="dv">0</span>
    image(ghost, ghostX, ghostY)</code></pre>
<p>Wie Ihr seht, ist da eigentlich nicht viel mehr. Au√üer dem <em>Easing</em> habe ich mit den Randabfragen nur noch daf√ºr gesorgt, da√ü die beiden Sprites bei ihrem T√§nzchen das Programmfenster nicht verlassen.</p>
<h2 id="maus-versus-tastatur">Maus versus Tastatur</h2>
<p>Die Abfrage der Mausposition funktioniert bei Processing(.py) im Gegensatz zur Tastaturabfrage auch dann, wenn das Programmfenster nicht den Fokus besitzt, sondern auch, wenn die IDE oder andere Fenster noch im Vordergrund sind. Denn die IDE mu√ü sich die Maus ja auch nicht mit dem Programmfenster teilen, die Tastatur aber doch.</p>
<h2 id="caveat-5">Caveat</h2>
<p>Meine urspr√ºngliche Idee war, statt der Bilder Emojis f√ºr Geist und Engel einzusetzen, und zwar diese: üëª und üëº , wie ich eine √§hnliche Idee schon einmal in einem <a href="http://blog.schockwellenreiter.de/2016/07/2016071001.html">P5.js-Sketch</a> umgesetzt hatte. Dann fiel mir jedoch ein, da√ü Processing.py ja auf <a href="http://cognitiones.kantel-chaos-team.de/programmierung/python/jython.html">Jython</a> aufsetzt und es daher mit der UTF-8-Unterst√ºtzung im Allgemeinen und der Nutzung von Emojis im Besonderen schwierig werden kann (ein aktuelles Jython ist zwar nahezu kompatibel zu Python 2.7, aber eben nicht zu Python 3). Daher habe ich auf die freien (<a href="https://creativecommons.org/licenses/by/4.0/">CC-BY 4.0</a>) <a href="https://github.com/twitter/twemoji">Twemoji-Graphiken von Twitter</a> zur√ºckgegriffen. Hier sind sie, falls Ihr das Beispiel nachprogrammieren wollt.</p>
<p><img src="images/engel.png" alt="Engel" /> <img src="images/ghost.png" alt="Geist" /></p>
<p>Der Geist sieht zwar nicht ganz so fr√∂hlich aus, wie das Emoji von Apple und anderen, aber es ist vielleicht realistischer. Wenn M√§nner tanzen (m√ºssen), dann verziehen sie halt oft schmerzhaft ihr Gesicht.</p>
<h2 id="weitere-credits">Weitere Credits</h2>
<p><a href="http://blog.schockwellenreiter.de/g2016/b201612/201612bild15.html"><img src="images/koken.jpg" alt="Background" /></a></p>
<p>Das Tor zur Waldkirche ist ein Ausschnitt aus einem [Gem√§lde von Edmund Koken][8], das -- da der Maler 1872 verstorben ist -- hinreichend gemeinfrei sein d√ºrfte, so da√ü Ihr das Bild gefahrlos verwenden k√∂nnt.</p>
<h1 id="exkurs-walking-pingus">Exkurs: Walking Pingus</h1>
<p>Die √§lteren unter Euch k√∂nnen sich sicher noch an das Computerspiel <a href="https://de.wikipedia.org/wiki/Lemmings">Lemminge</a> von 1991 erinnern, in dem man eine Horde kleiner, aber dummer Gesch√∂pfe mit gr√ºnen Haaren und blauem Anzug, die immer stur geradeaus liefen, davon abhalten mu√üte, ins Verderben zu rennen und sie zum rettenden Ausgang f√ºhren. <em>Ingo Runke</em> hatte einen freien (GPL) Klon gebastelt, den er in Anspielung auf das Linus-Maskottchen <em>Tux</em> <a href="https://de.wikipedia.org/wiki/Pingus">Pingus</a> nannte und in dem man -- statt der Lemming -- kleine Pinguine retten mu√üte. Die Pinguine bewegten sich in jede Richtung mit 8 Bildern und da ich mal etwas anderes als zappelige Orks mit [Processing.py][wp7] auf den Bildschirm bringen wollte, habe ich mich mal an den Pinguinen versucht.</p>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/31892319221/"><img src="images/walkingpingus-b.jpg" alt="Screenshot" /></a></p>
<p>Nach den bisherigen Helden- und Orks-Tutorials ist es nur eine Finger√ºbung. Auf eine Oberklasse <code>Sprites</code> habe ich dieses Mal verzichtet, der Pingus mu√ü ja nur mit den Fensterr√§ndern kommunizieren. Wie schon bisher existieren neben der Initialisierung drei Methoden, n√§mlich <code>loadPics()</code>, <code>move()</code> und <code>display()</code>. Die ersten beiden Methoden sind eigentlich trivial und nur deswegen so umfangreich, weil sie jeweils mit 16 Bildchen umgehen m√ºssen. Lediglich bei der <code>display()</code>-Methode mu√ü man aufpassen und r√ºckw√§rts z√§hlen, da andersherum die Schleife nach dem ersten Male immer sofort verlassen wird:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">28</span>:
            image(<span class="ot">self</span>.image1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">24</span>:
            image(<span class="ot">self</span>.image2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">20</span>:
            image(<span class="ot">self</span>.image3, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">16</span>:
            image(<span class="ot">self</span>.image4, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">12</span>:
                image(<span class="ot">self</span>.image5, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">8</span>:
            image(<span class="ot">self</span>.image6, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">4</span>:
            image(<span class="ot">self</span>.image7, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">else</span>:
            image(<span class="ot">self</span>.image8, <span class="ot">self</span>.x, <span class="ot">self</span>.y)</code></pre>
<p>Die einzelnen Bilder habe ich wieder mit <a href="http://cognitiones.kantel-chaos-team.de/multimedia/spieleprogrammierung/tiled.html">Tiled</a> aus dem Spritesheet ausgeschnitten. Dabei ist zu beachten, da√ü die einzelnen Pinguine eine Tilegr√∂√üe von 32x44 Pixeln besitzen.</p>
<figure>
<img src="images/xmas-walker.png" alt="Spritesheet" /><figcaption>Spritesheet</figcaption>
</figure>
<h2 id="der-quellcode-12">Der Quellcode</h2>
<p>Wie gesagt, es ist nur eine kleine Finger√ºbung. Hier erst einmal das Modul <code>penguin.py</code>, das nur die Klasse <code>Penguin</code> enth√§lt:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Penguin(<span class="dt">object</span>):
    
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY
        <span class="ot">self</span>.<span class="dt">dir</span> = <span class="dv">0</span>
        <span class="ot">self</span>.dx = <span class="dv">0</span>
        
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="co"># nach rechts laufen</span>
        <span class="ot">self</span>.pingrt1 = loadImage(<span class="st">&quot;pingrt1.png&quot;</span>)
        <span class="ot">self</span>.pingrt2 = loadImage(<span class="st">&quot;pingrt2.png&quot;</span>)
        <span class="ot">self</span>.pingrt3 = loadImage(<span class="st">&quot;pingrt3.png&quot;</span>)
        <span class="ot">self</span>.pingrt4 = loadImage(<span class="st">&quot;pingrt4.png&quot;</span>)
        <span class="ot">self</span>.pingrt5 = loadImage(<span class="st">&quot;pingrt5.png&quot;</span>)
        <span class="ot">self</span>.pingrt6 = loadImage(<span class="st">&quot;pingrt6.png&quot;</span>)
        <span class="ot">self</span>.pingrt7 = loadImage(<span class="st">&quot;pingrt7.png&quot;</span>)
        <span class="ot">self</span>.pingrt8 = loadImage(<span class="st">&quot;pingrt8.png&quot;</span>)
        <span class="co"># nach links laufen</span>
        <span class="ot">self</span>.pinglft1 = loadImage(<span class="st">&quot;pinglft1.png&quot;</span>)
        <span class="ot">self</span>.pinglft2 = loadImage(<span class="st">&quot;pinglft2.png&quot;</span>)
        <span class="ot">self</span>.pinglft3 = loadImage(<span class="st">&quot;pinglft3.png&quot;</span>)
        <span class="ot">self</span>.pinglft4 = loadImage(<span class="st">&quot;pinglft4.png&quot;</span>)
        <span class="ot">self</span>.pinglft5 = loadImage(<span class="st">&quot;pinglft5.png&quot;</span>)
        <span class="ot">self</span>.pinglft6 = loadImage(<span class="st">&quot;pinglft6.png&quot;</span>)
        <span class="ot">self</span>.pinglft7 = loadImage(<span class="st">&quot;pinglft7.png&quot;</span>)
        <span class="ot">self</span>.pinglft8 = loadImage(<span class="st">&quot;pinglft8.png&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="kw">if</span> <span class="ot">self</span>.<span class="dt">dir</span> == <span class="dv">1</span>:
            <span class="ot">self</span>.x += <span class="ot">self</span>.dx
            <span class="ot">self</span>.image1 = <span class="ot">self</span>.pingrt1
            <span class="ot">self</span>.image2 = <span class="ot">self</span>.pingrt2
            <span class="ot">self</span>.image3 = <span class="ot">self</span>.pingrt3
            <span class="ot">self</span>.image4 = <span class="ot">self</span>.pingrt4
            <span class="ot">self</span>.image5 = <span class="ot">self</span>.pingrt5
            <span class="ot">self</span>.image6 = <span class="ot">self</span>.pingrt6
            <span class="ot">self</span>.image7 = <span class="ot">self</span>.pingrt7
            <span class="ot">self</span>.image8 = <span class="ot">self</span>.pingrt8
        <span class="kw">elif</span> <span class="ot">self</span>.<span class="dt">dir</span> == -<span class="dv">1</span>:
            <span class="ot">self</span>.x -= <span class="ot">self</span>.dx
            <span class="ot">self</span>.image1 = <span class="ot">self</span>.pinglft1
            <span class="ot">self</span>.image2 = <span class="ot">self</span>.pinglft2
            <span class="ot">self</span>.image3 = <span class="ot">self</span>.pinglft3
            <span class="ot">self</span>.image4 = <span class="ot">self</span>.pinglft4
            <span class="ot">self</span>.image5 = <span class="ot">self</span>.pinglft5
            <span class="ot">self</span>.image6 = <span class="ot">self</span>.pinglft6
            <span class="ot">self</span>.image7 = <span class="ot">self</span>.pinglft7
            <span class="ot">self</span>.image8 = <span class="ot">self</span>.pinglft8
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">28</span>:
            image(<span class="ot">self</span>.image1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">24</span>:
            image(<span class="ot">self</span>.image2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">20</span>:
            image(<span class="ot">self</span>.image3, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">16</span>:
            image(<span class="ot">self</span>.image4, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">12</span>:
                image(<span class="ot">self</span>.image5, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">8</span>:
            image(<span class="ot">self</span>.image6, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> frameCount % <span class="dv">32</span> &gt;= <span class="dv">4</span>:
            image(<span class="ot">self</span>.image7, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">else</span>:
            image(<span class="ot">self</span>.image8, <span class="ot">self</span>.x, <span class="ot">self</span>.y)</code></pre>
<p>Das Hauptprogramm ist extrem kurz, aber der Pinguin watschelt ja auch nur von links nach rechts und wieder zur√ºck:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> penguin <span class="ch">import</span> Penguin

pingus = Penguin(<span class="dv">0</span>, <span class="dv">16</span>)

<span class="kw">def</span> setup():
    frameRate(<span class="dv">30</span>)
    size(<span class="dv">640</span>, <span class="dv">64</span>)
    pingus.loadPics()
    pingus.dx = <span class="dv">1</span>
    pingus.<span class="dt">dir</span> = <span class="dv">1</span>

<span class="kw">def</span> draw():
    background(<span class="dv">0</span>, <span class="dv">153</span>, <span class="dv">204</span>)
    pingus.move()
    <span class="kw">if</span> pingus.x &gt;= <span class="dv">640</span> - <span class="dv">32</span>:
        pingus.<span class="dt">dir</span> = -<span class="dv">1</span>
    <span class="kw">if</span> pingus.x &lt;= <span class="dv">0</span>:
        pingus.<span class="dt">dir</span> = <span class="dv">1</span>
    pingus.display()</code></pre>
<p>Im Gegensatz zu den Orks aus den vorherigen Programmen bewegt sich Pingus mit jedem Frame nur einen Pixel weiter. Denn durch die vielen Bilder ist die Bewegung doch so exakt, da√ü es bei schnellerem Vorangehen aussieht, als ob Pingus auf Eis schlittert (bei Pinguinen sicher nicht un√ºblich, aber in diesem Fall nicht gewollt). Es ist eben kein <em>Running Ork</em> sondern nur ein <em>Walking Pingus</em>.</p>
<p>Wenn Ihr das nachprogrammiert und laufen la√üt, werdet Ihr sehen, da√ü das schon sehr nett aussieht, besonders auch wie die Zipfelm√ºtze des kleinen Pinguins im Takt hin und her wippt.</p>
<h2 id="pingus-links">Pingus Links</h2>
<p>Wenn Ihr Pingus spielen wollt, das Spiel gibt es trotz seines Alters immer noch <a href="https://pingus.seul.org/download.html">hier f√ºr Windows, Mac und Linux zum freien Download</a>. Auf meinen Macs l√§uft es auch noch, macht Spa√ü und die <a href="https://github.com/Pingus/pingus">Quellen k√∂nnt Ihr auf GitHub</a> finden.</p>
<h1 id="das-avoider-game">Das Avoider Game</h1>
<h2 id="game-stage-1">Game Stage 1</h2>
<p>Zum Abschlu√ü meiner kleinen, geplanten Tutorial-Reihe zu Processing.py, dem Python-Mode von Processing, m√∂chte ich mit und f√ºr Euch ein kleines, vollst√§ndiges Spieleprojekt programmieren. Es basiert zum einen auf dem ¬ª<a href="http://gamedev.michaeljameswilliams.com/as3-avoider-game-tutorial-base/">AS3 Avoider Game Tutorial</a>¬´, das <em>Michael James Williams</em> f√ºr ActionScript 3 und Flash geschrieben hat und das <em>Michael Haungs</em> dann in seinem Buch ¬ª<a href="https://www.amazon.de/Creative-Greenfoot-Michael-Haungs/dp/1783980389/ref=as_li_ss_tl?ie=UTF8&amp;qid=1503160042&amp;sr=8-1&amp;keywords=Creative+Greenfoot&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=e9b13f6f5e11c34b606d9e8d6bffcb10">Creative Greenfoot</a>¬´ nach Java und Greenfoot portierte. Zum anderen habe ich es noch mit Ideen aus einem Programm aus dem wundervollen Buch ¬ª<a href="https://www.amazon.de/Game-Programming-Express-Line-Learning/dp/0470068221/ref=as_li_ss_tl?&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=e73cc33dbae2dbe0f72dbbe560f3b008">Game Programming</a>¬´, einem PyGame-Tutorial von <em>Andy Harris</em> aufgepeppt, in dem ein Postflieger Inseln anfliegen, aber Wolken vermeiden mu√ü.</p>
<h3 id="die-spiel-idee">Die Spiel-Idee</h3>
<p><a href="https://www.flickr.com/photos/schockwellenreiter/36501204602/"><img src="images/avoider1.jpg" alt="Screenshot" /></a></p>
<p>Ziel des Spiels ist es, da√ü der Held seinen von oben herabregnenden Feinden ausweichen mu√ü. Doch in diesem Spiel ist nichts so, wie es scheint: Die Feinde sind l√§chelnde Smileys und unser Held ist ein h√§√ülicher Totenkopfsch√§del. Im ersten Stadium m√∂chte ich nur dieses einfache Spieleprinzip und einen <em>Highscore</em> implementieren, in den n√§chsten Tutorials m√∂chte ich dieses mit weiteren Variationen und Ideen zu einem interessanteren Spiel ausbauen.</p>
<h3 id="das-sprite-modul">Das Sprite-Modul</h3>
<p>Wie schon mehrmals praktiziert, lege ich erst einmal einen separaten Tab <code>spite.py</code> an, der in der Hauptsache die Klasse <code>Sprite</code> und die davon abgeleiteten Unterklassen <code>Skull</code> und <code>Smiley</code> beherbergt:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> random <span class="ch">import</span> randint

tw = th = <span class="dv">36</span>

<span class="kw">class</span> Sprite():
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY
        <span class="ot">self</span>.dx = <span class="dv">0</span>
        <span class="ot">self</span>.dy = <span class="dv">0</span>
        <span class="ot">self</span>.score = <span class="dv">0</span>
        <span class="ot">self</span>.over = <span class="ot">False</span>

    <span class="kw">def</span> checkCollision(<span class="ot">self</span>, otherSprite):
        <span class="kw">if</span> (<span class="ot">self</span>.x &lt; otherSprite.x + tw and otherSprite.x &lt; <span class="ot">self</span>.x + tw
            and <span class="ot">self</span>.y &lt; otherSprite.y + th and otherSprite.y &lt; <span class="ot">self</span>.y + th):
            <span class="kw">return</span> <span class="ot">True</span>
        <span class="kw">else</span>:
            <span class="kw">return</span> <span class="ot">False</span>

<span class="kw">class</span> Skull(Sprite):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im1 = loadImage(<span class="st">&quot;skull.png&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.x = mouseX
        <span class="kw">if</span> <span class="ot">self</span>.x &lt;= <span class="dv">0</span>:
            <span class="ot">self</span>.x = <span class="dv">0</span>
        <span class="kw">elif</span> <span class="ot">self</span>.x &gt;= width-tw:
            <span class="ot">self</span>.x = width - tw
            
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.im1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)

<span class="kw">class</span> Smiley(Sprite):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im0 = loadImage(<span class="st">&quot;smiley0.png&quot;</span>)
        <span class="ot">self</span>.im1 = loadImage(<span class="st">&quot;smiley1.png&quot;</span>)
        <span class="ot">self</span>.im2 = loadImage(<span class="st">&quot;smiley4.png&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.over = <span class="ot">False</span>
        <span class="ot">self</span>.y += <span class="ot">self</span>.dy
        <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height:
            <span class="ot">self</span>.over = <span class="ot">True</span>
            <span class="ot">self</span>.y = -randint(<span class="dv">50</span>, <span class="dv">250</span>)
            <span class="ot">self</span>.x = randint(<span class="dv">0</span>, width-tw)
            <span class="ot">self</span>.dy = randint(<span class="dv">2</span>, <span class="dv">10</span>)
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> (<span class="ot">self</span>.y &gt; -<span class="dv">30</span>) and (<span class="ot">self</span>.y &lt;= <span class="dv">200</span>):
            image(<span class="ot">self</span>.im0, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> (<span class="ot">self</span>.y &gt; <span class="dv">200</span>) and (<span class="ot">self</span>.y &lt;= <span class="dv">360</span>):
            image(<span class="ot">self</span>.im1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> (<span class="ot">self</span>.y &gt; <span class="dv">360</span>):
            image(<span class="ot">self</span>.im2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)</code></pre>
<p>F√ºr die Bilder der Akteure habe habe ich mich wieder bei den freien <a href="https://github.com/twitter/twemoji">Twitter Emojis</a> bedient und hier sind sie, damit Ihr das Spiel nachprogrammieren k√∂nnt:</p>
<p><img src="images/skull.png" alt="skull" /> <img src="images/smiley0.png" alt="smiley0" /> <img src="images/smiley1.png" alt="smiley1" /> <img src="images/smiley4.png" alt="smiley4" /></p>
<p>Die Bilder sind jeweils 36x36 Pixel gro√ü, das habe ich in den Variablen <code>tw</code> und <code>th</code> festgehalten. Unser armer Held, der den grinsenden Smileys ausweichen mu√ü, soll mit der Maus gesteuert werden. Dabei kann er sich nur horizontal bewegen, sein vertikaler Standort ist im Programm festverdrahtet. Mit den Zeilen</p>
<pre class="sourceCode python"><code class="sourceCode python">        <span class="kw">if</span> <span class="ot">self</span>.x &lt;= <span class="dv">0</span>:
            <span class="ot">self</span>.x = <span class="dv">0</span>
        <span class="kw">elif</span> <span class="ot">self</span>.x &gt;= width-tw:
            <span class="ot">self</span>.x = width - tw</code></pre>
<p>ist sichergestellt, da√ü er das Spielfeld nicht heimlich verlassen kann, um sich den Grinsebacken zu entziehen. Diese grinsen tats√§chlich nicht immer: Fr√∂hlich st√ºrzen sie herab, strecken auf der H√∂he unseres Helden die Zunge heraus, um dann, wenn sie merken, da√ü sie ihn nicht getroffen haben, mit ver√§rgertem Gesicht in die Tiefe zu st√ºrzen. Dazu wird ihnen je nach Y-Koordinate in der <code>display()</code>-Funktion das entsprechende Bildchen zugewiesen:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> (<span class="ot">self</span>.y &gt; -<span class="dv">30</span>) and (<span class="ot">self</span>.y &lt;= <span class="dv">200</span>):
            image(<span class="ot">self</span>.im0, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> (<span class="ot">self</span>.y &gt; <span class="dv">200</span>) and (<span class="ot">self</span>.y &lt;= <span class="dv">360</span>):
            image(<span class="ot">self</span>.im1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> (<span class="ot">self</span>.y &gt; <span class="dv">360</span>):
            image(<span class="ot">self</span>.im2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)</code></pre>
<p>Die Smileys st√ºrzen nat√ºrlich nicht ins Bodenlose. Ich wollte mir den Stre√ü ersparen und die Smiley-Objekte l√∂schen zu m√ºssen, nachdem sie das Spielfeld verlassen haben. Stattdessen habe ich im Hauptprogramm die Anzahl der Smileys konstant gesetzt (es sind zehn) und diese jedesmal, wenn sie das Spielefenster verlassen haben, habe ich sie an einer zuf√§lligen Position weit oberhalb des Fensters wieder neu positioniert:</p>
<pre class="sourceCode python"><code class="sourceCode python">            <span class="ot">self</span>.y = -randint(<span class="dv">50</span>, <span class="dv">250</span>)
            <span class="ot">self</span>.x = randint(<span class="dv">0</span>, width-tw)
            <span class="ot">self</span>.dy = randint(<span class="dv">2</span>, <span class="dv">10</span>)</code></pre>
<p>Mit der letzten Zeile wird ihnen dabei auch noch zuf√§llig eine neue Geschwindigkeit zugewiesen, so da√ü der Spieler nicht merkt, da√ü er es immer wieder mit den gleichen Akteuren zu tun hat.</p>
<h3 id="das-hauptprogramm">Das Hauptprogramm</h3>
<p>Nun zum Hauptprogramm. Es ist zwar nicht ganz so kurz geraten, wie einige andere, die ich hier schon vorgestellt hatte, aber eigentlich immer noch √ºbersichtlich:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> random <span class="ch">import</span> randint
<span class="ch">from</span> sprite <span class="ch">import</span> Skull, Smiley

w = <span class="dv">640</span>
tw = th = <span class="dv">36</span>
noSmileys = <span class="dv">10</span>
startGame = <span class="ot">True</span>
playGame = <span class="ot">False</span>
gameOver = <span class="ot">False</span>


skull = Skull(w/<span class="dv">2</span>, <span class="dv">320</span>)
smiley = []
<span class="kw">for</span> i in <span class="dt">range</span>(noSmileys):
    smiley.append(Smiley(randint(<span class="dv">0</span>, w-tw), randint(<span class="dv">50</span>, <span class="dv">250</span>)))

<span class="kw">def</span> setup():
    skull.score = <span class="dv">0</span>
    size(<span class="dv">640</span>, <span class="dv">480</span>)
    frameRate(<span class="dv">30</span>)
    skull.loadPics()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
        smiley[i].loadPics()
        smiley[i].dy = randint(<span class="dv">2</span>, <span class="dv">10</span>)
    font = loadFont(<span class="st">&quot;ComicSansMS-32.vlw&quot;</span>)
    textFont(font, <span class="dv">32</span>)
  
<span class="kw">def</span> draw():
    <span class="kw">global</span> startGame, playGame, gameOver
    background(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)
    text(<span class="st">&quot;Score: &quot;</span> + <span class="dt">str</span>(skull.score), <span class="dv">10</span>, <span class="dv">32</span>)
    <span class="kw">if</span> startGame:
        text(<span class="st">&quot;Klick to Play&quot;</span>, <span class="dv">200</span>, height/<span class="dv">2</span>)
        <span class="kw">if</span> mousePressed:
            startGame = <span class="ot">False</span>
            playGame = <span class="ot">True</span>
    <span class="kw">elif</span> playGame:
        skull.move()
        <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
            <span class="kw">if</span> skull.checkCollision(smiley[i]):
                playGame = <span class="ot">False</span>
                gameOver = <span class="ot">True</span>        
        skull.display()
        <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
            smiley[i].move()
            <span class="kw">if</span> smiley[i].over:
                skull.score += <span class="dv">1</span>
            smiley[i].display()
    <span class="kw">elif</span> gameOver:
        text(<span class="st">&quot;Game Over!&quot;</span>, <span class="dv">200</span>, height/<span class="dv">2</span>)</code></pre>
<p>F√ºr dieses Spiel habe ich mir mal erlaubt, die allgemein verp√∂nte Schrift <code>Comic Sans</code> zu verwenden, denn nichts ist hier so, wie es scheint: Das B√∂se ist gut und das Gute ist b√∂se. Die Entsprechende <code>.vlw</code>-Datei habe ich mit dem Tool ¬ªSchrift erstellen¬´ (in <code>Tools -&gt; Schrift erstellen ‚Ä¶</code>) erzeugt und wie die Bildchen in den <code>data</code>-Folder des Sketches abgelegt.</p>
<p>Nach dem Import der Klassen <code>Skull</code> und <code>Smiley</code> habe ich die entsprechenden Objekte erzeugt und ihnen ihre Startposition zugewiesen. Im <code>setup()</code> werden dann die Bilder geladen und den Smileys je eine eigene, zuf√§llige Geschwindigkeit (<code>dy</code>) zugewiesen.</p>
<p>Etwas komplizierter ist die <code>draw()</code>-Funktion aufgebaut. Wegen der Eigenheit von Processing.py, da√ü das Programm zwar aus der IDE heraus startet, das Programmfenster aber dann noch nicht den Fokus besitzt (den hat nach wie vor die IDE), war es notwendig, einen Startbildschirm vorzuschalten, der das Spiel erst nach einem Mausklick startet (und damit dem Programmfenster auch den Fokus gibt). Und nat√ºrlich sollte es auch einen ¬ªGame Over¬´-Bildschirm geben. Daher habe ich drei globale Zustandvariablen (<code>startGame</code>, <code>playGame</code> und <code>gameOver</code>) definiert und je nach ihrem Zustand werden dann die jeweiligen Bildschirme angezeigt.</p>
<p>Jeder Smiley, der das Fenster verl√§√üt, ohne mit dem Sch√§del zu kollidieren, erh√∂ht den Score des Spielers um einen Punkt. Dazu wurde die Variable <code>over</code> schon in der Klasse Smiley erzeugt, die jedesmal, wenn ein Smiley das Fenster verl√§√üt</p>
<pre class="sourceCode python"><code class="sourceCode python">        <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height:
            <span class="ot">self</span>.over = <span class="ot">True</span></code></pre>
<p>auf <code>True</code> gesetzt wird. Dies wird aber beim n√§chsten Druchlauf in</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.over = <span class="ot">False</span></code></pre>
<p>sofort wieder zur√ºckgesetzt. Im Hauptprogramm wird dann in den Zeilen</p>
<pre class="sourceCode python"><code class="sourceCode python">            <span class="kw">if</span> smiley[i].over:
                skull.score += <span class="dv">1</span></code></pre>
<p>der Zustand abgefragt und der Score entsprechend hochgesetzt.</p>
<p>Das Programm ist tats√§chlich spielbar. Passt der Spieler nicht auf und kollidiert mit einem der Smileys, dann ist es unbarmherzig zu Ende und es hei√üt ¬ªGame Over!¬´</p>
<h2 id="stage-2">Stage 2</h2>
<p>Nun ist es an der Zeit, das <em>Avoider Game</em>, das ich <a href="avoider1.md">hier begonnen</a> hatte ein wenig aufzupeppen und auch ein bi√üchen <em>Refactoring</em> vorzunehmen. Zum einen war es ja bisher sehr unnachgiebig und hat bei jeden Kontakt mit einem Smiley unseren Helden sofort sterben lassen. Nun m√∂chte ich ihm ein paar Leben mehr spendieren. Und zum anderen habe ich aus Bequemlichkeit einige Initialisierungen in der Klasse <code>Sprite</code> vorgenommen, die dort eigentlich nicht hingeh√∂rten, da sie redundant waren. Diese habe ich nun in die abgeleiteten Klassen verfrachtet. Dazu mu√üte ich aber die <code>__init__()</code>-Methode jeweils √ºberschreiben, so da√ü ich in den abgeleiteten Klassen <code>super()</code> aufrufen mu√üte, um die <code>__init()__</code>-Methode der Oberklasse auch aufzurufen. Ich will das mal an einem Beispiel zeigen. Die Klasse <code>Sprite</code> sieht nun so aus:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Sprite(<span class="dt">object</span>):
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY

    <span class="kw">def</span> checkCollision(<span class="ot">self</span>, otherSprite):
        <span class="kw">if</span> (<span class="ot">self</span>.x &lt; otherSprite.x + tw and otherSprite.x &lt; <span class="ot">self</span>.x + tw
            and <span class="ot">self</span>.y &lt; otherSprite.y + th and otherSprite.y &lt; <span class="ot">self</span>.y + th):
            <span class="kw">return</span> <span class="ot">True</span>
        <span class="kw">else</span>:
            <span class="kw">return</span> <span class="ot">False</span></code></pre>
<p>Sie hat nur noch eine minimale Initialisierung und besitzt auch nur noch die Methode <code>checkCollision()</code>, da nur diese an die daraus abgeleiteten Klassen vererbt wird. Die Klasse <code>Skull</code> hingegen und ihre <code>__init__()</code>-Methode sieht nun so aus:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Skull(Sprite):

    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="dt">super</span>(Skull, <span class="ot">self</span>).<span class="ot">__init__</span>(posX, posY)
        <span class="ot">self</span>.score = <span class="dv">0</span>
        <span class="ot">self</span>.health = <span class="dv">0</span></code></pre>
<p>Der Aufruf der <code>super()</code>-Methode ist so Python 2.7 spezifisch, in Python 3 wurde sie vereinfacht, aber Processing.py beruht nun mal auf Jython und Jython ist (noch?) Processing 2.7. Damit der <code>super()</code>-Aufruf funktioniert, mu√ü √ºbrigens das Eltern-Objekt von <code>object</code> abgeleitet werden, sonst kann Processing.py den Typ nicht erkennen.</p>
<p>Die Variablen <code>score</code> und <code>health</code> sind nur f√ºr das Objekt <code>Skull</code> von Bedeutung und wurden daher vom Eltern-Objekt in das abgeleitete Objekt verschoben.</p>
<h3 id="das-spiel">Das Spiel</h3>
<figure>
<img src="images/avoider2.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Um das Spiel angenehmer f√ºr den Spieler zu machen, bekam der Sch√§del ein paar Leben spendiert, die mit Herzchen symbolisiert werden, und au√üerdam bekam der <em>Game-Over-Screen</em> die M√∂glichkeit, von hier aus das Spiel noch einmal zu starten. Daf√ºr mu√üte ich der Klasse <code>Smiley</code>, deren <code>__init__()</code>-Methode nun so aussieht,</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="dt">super</span>(Smiley, <span class="ot">self</span>).<span class="ot">__init__</span>(posX, posY)
        <span class="ot">self</span>.outside = <span class="ot">False</span></code></pre>
<p>eine <code>reset()</code>-Methode verpassen, die die M√∂glichkeit gibt, zu Beginn eines neuen Spieles auch die Smileys wieder oberhalb des oberen Bildschirmrandes zu katapultieren, von der sie dann fr√∂hlich wieder herabfallen k√∂nnen. Sie ist ganz einfach gehalten, da die Berechnung der neuen Positionen im Hauptprogramm abl√§uft:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> reset(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY</code></pre>
<p>In der Initialisierung habe ich noch die Variable <code>over</code> in <code>outside</code> ge√§ndert. Auch wenn es nur Kosmetik ist, der Name schien mir verst√§ndlicher auszudr√ºcken, was die Variable machen soll. Ansonsten hat es in dem Reiter <code>sprite.py</code> keine weiteren Ver√§nderungen gegeben.</p>
<h3 id="das-hauptprogramm-1">Das Hauptprogramm</h3>
<p>Alle anderen Ver√§nderungen fanden im Hauptprogramm statt, das ein komplettes <em>Refactoring</em> erfahren hat. Die <code>draw()</code>-Schleife sieht nun so aus:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> draw():
    <span class="kw">global</span> heart
    background(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)
    text(<span class="st">&quot;Score: &quot;</span> + <span class="dt">str</span>(skull.score), <span class="dv">10</span>, <span class="dv">32</span>)
    <span class="kw">for</span> i in <span class="dt">range</span>(skull.health):
        image(heart, width - i*tw - tw - <span class="dv">2</span>, <span class="dv">2</span>)
    <span class="kw">if</span> startgame:
        startGame()
    <span class="kw">elif</span> playgame:
        playGame()
    <span class="kw">elif</span> gameover:
        gameOver()</code></pre>
<p>Nach der Definition des Hintergrundes wird ein <em>HUD</em> <em>(Head-Up-Display)</em> gezeichnet der in allen drei Bildschirmen gleich ist. Damit die Herzchen, obwohl von links nach rechts gezeichnet, immer in der rechten oberen Ecke kleben, sieht die Berechnung der Position etwas seltsam aus, aber es ist einfach nur die Weite des Bildschirms, abz√ºglich der Weite der Herzchen (in diesem Fall <code>tw = 36</code>) multipliziert mit der Anzahl der Herzchen und versehen mit einem Abstand von je zwei Pixeln.</p>
<p>Die einzelnen Bildschirme (Startbildschirm, das eigentliche Spiel und den Game-Over-Bildschirm) habe ich dann in eigene Funktionen verschoben und so aus der Hauptschleife ausgelagert. Sie sehen nun so aus:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> startGame():
    <span class="kw">global</span> startgame, playgame
    text(<span class="st">&quot;Klick to Play&quot;</span>, <span class="dv">200</span>, height/<span class="dv">2</span>)
    <span class="kw">if</span> mousePressed:
        startgame = <span class="ot">False</span>
        playgame = <span class="ot">True</span>
        
<span class="kw">def</span> playGame():
    <span class="kw">global</span> playgame, gameover
    skull.move()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
        <span class="kw">if</span> skull.checkCollision(smiley[i]):
            <span class="kw">if</span> skull.health &gt; <span class="dv">0</span>:
                skull.health -= <span class="dv">1</span>
                smiley[i].reset(randint(<span class="dv">0</span>, w-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>))
            <span class="kw">else</span>:
                playgame = <span class="ot">False</span>
                gameover = <span class="ot">True</span> 
    skull.display()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
        smiley[i].move()
        <span class="kw">if</span> smiley[i].outside:
            skull.score += <span class="dv">1</span>
        smiley[i].display()

<span class="kw">def</span> gameOver():
    <span class="kw">global</span> playgame, gameover
    text(<span class="st">&quot;Game Over!&quot;</span>, <span class="dv">200</span>, height/<span class="dv">2</span>)
    text(<span class="st">&quot;Klick to play again.&quot;</span>, <span class="dv">200</span>, <span class="dv">300</span>)
    <span class="kw">if</span> mousePressed:
        gameover = <span class="ot">False</span>
        <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
            smiley[i].reset(randint(<span class="dv">0</span>, w-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>))
        playgame = <span class="ot">True</span>
        skull.health = <span class="dv">5</span></code></pre>
<p>Zu <code>startGame()</code>ist eigentlich nichts zu schreiben, der Code sollte selbsterkl√§rend sein.</p>
<p>Anders ist es bei <code>playGame()</code>. Da der Kontakt des Sch√§dels mit einem Spieler nicht mehr zum sofortigen Spielende f√ºhrt, mu√ü bei Kontakt das Smiley ¬ªgel√∂scht¬´ werden, das hei√üt es wird wieder an eine zuf√§llige Stelle oberhalb des Bildschirms versetzt. Und bei jedem Kontakt bekommt der Spieler nat√ºrlich ein Leben und ein Herzchen abgezogen. Da ich schon soviel dar√ºber geschrieben habe, hier erst einmal das Herzchen, damit Ihr das Spiel auch nachprogrammieren k√∂nnt:</p>
<figure>
<img src="images/heart.png" alt="Heart" /><figcaption>Heart</figcaption>
</figure>
<p>√Ñhnliches gilt f√ºr den <code>gameOver</code>-Screen. Hier m√ºssen <em>alle</em> Smileys wieder an eine zuf√§llige Position oberhalb des Bildschirms katapultiert werden und nat√ºrlich erh√§lt der Sch√§del auch alle seine Leben wieder zur√ºck.</p>
<h3 id="der-quellcode-13">Der Quellcode</h3>
<p>Zum vollen Verst√§ndnis und damit Ihr das Spiel auch vollst√§ndig nachprogrammieren k√∂nnt, hier der vollst√§ndige Quellcode. Erst einmal der Code im Reiter <code>sprite.py</code>:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> random <span class="ch">import</span> randint

tw = th = <span class="dv">36</span>

<span class="kw">class</span> Sprite(<span class="dt">object</span>):
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY

    <span class="kw">def</span> checkCollision(<span class="ot">self</span>, otherSprite):
        <span class="kw">if</span> (<span class="ot">self</span>.x &lt; otherSprite.x + tw and otherSprite.x &lt; <span class="ot">self</span>.x + tw
            and <span class="ot">self</span>.y &lt; otherSprite.y + th and otherSprite.y &lt; <span class="ot">self</span>.y + th):
            <span class="kw">return</span> <span class="ot">True</span>
        <span class="kw">else</span>:
            <span class="kw">return</span> <span class="ot">False</span>

<span class="kw">class</span> Skull(Sprite):

    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="dt">super</span>(Skull, <span class="ot">self</span>).<span class="ot">__init__</span>(posX, posY)
        <span class="ot">self</span>.score = <span class="dv">0</span>
        <span class="ot">self</span>.health = <span class="dv">0</span>
            
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im1 = loadImage(<span class="st">&quot;skull.png&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.x = mouseX
        <span class="kw">if</span> <span class="ot">self</span>.x &lt;= <span class="dv">0</span>:
            <span class="ot">self</span>.x = <span class="dv">0</span>
        <span class="kw">elif</span> <span class="ot">self</span>.x &gt;= width-tw:
            <span class="ot">self</span>.x = width - tw
            
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.im1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)

<span class="kw">class</span> Smiley(Sprite):
    
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="dt">super</span>(Smiley, <span class="ot">self</span>).<span class="ot">__init__</span>(posX, posY)
        <span class="ot">self</span>.outside = <span class="ot">False</span>

    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im0 = loadImage(<span class="st">&quot;smiley0.png&quot;</span>)
        <span class="ot">self</span>.im1 = loadImage(<span class="st">&quot;smiley1.png&quot;</span>)
        <span class="ot">self</span>.im2 = loadImage(<span class="st">&quot;smiley4.png&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.outside = <span class="ot">False</span>
        <span class="ot">self</span>.y += <span class="ot">self</span>.dy
        <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height:
            <span class="ot">self</span>.outside = <span class="ot">True</span>
            <span class="ot">self</span>.y = -randint(<span class="dv">50</span>, <span class="dv">250</span>)
            <span class="ot">self</span>.x = randint(<span class="dv">0</span>, width-tw)
            <span class="ot">self</span>.dy = randint(<span class="dv">2</span>, <span class="dv">10</span>)
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> (<span class="ot">self</span>.y &gt; -<span class="dv">30</span>) and (<span class="ot">self</span>.y &lt;= <span class="dv">200</span>):
            image(<span class="ot">self</span>.im0, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> (<span class="ot">self</span>.y &gt; <span class="dv">200</span>) and (<span class="ot">self</span>.y &lt;= <span class="dv">360</span>):
            image(<span class="ot">self</span>.im1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> (<span class="ot">self</span>.y &gt; <span class="dv">360</span>):
            image(<span class="ot">self</span>.im2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
    
    <span class="kw">def</span> reset(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY</code></pre>
<p>Und dann das Hauptprogramm <code>avoider2</code>:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> random <span class="ch">import</span> randint
<span class="ch">from</span> sprite <span class="ch">import</span> Skull, Smiley

w = <span class="dv">640</span>
tw = th = <span class="dv">36</span>
noSmileys = <span class="dv">10</span>
startgame = <span class="ot">True</span>
playgame = <span class="ot">False</span>
gameover = <span class="ot">False</span>

skull = Skull(w/<span class="dv">2</span>, <span class="dv">320</span>)
smiley = []
<span class="kw">for</span> i in <span class="dt">range</span>(noSmileys):
    smiley.append(Smiley(randint(<span class="dv">0</span>, w-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>)))

<span class="kw">def</span> setup():
    <span class="kw">global</span> heart
    skull.score = <span class="dv">0</span>
    skull.health = <span class="dv">5</span>
    size(<span class="dv">640</span>, <span class="dv">480</span>)
    frameRate(<span class="dv">30</span>)
    skull.loadPics()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
        smiley[i].loadPics()
        smiley[i].dy = randint(<span class="dv">2</span>, <span class="dv">10</span>)
    font = loadFont(<span class="st">&quot;ComicSansMS-32.vlw&quot;</span>)
    textFont(font, <span class="dv">32</span>)
    heart = loadImage(<span class="st">&quot;heart.png&quot;</span>)
    <span class="co"># noCursor()</span>
    <span class="co"># cursor(HAND)</span>
  
<span class="kw">def</span> draw():
    <span class="kw">global</span> heart
    background(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)
    text(<span class="st">&quot;Score: &quot;</span> + <span class="dt">str</span>(skull.score), <span class="dv">10</span>, <span class="dv">32</span>)
    <span class="kw">for</span> i in <span class="dt">range</span>(skull.health):
        image(heart, width - i*tw - tw - <span class="dv">2</span>, <span class="dv">2</span>)
    <span class="kw">if</span> startgame:
        startGame()
    <span class="kw">elif</span> playgame:
        playGame()
    <span class="kw">elif</span> gameover:
        gameOver()

<span class="kw">def</span> startGame():
    <span class="kw">global</span> startgame, playgame
    text(<span class="st">&quot;Klick to Play&quot;</span>, <span class="dv">200</span>, height/<span class="dv">2</span>)
    <span class="kw">if</span> mousePressed:
        startgame = <span class="ot">False</span>
        playgame = <span class="ot">True</span>
        
<span class="kw">def</span> playGame():
    <span class="kw">global</span> playgame, gameover
    skull.move()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
        <span class="kw">if</span> skull.checkCollision(smiley[i]):
            <span class="kw">if</span> skull.health &gt; <span class="dv">0</span>:
                skull.health -= <span class="dv">1</span>
                smiley[i].reset(randint(<span class="dv">0</span>, w-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>))
            <span class="kw">else</span>:
                playgame = <span class="ot">False</span>
                gameover = <span class="ot">True</span> 
    skull.display()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
        smiley[i].move()
        <span class="kw">if</span> smiley[i].outside:
            skull.score += <span class="dv">1</span>
        smiley[i].display()

<span class="kw">def</span> gameOver():
    <span class="kw">global</span> playgame, gameover
    text(<span class="st">&quot;Game Over!&quot;</span>, <span class="dv">200</span>, height/<span class="dv">2</span>)
    text(<span class="st">&quot;Klick to play again.&quot;</span>, <span class="dv">200</span>, <span class="dv">300</span>)
    <span class="kw">if</span> mousePressed:
        gameover = <span class="ot">False</span>
        <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
            smiley[i].reset(randint(<span class="dv">0</span>, w-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>))
        playgame = <span class="ot">True</span>
        skull.health = <span class="dv">5</span></code></pre>
<p>Ich glaube, das <em>Refactoring</em> hat dem Quellcode gutgetan, er ist deutlich lesbarer und verst√§ndlicher geworden. Das Spiel ist so schon richtig gut spielbar, in einer n√§chsten Version m√∂chte ich aber noch ein paar <em>Gimmicks</em> einbauen.</p>
<h2 id="stage-3-sternenhimmel">Stage 3: Sternenhimmel</h2>
<p>Als n√§chstes wollte ich dem kleinen Avoider-Spiel ein wenig optische Tiefe verpassen. Daher habe ich einen Sternenhimmel inszeniert, bei dem die kleinen Sternen im fernen Hintergrund sich sehr langsam bewegen und die gr√∂√üeren Sterne etwas schneller. So, wie wenn man bei einer Zugfahrt aus dem Fenster schaut, da scheinen die nahen B√§ume auch schnell vorbeizufliegen, w√§hrend der Wald im Hintergrund sich nur langsam bewegt. Diese Wahrnehmung nennt man <a href="https://de.wikipedia.org/wiki/Bewegungsparallaxe">Bewegungsparallaxe</a> und sie wird besonders gerne in <a href="https://de.wikipedia.org/wiki/Jump_%E2%80%99n%E2%80%99_Run">Plattformspielen</a> angewandt.</p>
<figure>
<img src="images/avoider3.jpg" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<h3 id="die-sterne">Die Sterne</h3>
<p>Um dies zu inszenieren, habe ich erst einmal im Reiter <code>sprite.py</code> eine Klasse <code>Star</code> angelegt:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Star(<span class="dt">object</span>):
    
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY, dia, speed):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY
        <span class="ot">self</span>.r = dia
        <span class="ot">self</span>.dy = speed
        <span class="ot">self</span>.a = <span class="dv">255</span> <span class="co"># Transparency</span>
    
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.outside = <span class="ot">False</span>
        <span class="ot">self</span>.y += <span class="ot">self</span>.dy
        <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height:
            <span class="ot">self</span>.outside = <span class="ot">True</span>
            <span class="ot">self</span>.y = -<span class="dv">2</span>*<span class="ot">self</span>.r
            <span class="ot">self</span>.x = randint(<span class="dv">0</span>, width - <span class="dv">2</span>*<span class="ot">self</span>.r)
    
    <span class="kw">def</span> display(<span class="ot">self</span>):
        fill(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>, <span class="ot">self</span>.a)
        noStroke()
        ellipse(<span class="ot">self</span>.x, <span class="ot">self</span>.y, <span class="ot">self</span>.r, <span class="ot">self</span>.r)</code></pre>
<p>Ich h√§tte die Sterne nat√ºrlich auch von der Klasse <code>Sprite</code> ableiten k√∂nnen, aber da f√ºr sie ja keine Kollisionserkennung ben√∂tigt wird, hielt ich dies f√ºr <em>Overkill</em>. Da zumindest die gr√∂√üeren Sterne blinken sollen, bekommmen sie eine Alpha-Kanal f√ºr Transparenz zugewiesen (<code>self.a</code>). Ansonsten bewegen sie sich genauso wie die Smileys von oben nach unten, nur viel, viel langsamer.</p>
<p>Jeder Stern wird mit seiner Position, seiner Gr√∂√üe und seiner Geschwindigkeit initialisiert. Per Default erh√§lt er die gr√∂√ütm√∂gliche Transparenz, das hei√üt, er ist strahlend wei√ü.</p>
<p>Im Hauptprogramm werden f√ºr die Sterne zwei Listen angelegt, eine (<code>bstar[]</code>) f√ºr die weit entfernten, kleinen Sterne und eine <code>nStar</code> f√ºr die gr√∂√üeren, n√§her erscheinenden Sterne. Das Auff√ºllen aller Listen habe ich in die <code>setup</code>-Funktion verschoben, dort wird nun die Funktion <code>loadData()</code> aufgerufen:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> loadData():
    <span class="kw">for</span> i in <span class="dt">range</span>(noSmileys):
        smiley.append(Smiley(randint(<span class="dv">0</span>, w-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>)))
    <span class="kw">for</span> i in <span class="dt">range</span>(nobStars):
        bStar.append(Star(randint(<span class="dv">0</span>, w<span class="dv">-2</span>), randint(<span class="dv">2</span>, h<span class="dv">-2</span>), <span class="dv">1</span>, <span class="fl">0.1</span>))
    <span class="kw">for</span> i in <span class="dt">range</span>(nonStars):
        nStar.append(Star(randint(<span class="dv">0</span>, w<span class="dv">-4</span>), randint(<span class="dv">2</span>, h<span class="dv">-2</span>), randint(<span class="dv">2</span>, <span class="dv">3</span>), <span class="fl">0.2</span>))</code></pre>
<p>Die kleinen Sterne werden mit einem Durchmesser von 1 initialisert, die gr√∂√üeren Sterne bekommen per Zufallszahl entweder einen Durchmesser von 2 oder 3 zugewiesen. Interessant ist die Geschwindigkeit, mit der die Sterne sich bewegen: 0.1 per Frame f√ºr die kleinen, 0.2 per Frame f√ºr die gro√üen. Processing kommt intern erstaunlich gut mit diesen dezimalen Werten bei der Positionierung zurecht, obwohl ja eigentlich nur ganzzahlige Pixel m√∂glich sind.</p>
<p>Es gibt jeweils eine feste Anzahl von Sternen, wie bei den Smileys auch werden sie, wenn sie den unteren Bildrand passiert haben, wieder auf eine zuf√§llige Position oberhalb des Fensters zur√ºckversetzt.</p>
<p>Die Bewegung der Sterne findet nat√ºrlich in der Funktion <code>playGame()</code> statt, und zwar als erstes, bevor alle anderen Akteure gezeichnet werden (schlie√ülich bilden sie den Hintergrund des Spiels):</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(bStar)):
        bStar[i].move()
        bStar[i].display()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(nStar)):
        nStar[i].move()
        <span class="kw">if</span> (frameCount % randint(<span class="dv">15</span>, <span class="dv">30</span>)) &lt; randint(<span class="dv">1</span>, <span class="dv">15</span>):
            nStar[i].a = <span class="dv">120</span>
        <span class="kw">else</span>:
            nStar[i].a = <span class="dv">255</span>
        nStar[i].display()</code></pre>
<p>Die gr√∂√üeren Sterne sollen zus√§tzlich zur Bewegung auch noch Blinken, daher habe ich ihnen zuf√§llige Intervalle zugewiesen, in denen der Alpha-Kanal auf 120 gesetzt wird (<code>nStar[i].a = 120</code>). Die Werte f√ºr die Zufallszahlen habe ich experimentell herausgefunden, Ihr k√∂nnt ruhig auch einmal andere Intervalle ausprobieren.</p>
<h3 id="der-quellcode-14">Der Quellcode</h3>
<p>Und nun zum Nachvollziehen der vollst√§ndige Quellcode. Zuerst der Code aus dem Reiter <code>sprite.py</code>:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> random <span class="ch">import</span> randint

tw = th = <span class="dv">36</span>

<span class="kw">class</span> Sprite(<span class="dt">object</span>):
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY

    <span class="kw">def</span> checkCollision(<span class="ot">self</span>, otherSprite):
        <span class="kw">if</span> (<span class="ot">self</span>.x &lt; otherSprite.x + tw and otherSprite.x &lt; <span class="ot">self</span>.x + tw
            and <span class="ot">self</span>.y &lt; otherSprite.y + th and otherSprite.y &lt; <span class="ot">self</span>.y + th):
            <span class="kw">return</span> <span class="ot">True</span>
        <span class="kw">else</span>:
            <span class="kw">return</span> <span class="ot">False</span>


<span class="kw">class</span> Skull(Sprite):

    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="dt">super</span>(Skull, <span class="ot">self</span>).<span class="ot">__init__</span>(posX, posY)
        <span class="ot">self</span>.score = <span class="dv">0</span>
        <span class="ot">self</span>.health = <span class="dv">0</span>
            
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im1 = loadImage(<span class="st">&quot;skull.png&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.x = mouseX
        <span class="kw">if</span> <span class="ot">self</span>.x &lt;= <span class="dv">0</span>:
            <span class="ot">self</span>.x = <span class="dv">0</span>
        <span class="kw">elif</span> <span class="ot">self</span>.x &gt;= width-tw:
            <span class="ot">self</span>.x = width - tw
            
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.im1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)

<span class="kw">class</span> Smiley(Sprite):
    
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="dt">super</span>(Smiley, <span class="ot">self</span>).<span class="ot">__init__</span>(posX, posY)
        <span class="ot">self</span>.outside = <span class="ot">False</span>

    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im0 = loadImage(<span class="st">&quot;smiley0.png&quot;</span>)
        <span class="ot">self</span>.im1 = loadImage(<span class="st">&quot;smiley1.png&quot;</span>)
        <span class="ot">self</span>.im2 = loadImage(<span class="st">&quot;smiley4.png&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.outside = <span class="ot">False</span>
        <span class="ot">self</span>.y += <span class="ot">self</span>.dy
        <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height:
            <span class="ot">self</span>.outside = <span class="ot">True</span>
            <span class="ot">self</span>.y = -randint(<span class="dv">50</span>, <span class="dv">250</span>)
            <span class="ot">self</span>.x = randint(<span class="dv">0</span>, width-tw)
            <span class="ot">self</span>.dy = randint(<span class="dv">4</span>, <span class="dv">10</span>)
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> (<span class="ot">self</span>.y &gt; -<span class="dv">30</span>) and (<span class="ot">self</span>.y &lt;= <span class="dv">250</span>):
            image(<span class="ot">self</span>.im0, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> (<span class="ot">self</span>.y &gt; <span class="dv">250</span>) and (<span class="ot">self</span>.y &lt;= <span class="dv">320</span>):
            image(<span class="ot">self</span>.im1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> (<span class="ot">self</span>.y &gt; <span class="dv">320</span>):
            image(<span class="ot">self</span>.im2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
    
    <span class="kw">def</span> reset(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY
            
<span class="kw">class</span> Star(<span class="dt">object</span>):
    
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY, dia, speed):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY
        <span class="ot">self</span>.r = dia
        <span class="ot">self</span>.dy = speed
        <span class="ot">self</span>.a = <span class="dv">255</span> <span class="co"># Transparency</span>
    
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.outside = <span class="ot">False</span>
        <span class="ot">self</span>.y += <span class="ot">self</span>.dy
        <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height:
            <span class="ot">self</span>.outside = <span class="ot">True</span>
            <span class="ot">self</span>.y = -<span class="dv">2</span>*<span class="ot">self</span>.r
            <span class="ot">self</span>.x = randint(<span class="dv">0</span>, width - <span class="dv">2</span>*<span class="ot">self</span>.r)
    
    <span class="kw">def</span> display(<span class="ot">self</span>):
        fill(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>, <span class="ot">self</span>.a)
        noStroke()
        ellipse(<span class="ot">self</span>.x, <span class="ot">self</span>.y, <span class="ot">self</span>.r, <span class="ot">self</span>.r)</code></pre>
<p>Au√üer dem schon oben besprochen Objekt <code>Star</code> gibt es hier nichts Neues. Aber auch im Hauptprogramm sind nur die erw√§hnten √Ñnderungen neu:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> random <span class="ch">import</span> randint
<span class="ch">from</span> sprite <span class="ch">import</span> Skull, Smiley, Star

w = <span class="dv">640</span>
h = <span class="dv">480</span>
tw = th = <span class="dv">36</span>
noSmileys = <span class="dv">10</span>
nobStars = <span class="dv">30</span>
nonStars = <span class="dv">15</span>
startgame = <span class="ot">True</span>
playgame = <span class="ot">False</span>
gameover = <span class="ot">False</span>

skull = Skull(w/<span class="dv">2</span>, <span class="dv">320</span>)
smiley = []
bStar = []
nStar = []

<span class="kw">def</span> setup():
    <span class="kw">global</span> heart
    skull.score = <span class="dv">0</span>
    skull.health = <span class="dv">5</span>
    size(<span class="dv">640</span>, <span class="dv">480</span>)
    frameRate(<span class="dv">30</span>)
    loadData()
    skull.loadPics()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
        smiley[i].loadPics()
        smiley[i].dy = randint(<span class="dv">4</span>, <span class="dv">10</span>)
    font = loadFont(<span class="st">&quot;ComicSansMS-32.vlw&quot;</span>)
    textFont(font, <span class="dv">32</span>)
    heart = loadImage(<span class="st">&quot;heart.png&quot;</span>)
    <span class="co"># noCursor()</span>
    <span class="co"># cursor(HAND)</span>
  
<span class="kw">def</span> draw():
    <span class="kw">global</span> heart
    background(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)
    fill(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>)
    text(<span class="st">&quot;Score: &quot;</span> + <span class="dt">str</span>(skull.score), <span class="dv">10</span>, <span class="dv">32</span>)
    <span class="kw">for</span> i in <span class="dt">range</span>(skull.health):
        image(heart, width - i*tw - tw - <span class="dv">2</span>, <span class="dv">2</span>)
    <span class="kw">if</span> startgame:
        startGame()
    <span class="kw">elif</span> playgame:
        playGame()
    <span class="kw">elif</span> gameover:
        gameOver()

<span class="kw">def</span> loadData():
    <span class="kw">for</span> i in <span class="dt">range</span>(noSmileys):
        smiley.append(Smiley(randint(<span class="dv">0</span>, w-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>)))
    <span class="kw">for</span> i in <span class="dt">range</span>(nobStars):
        bStar.append(Star(randint(<span class="dv">0</span>, w<span class="dv">-2</span>), randint(<span class="dv">2</span>, h<span class="dv">-2</span>), <span class="dv">1</span>, <span class="fl">0.1</span>))
    <span class="kw">for</span> i in <span class="dt">range</span>(nonStars):
        nStar.append(Star(randint(<span class="dv">0</span>, w<span class="dv">-4</span>), randint(<span class="dv">2</span>, h<span class="dv">-2</span>), randint(<span class="dv">2</span>, <span class="dv">3</span>), <span class="fl">0.2</span>))

<span class="kw">def</span> startGame():
    <span class="kw">global</span> startgame, playgame
    text(<span class="st">&quot;Klick to Play&quot;</span>, <span class="dv">200</span>, height/<span class="dv">2</span>)
    <span class="kw">if</span> mousePressed:
        startgame = <span class="ot">False</span>
        playgame = <span class="ot">True</span>
        
<span class="kw">def</span> playGame():
    <span class="kw">global</span> playgame, gameover
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(bStar)):
        bStar[i].move()
        bStar[i].display()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(nStar)):
        nStar[i].move()
        <span class="kw">if</span> (frameCount % randint(<span class="dv">15</span>, <span class="dv">30</span>)) &lt; randint(<span class="dv">1</span>, <span class="dv">15</span>):
            nStar[i].a = <span class="dv">120</span>
        <span class="kw">else</span>:
            nStar[i].a = <span class="dv">255</span>
        nStar[i].display()
    skull.move()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
        <span class="kw">if</span> skull.checkCollision(smiley[i]):
            <span class="kw">if</span> skull.health &gt; <span class="dv">0</span>:
                skull.health -= <span class="dv">1</span>
                smiley[i].reset(randint(<span class="dv">0</span>, w-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>))
            <span class="kw">else</span>:
                playgame = <span class="ot">False</span>
                gameover = <span class="ot">True</span> 
    skull.display()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
        smiley[i].move()
        <span class="kw">if</span> smiley[i].outside:
            skull.score += <span class="dv">1</span>
        smiley[i].display()

<span class="kw">def</span> gameOver():
    <span class="kw">global</span> playgame, gameover
    text(<span class="st">&quot;Game Over!&quot;</span>, <span class="dv">200</span>, height/<span class="dv">2</span>)
    text(<span class="st">&quot;Klick to play again.&quot;</span>, <span class="dv">200</span>, <span class="dv">300</span>)
    <span class="kw">if</span> mousePressed:
        gameover = <span class="ot">False</span>
        <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
            smiley[i].reset(randint(<span class="dv">0</span>, w-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>))
        playgame = <span class="ot">True</span>
        skull.health = <span class="dv">5</span></code></pre>
<p>Das Spiel ist schon recht spielbar geworden, durch die Sterne entsteht tats√§chlich die Illusion von Tiefe und es ist auch nicht einfach, den Sch√§del f√ºr l√§ngere Zeit an den herunterfallenden Smileys vorbei zu man√∂vrieren. Irgendwann erwischt es einen immer.</p>
<h2 id="stage-4-powerup-und-powerdown">Stage 4: PowerUp und PowerDown</h2>
<p>Im vierten und letzten Teil meiner kleinen Serie √ºber die Programmierung des Avoider-Spiels in Processing.py wollte ich das Spiel noch mit ein paar zus√§tzlichen Akteuren aufpeppen. Dazu habe ich <em>Power Items</em> eingef√ºhrt, die entweder dem Spieler zus√§tzliche Leben geben oder nehmen, also je ein <em>PowerUp</em> und ein <em>PowerDown</em>. Als besonderes Highlight bewegen diese sich auf anderen Wegen durch das Spielefenster als die Smileys und sind daher etwas unberechenbarer f√ºr den Spieler. Gem√§√ü dem Motto des Spieles, da√ü man niemanden trauen darf, das gut aussieht, ist das PowerUp, das dem Spieler ein weiteres Leben schenkt, ein grimmig aussehendes Gespenst und das PowerDown, das ihm ein Leben nimmt, ein lecker aussehendes Tassent√∂rtchen.</p>
<p><img src="images/ghost.png" alt="Ghost" /> <img src="images/cupcake.png" alt="Cupcake" /></p>
<p>Auch diese Bilder habe ich wieder den freien <a href="https://github.com/twitter/twemoji">Twitter Emojis</a> <em>(Twemojis)</em> entnommen und hier sind sie, damit Ihr das Spiel nachprogrammieren k√∂nnt.</p>
<h3 id="power-items">Power Items</h3>
<p>Als erstes habe ich im Reiter <code>sprite.py</code> eine Klasse <code>PowerItem</code> angelegt, die von <code>Sprite</code> erbt:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> PowerItem(Sprite):
    
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY, tX, tY, eT):
        <span class="dt">super</span>(PowerItem, <span class="ot">self</span>).<span class="ot">__init__</span>(posX, posY)
        <span class="ot">self</span>.origX = posX
        <span class="ot">self</span>.origY = posY
        <span class="ot">self</span>.targetX = tX
        <span class="ot">self</span>.targetY = tY
        <span class="ot">self</span>.expireTime = eT
        <span class="ot">self</span>.duration = <span class="ot">self</span>.expireTime/<span class="fl">2.0</span>
        <span class="ot">self</span>.counter = <span class="dv">0</span>
        <span class="ot">self</span>.pause = randint(<span class="dv">10</span>, <span class="dv">150</span>)
        
    <span class="kw">def</span> curveX(<span class="ot">self</span>, x):
        <span class="kw">return</span> x
    
    <span class="kw">def</span> curveY(<span class="ot">self</span>, y):
        <span class="kw">return</span> y
    
    <span class="kw">def</span> easing(<span class="ot">self</span>):
        <span class="ot">self</span>.counter += <span class="dv">1</span>
        <span class="ot">self</span>.fX = <span class="ot">self</span>.fY = (<span class="ot">self</span>.counter)/<span class="dt">float</span>(<span class="ot">self</span>.duration)
        <span class="ot">self</span>.fX = <span class="ot">self</span>.curveX(<span class="ot">self</span>.fX)
        <span class="ot">self</span>.fY = <span class="ot">self</span>.curveY(<span class="ot">self</span>.fY)
        <span class="ot">self</span>.x = (<span class="ot">self</span>.targetX * <span class="ot">self</span>.fX) + (<span class="ot">self</span>.origX * (<span class="fl">1.0</span> - <span class="ot">self</span>.fX))
        <span class="ot">self</span>.y = (<span class="ot">self</span>.targetY * <span class="ot">self</span>.fY) + (<span class="ot">self</span>.origY * (<span class="fl">1.0</span> - <span class="ot">self</span>.fY))

    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.expireTime -= <span class="dv">1</span>
        <span class="kw">if</span> <span class="ot">self</span>.expireTime &lt; <span class="dv">0</span>:
            <span class="ot">self</span>.pause -= <span class="dv">1</span>
            <span class="kw">if</span> <span class="ot">self</span>.pause &lt; <span class="dv">0</span>:
                <span class="ot">self</span>.reset()
    
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="co"># print(self.x, self.y)</span>
        image(<span class="ot">self</span>.im1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
    
    <span class="kw">def</span> reset(<span class="ot">self</span>):
        <span class="ot">self</span>.origX = randint(-<span class="dv">150</span>, width-tw)
        <span class="ot">self</span>.origY = -randint(<span class="dv">50</span>, <span class="dv">250</span>)
        <span class="ot">self</span>.targetX = randint(tw, width-tw)
        <span class="ot">self</span>.targetY = randint(tw, height-tw)
        <span class="ot">self</span>.expireTime = <span class="ot">self</span>.duration*<span class="fl">2.0</span>
        <span class="ot">self</span>.counter = <span class="dv">0</span>
        <span class="ot">self</span>.pause = randint(<span class="dv">10</span>, <span class="dv">150</span>)</code></pre>
<p>Die <em>Power Items</em> haben nur eine gewisse Lebensdauer und bewegen sich w√§hrend ihrer Lebenszeit (<code>eT</code>) von der Startposition (<code>posX</code>, <code>posY</code>) zur Zielposition (<code>tX</code>, <code>tY</code>). Diese Parameter m√ºssen daher dem Konstruktor √ºbergeben werden.</p>
<p>Wie alle Akteure prasseln die <em>Power Items</em> zu Beginn des Spieles quasi gleichzeitig vom oberen Fensterrand auf den Spieler nieder, damit sich die Lage in den folgenden Runden entspannt, habe ich den einzelnen Items nach Ende ihren Lebens eine Pause verordnet, deren L√§nge vom Zufallszahlengenerator bestimmt wird, bevor sie wieder die Arena betreten d√ºrfen.</p>
<h3 id="easing">Easing</h3>
<p>Das Prinzip des <em><a href="https://processing.org/examples/easing.html">Easings</a></em> hatte ich <a href="rauhnaechte.md">in diesem Beispiel</a> schon einmal eingef√ºhrt. Es war ein einfaches, lineares Easing, in dem die Figur immer langsamer wurde, je mehr sie sich dem Ziel n√§herte. Dieses lineare Easing ist auch in der Klasse <code>PowerItem</code> implementiert, aber so, da√ü es ver√§ndert werden kann, wenn die abgeleiteten Klassen die Methoden <code>curveX()</code> und/oder <code>curveY()</code> √ºberschreiben. Au√üerdem wird die Geschwindigkeit und neue Position unter anderem auch von der Lebensdauer des <em>Power Items</em> beeinflu√üt.</p>
<p>In den von <code>PowerItem</code> abgeleiteten Klassen <code>Ghost</code> und <code>Cupcake</code> mu√üten also nur die entsprechenden Bildchen geladen und die Methode <code>curveY()</code> √ºberschreiben:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Ghost(PowerItem):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im1 = loadImage(<span class="st">&quot;ghost.png&quot;</span>)
    
    
    <span class="kw">def</span> curveY(<span class="ot">self</span>, y):
        <span class="kw">return</span> y**<span class="dv">5</span>

<span class="kw">class</span> Cupcake(PowerItem):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im1 = loadImage(<span class="st">&quot;cupcake.png&quot;</span>)
    
    <span class="kw">def</span> curveY(<span class="ot">self</span>, y):
        <span class="kw">return</span> <span class="dv">3</span>*sin(<span class="dv">3</span>*y)</code></pre>
<p>Im Falle des <em>Power Up</em>, des Gespenstes, bewegt sich das <em>Power Item</em> in einer expotentionellen Kurve von oben nach unten und wird immer schneller, je tiefer es f√§llt. Der Spieler mu√ü sich schon beeilen, um mit diesem Item zu kollidieren, um ein zus√§tzlichres Leben einzufangen. Dagegen habe ich mir im Falle des Tassent√∂rtchens etwas Gemeines √ºberlegt: Die einzelnen T√∂rtchen bewegen sich auf einer √ºbergro√üen Sinuskurve durch das Geschehen. Daher kann es durchaus passieren, da√ü die T√∂rtchen, nachdem sie das Fenster am unteren Rand verlassen haben, von dort auch wieder auftauchen und nach oben schie√üen. Das macht es dem Spieler schwieriger, ihnen auszuweichen. Also: Die Kollision mit den <em>Power Ups</em> ist schwierig, umgekehrt it es schwer, den <em>Power Downs</em> auszuweichen. Schie√ülich soll es dem Spieler ja nicht zu einfach vorkommen.</p>
<p>Die jeweiligen Werte in der Methode <code>curveY()</code> habe ich durch wildes Experimentieren herausgefunden.</p>
<h3 id="das-hauptprogramm-2">Das Hauptprogramm</h3>
<figure>
<img src="images/screenshot-1099.png" alt="Screenshot" /><figcaption>Screenshot</figcaption>
</figure>
<p>Im Hauptprogramm sind die wichtigsten √Ñnderungen in der Funktion <code>playGame()</code> vorgenommen worden, die folgende zus√§tzliche Zeilen erhielt:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(ghost)):
        ghost[i].easing()
        ghost[i].move()
        <span class="kw">if</span> ghost[i].checkCollision(skull):
            <span class="kw">if</span> skull.health &lt; <span class="dv">5</span>:
                skull.health += <span class="dv">1</span>
                ghost[i].reset()
        ghost[i].display()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(cupcake)):
        cupcake[i].easing()
        cupcake[i].move()
        <span class="kw">if</span> cupcake[i].checkCollision(skull):
            skull.health -= <span class="dv">1</span>
            cupcake[i].reset()
        cupcake[i].display()</code></pre>
<p>F√ºr jedes <em>Power Item</em> wird erst das <em>Easing</em> berechnet, dann die neue Position bestimmt, √ºberpr√ºft ob es mit dem Spieler kollidiert und dann wird es angezeigt. Au√üerdem lasse ich als kleine Optimierung nicht mehr in jedem Frame den Spieler pr√ºfen, ob er mit einem der Smileys kollidiert (das mu√ü er n√§mlich jedes Mal mit <em>allen</em> Smileys machen), sondern nun √ºberpr√ºfen -- wie bei den <em>Power Items</em> -- die Smileys, ob sie mit dem Spieler kollidieren:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
        smiley[i].move()
        <span class="kw">if</span> smiley[i].checkCollision(skull):
            skull.health -= <span class="dv">1</span>
            smiley[i].reset(randint(<span class="dv">0</span>, w-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>))
        <span class="kw">if</span> smiley[i].outside:
            skull.score += <span class="dv">1</span>
        smiley[i].display()</code></pre>
<p>Das Spiel startet in meiner Version mit zehn Smileys, drei Gespenstern und f√ºnf Tassent√∂rtchen. Das sind 18 Akteure auf die der Spieler aufpassen mu√ü und das macht das Spiel schon ganz sch√∂n schwierig, aber ohne da√ü es unfair wirkt oder gar unspielbar ist.</p>
<h3 id="der-quellcode-15">Der Quellcode</h3>
<p>Und nun -- wie immer -- der vollst√§ndige Quellcode, damit Ihr das Spiel nachprogrammieren und nachvollziehen k√∂nnt. Als erstes wieder der Code aus dem Reiter <code>sprite.py</code>:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> random <span class="ch">import</span> randint

tw = th = <span class="dv">36</span>

<span class="kw">class</span> Sprite(<span class="dt">object</span>):
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY

    <span class="kw">def</span> checkCollision(<span class="ot">self</span>, otherSprite):
        <span class="kw">if</span> (<span class="ot">self</span>.x &lt; otherSprite.x + tw and otherSprite.x &lt; <span class="ot">self</span>.x + tw
            and <span class="ot">self</span>.y &lt; otherSprite.y + th and otherSprite.y &lt; <span class="ot">self</span>.y + th):
            <span class="kw">return</span> <span class="ot">True</span>
        <span class="kw">else</span>:
            <span class="kw">return</span> <span class="ot">False</span>


<span class="kw">class</span> Skull(Sprite):

    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="dt">super</span>(Skull, <span class="ot">self</span>).<span class="ot">__init__</span>(posX, posY)
        <span class="ot">self</span>.score = <span class="dv">0</span>
        <span class="ot">self</span>.health = <span class="dv">0</span>
            
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im1 = loadImage(<span class="st">&quot;skull.png&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.x = mouseX
        <span class="kw">if</span> <span class="ot">self</span>.x &lt;= <span class="dv">0</span>:
            <span class="ot">self</span>.x = <span class="dv">0</span>
        <span class="kw">elif</span> <span class="ot">self</span>.x &gt;= width-tw:
            <span class="ot">self</span>.x = width - tw
            
    <span class="kw">def</span> display(<span class="ot">self</span>):
        image(<span class="ot">self</span>.im1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)

<span class="kw">class</span> Smiley(Sprite):
    
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY):
        <span class="dt">super</span>(Smiley, <span class="ot">self</span>).<span class="ot">__init__</span>(posX, posY)
        <span class="ot">self</span>.outside = <span class="ot">False</span>

    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im0 = loadImage(<span class="st">&quot;smiley0.png&quot;</span>)
        <span class="ot">self</span>.im1 = loadImage(<span class="st">&quot;smiley1.png&quot;</span>)
        <span class="ot">self</span>.im2 = loadImage(<span class="st">&quot;smiley4.png&quot;</span>)
        
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.outside = <span class="ot">False</span>
        <span class="ot">self</span>.y += <span class="ot">self</span>.dy
        <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height:
            <span class="ot">self</span>.outside = <span class="ot">True</span>
            <span class="ot">self</span>.y = -randint(<span class="dv">50</span>, <span class="dv">250</span>)
            <span class="ot">self</span>.x = randint(<span class="dv">0</span>, width-tw)
            <span class="ot">self</span>.dy = randint(<span class="dv">4</span>, <span class="dv">10</span>)
        
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="kw">if</span> (<span class="ot">self</span>.y &gt; -<span class="dv">30</span>) and (<span class="ot">self</span>.y &lt;= <span class="dv">250</span>):
            image(<span class="ot">self</span>.im0, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> (<span class="ot">self</span>.y &gt; <span class="dv">250</span>) and (<span class="ot">self</span>.y &lt;= <span class="dv">320</span>):
            image(<span class="ot">self</span>.im1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
        <span class="kw">elif</span> (<span class="ot">self</span>.y &gt; <span class="dv">320</span>):
            image(<span class="ot">self</span>.im2, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
    
    <span class="kw">def</span> reset(<span class="ot">self</span>, posX, posY):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY

<span class="kw">class</span> PowerItem(Sprite):
    
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY, tX, tY, eT):
        <span class="dt">super</span>(PowerItem, <span class="ot">self</span>).<span class="ot">__init__</span>(posX, posY)
        <span class="ot">self</span>.origX = posX
        <span class="ot">self</span>.origY = posY
        <span class="ot">self</span>.targetX = tX
        <span class="ot">self</span>.targetY = tY
        <span class="ot">self</span>.expireTime = eT
        <span class="ot">self</span>.duration = <span class="ot">self</span>.expireTime/<span class="fl">2.0</span>
        <span class="ot">self</span>.counter = <span class="dv">0</span>
        <span class="ot">self</span>.pause = randint(<span class="dv">10</span>, <span class="dv">150</span>)
        
    <span class="kw">def</span> curveX(<span class="ot">self</span>, x):
        <span class="kw">return</span> x
    
    <span class="kw">def</span> curveY(<span class="ot">self</span>, y):
        <span class="kw">return</span> y
    
    <span class="kw">def</span> easing(<span class="ot">self</span>):
        <span class="ot">self</span>.counter += <span class="dv">1</span>
        <span class="ot">self</span>.fX = <span class="ot">self</span>.fY = (<span class="ot">self</span>.counter)/<span class="dt">float</span>(<span class="ot">self</span>.duration)
        <span class="ot">self</span>.fX = <span class="ot">self</span>.curveX(<span class="ot">self</span>.fX)
        <span class="ot">self</span>.fY = <span class="ot">self</span>.curveY(<span class="ot">self</span>.fY)
        <span class="ot">self</span>.x = (<span class="ot">self</span>.targetX * <span class="ot">self</span>.fX) + (<span class="ot">self</span>.origX * (<span class="fl">1.0</span> - <span class="ot">self</span>.fX))
        <span class="ot">self</span>.y = (<span class="ot">self</span>.targetY * <span class="ot">self</span>.fY) + (<span class="ot">self</span>.origY * (<span class="fl">1.0</span> - <span class="ot">self</span>.fY))

    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.expireTime -= <span class="dv">1</span>
        <span class="kw">if</span> <span class="ot">self</span>.expireTime &lt; <span class="dv">0</span>:
            <span class="ot">self</span>.pause -= <span class="dv">1</span>
            <span class="kw">if</span> <span class="ot">self</span>.pause &lt; <span class="dv">0</span>:
                <span class="ot">self</span>.reset()
    
    <span class="kw">def</span> display(<span class="ot">self</span>):
        <span class="co"># print(self.x, self.y)</span>
        image(<span class="ot">self</span>.im1, <span class="ot">self</span>.x, <span class="ot">self</span>.y)
    
    <span class="kw">def</span> reset(<span class="ot">self</span>):
        <span class="ot">self</span>.origX = randint(-<span class="dv">150</span>, width-tw)
        <span class="ot">self</span>.origY = -randint(<span class="dv">50</span>, <span class="dv">250</span>)
        <span class="ot">self</span>.targetX = randint(tw, width-tw)
        <span class="ot">self</span>.targetY = randint(tw, height-tw)
        <span class="ot">self</span>.expireTime = <span class="ot">self</span>.duration*<span class="fl">2.0</span>
        <span class="ot">self</span>.counter = <span class="dv">0</span>
        <span class="ot">self</span>.pause = randint(<span class="dv">10</span>, <span class="dv">150</span>)
        
<span class="kw">class</span> Ghost(PowerItem):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im1 = loadImage(<span class="st">&quot;ghost.png&quot;</span>)
    
    
    <span class="kw">def</span> curveY(<span class="ot">self</span>, y):
        <span class="kw">return</span> y**<span class="dv">5</span>

<span class="kw">class</span> Cupcake(PowerItem):
    
    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im1 = loadImage(<span class="st">&quot;cupcake.png&quot;</span>)
    
    <span class="kw">def</span> curveY(<span class="ot">self</span>, y):
        <span class="kw">return</span> <span class="dv">3</span>*sin(<span class="dv">3</span>*y)
    
            
<span class="kw">class</span> Star(<span class="dt">object</span>):
    
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, posX, posY, dia, speed):
        <span class="ot">self</span>.x = posX
        <span class="ot">self</span>.y = posY
        <span class="ot">self</span>.r = dia
        <span class="ot">self</span>.dy = speed
        <span class="ot">self</span>.a = <span class="dv">255</span> <span class="co"># Transparency</span>
    
    <span class="kw">def</span> move(<span class="ot">self</span>):
        <span class="ot">self</span>.outside = <span class="ot">False</span>
        <span class="ot">self</span>.y += <span class="ot">self</span>.dy
        <span class="kw">if</span> <span class="ot">self</span>.y &gt;= height:
            <span class="ot">self</span>.outside = <span class="ot">True</span>
            <span class="ot">self</span>.y = -<span class="dv">2</span>*<span class="ot">self</span>.r
            <span class="ot">self</span>.x = randint(<span class="dv">0</span>, width - <span class="dv">2</span>*<span class="ot">self</span>.r)
    
    <span class="kw">def</span> display(<span class="ot">self</span>):
        fill(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>, <span class="ot">self</span>.a)
        noStroke()
        ellipse(<span class="ot">self</span>.x, <span class="ot">self</span>.y, <span class="ot">self</span>.r, <span class="ot">self</span>.r)</code></pre>
<p>Und dann das eigentliche Hauptprogramm, das ebenfalls noch einmal an Umfang zugenommen hat:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> random <span class="ch">import</span> randint
<span class="ch">from</span> sprite <span class="ch">import</span> Skull, Smiley, Ghost, Cupcake, Star

w = <span class="dv">640</span>
h = <span class="dv">480</span>
tw = th = <span class="dv">36</span>
noSmileys = <span class="dv">10</span>
nobStars = <span class="dv">30</span>
nonStars = <span class="dv">15</span>
noGhost = <span class="dv">3</span>
noCupcakes = <span class="dv">5</span>
startgame = <span class="ot">True</span>
playgame = <span class="ot">False</span>
gameover = <span class="ot">False</span>

skull = Skull(w/<span class="dv">2</span>, <span class="dv">320</span>)
smiley = []
bStar = []
nStar = []
ghost = []
cupcake = []

<span class="kw">def</span> setup():
    <span class="kw">global</span> heart
    size(<span class="dv">640</span>, <span class="dv">480</span>)
    frameRate(<span class="dv">30</span>)
    loadData()
    skull.score = <span class="dv">0</span>
    skull.health = <span class="dv">5</span>
    skull.loadPics()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
        smiley[i].loadPics()
        smiley[i].dy = randint(<span class="dv">4</span>, <span class="dv">10</span>)
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(ghost)):
        ghost[i].loadPics()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(cupcake)):
        cupcake[i].loadPics()
    font = loadFont(<span class="st">&quot;ComicSansMS-32.vlw&quot;</span>)
    textFont(font, <span class="dv">32</span>)
    heart = loadImage(<span class="st">&quot;heart.png&quot;</span>)
    <span class="co"># noCursor()</span>
    <span class="co"># cursor(HAND)</span>
  
<span class="kw">def</span> draw():
    <span class="kw">global</span> heart
    background(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)
    fill(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>)
    text(<span class="st">&quot;Score: &quot;</span> + <span class="dt">str</span>(skull.score), <span class="dv">10</span>, <span class="dv">32</span>)
    <span class="kw">for</span> i in <span class="dt">range</span>(skull.health):
        image(heart, width - i*tw - tw - <span class="dv">2</span>, <span class="dv">2</span>)
    <span class="kw">if</span> startgame:
        startGame()
    <span class="kw">elif</span> playgame:
        playGame()
    <span class="kw">elif</span> gameover:
        gameOver()

<span class="kw">def</span> loadData():
    <span class="kw">for</span> i in <span class="dt">range</span>(noSmileys):
        smiley.append(Smiley(randint(<span class="dv">0</span>, width-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>)))
    <span class="kw">for</span> i in <span class="dt">range</span>(noGhost):
        ghost.append(Ghost(randint(-<span class="dv">150</span>, width-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>), randint(tw, width-tw), randint(tw, height-tw), <span class="dv">300</span>))
    <span class="kw">for</span> i in <span class="dt">range</span>(noCupcakes):
        cupcake.append(Cupcake(randint(-<span class="dv">150</span>, width-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>), randint(tw, width-tw), randint(tw, height-tw), <span class="dv">600</span>))
    <span class="kw">for</span> i in <span class="dt">range</span>(nobStars):
        bStar.append(Star(randint(<span class="dv">0</span>, width<span class="dv">-2</span>), randint(<span class="dv">2</span>, height<span class="dv">-2</span>), <span class="dv">1</span>, <span class="fl">0.1</span>))
    <span class="kw">for</span> i in <span class="dt">range</span>(nonStars):
        nStar.append(Star(randint(<span class="dv">0</span>, width<span class="dv">-4</span>), randint(<span class="dv">2</span>, height<span class="dv">-2</span>), randint(<span class="dv">2</span>, <span class="dv">3</span>), <span class="fl">0.2</span>))

<span class="kw">def</span> startGame():
    <span class="kw">global</span> startgame, playgame
    text(<span class="st">&quot;Klick to Play&quot;</span>, <span class="dv">200</span>, height/<span class="dv">2</span>)
    <span class="kw">if</span> mousePressed:
        startgame = <span class="ot">False</span>
        playgame = <span class="ot">True</span>
        
<span class="kw">def</span> playGame():
    <span class="kw">global</span> playgame, gameover
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(bStar)):
        bStar[i].move()
        bStar[i].display()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(nStar)):
        nStar[i].move()
        <span class="kw">if</span> (frameCount % randint(<span class="dv">15</span>, <span class="dv">30</span>)) &lt; randint(<span class="dv">1</span>, <span class="dv">15</span>):
            nStar[i].a = <span class="dv">120</span>
        <span class="kw">else</span>:
            nStar[i].a = <span class="dv">255</span>
        nStar[i].display()
    skull.move()
    <span class="kw">if</span> skull.health &lt; <span class="dv">0</span>:
        playgame = <span class="ot">False</span>
        gameover = <span class="ot">True</span> 
    skull.display()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
        smiley[i].move()
        <span class="kw">if</span> smiley[i].checkCollision(skull):
            skull.health -= <span class="dv">1</span>
            smiley[i].reset(randint(<span class="dv">0</span>, w-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>))
        <span class="kw">if</span> smiley[i].outside:
            skull.score += <span class="dv">1</span>
        smiley[i].display()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(ghost)):
        ghost[i].easing()
        ghost[i].move()
        <span class="kw">if</span> ghost[i].checkCollision(skull):
            <span class="kw">if</span> skull.health &lt; <span class="dv">5</span>:
                skull.health += <span class="dv">1</span>
                ghost[i].reset()
        ghost[i].display()
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(cupcake)):
        cupcake[i].easing()
        cupcake[i].move()
        <span class="kw">if</span> cupcake[i].checkCollision(skull):
            skull.health -= <span class="dv">1</span>
            cupcake[i].reset()
        cupcake[i].display()

<span class="kw">def</span> gameOver():
    <span class="kw">global</span> playgame, gameover
    text(<span class="st">&quot;Game Over!&quot;</span>, <span class="dv">200</span>, height/<span class="dv">2</span>)
    text(<span class="st">&quot;Klick to play again.&quot;</span>, <span class="dv">200</span>, <span class="dv">300</span>)
    <span class="kw">if</span> mousePressed:
        gameover = <span class="ot">False</span>
        <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(smiley)):
            smiley[i].reset(randint(<span class="dv">0</span>, w-tw), -randint(<span class="dv">50</span>, <span class="dv">250</span>))
        <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(ghost)):
            ghost[i].reset()
        <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dt">len</span>(cupcake)):
            cupcake[i].reset()
        playgame = <span class="ot">True</span>
        skull.health = <span class="dv">5</span>
        skull.score = <span class="dv">0</span>
        
<span class="kw">def</span> mousePressed():
    <span class="kw">global</span> playgame
    <span class="kw">if</span> playgame:
        saveFrame(<span class="st">&quot;frames/screenshot-####.png&quot;</span>)</code></pre>
<h3 id="screenshots">Screenshots</h3>
<p>Bei diesem Spiel ist es nahezu unm√∂glich, mit den Bordmitteln des Betriebssystems noch aussagef√§hige Screenshots wie den oben im Beitrag zu erstellen. Daher habe ich das mit Processing-eigenen Mitteln erledigt: Die Funktion <code>mousePressed()</code></p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> mousePressed():
    <span class="kw">global</span> playgame
    <span class="kw">if</span> playgame:
        saveFrame(<span class="st">&quot;frames/screenshot-####.png&quot;</span>)</code></pre>
<p>schie√üt jedes Mal, wenn die linke Maustaste gedr√ºckt wird, einen aktuellen Screenshot. Aus dem fertigen Spiel solltet Ihr diese Funktion nat√ºrlich wieder herausnehmen.</p>
<p>Das war es mit dem <em>Avoider Game</em>. Nat√ºrlich sind noch jede Menge Erweiterungen m√∂glich und auch die Gestaltung des Start- und des Game-Over-Bildschirms kann sicher noch versch√∂nert werden. Mir kam es aber darauf an, zu zeigen, wie in Processing.py mit einfachen Mitteln doch schnell ein ansprechendes Spiel programmiert werden kann. Alles weitere ist Eurer Phantasie √ºberlassen.</p>
<h3 id="nachtrag-avoider-game-stage-4a">Nachtrag: Avoider Game Stage 4a</h3>
<p>Ich konnte es nicht lassen, nachdem ich zwei N√§chte dar√ºber geschlafen hatte, mu√üte ich doch noch einmal an das Avoider Game heran. Die <em>Power Ups</em> und <em>Power Downs</em> sollten jeweils zwei unterschiedliche Bildchen zugeordnet bekommen. Erreicht habe ich das mit der Python-eigenen Zufallsfunktion <code>choice()</code> aus der <a href="https://docs.python.org/2/library/random.html">Random-Bibliothek</a>. So habe ich im Reiter <code>sprite.py</code> in der ersten Zeile <code>choice</code> importiert:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> random <span class="ch">import</span> randint, choice</code></pre>
<p>Und dann in der Klasse <code>Ghost</code> die Methode <code>loadPics()</code> wie folgt ge√§ndert:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im1 = loadImage(choice([<span class="st">&quot;ghost.png&quot;</span>, <span class="st">&quot;octo.png&quot;</span>]))</code></pre>
<p>In der Klasse <code>Cupcake</code> sieht die gleiche Methode nun so aus:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> loadPics(<span class="ot">self</span>):
        <span class="ot">self</span>.im1 = loadImage(choice([<span class="st">&quot;cupcake.png&quot;</span>, <span class="st">&quot;bier.png&quot;</span>]))</code></pre>
<p>Hier sind die Bildchen f√ºr diejenigen unter Euch, die auch diese (letzte) √Ñnderung nachprogrammieren wollen:</p>
<p><img src="images/octo.png" /> <img src="images/bier.png" /></p>
<p>Auch diese Bilder entstammen den freien (<a href="http://twitter.github.io/twemoji/">CC-BY</a>) <a href="https://github.com/twitter/twemoji">Twitter Emojis</a> <em>(Twemojis)</em>.</p>
<figure>
<img src="images/avoider4a.png" />
</figure>
<p>Ich habe leider keinen Screenshot hinbekommen, auf denen alle verwendeten Bildchen zu sehen sind. So m√º√üt Ihr mit obigem vorliebnehmen und mir glauben: Auch die Krake existiert!</p>
<h1 id="epilog">Epilog</h1>
<h1 id="anhang">Anhang</h1>
<h2 id="literaturverzeichnis">Literaturverzeichnis</h2>
<h2 id="index">Index</h2>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Ich habe das Bild testweise auch mal erst nach 240.000 Schritten herausschreiben lassen. Die Verz√∂gerung war kaum merkbar. Allerdings gab es auch nur noch einen geringen Unterschied zu dem Bild im Screenshot. Hier setzt die Aufl√∂sung des Ausgabefensters weiterem Erkenntnisgewinn Grenzen.<a href="#fnref1">‚Ü©</a></p></li>
<li id="fn2"><p>Und das schon vor langer Zeit, als der Monitor meines Rechners noch eine Aufl√∂sung von 640 x 480 Pixeln hatte. üòú<a href="#fnref2">‚Ü©</a></p></li>
<li id="fn3"><p>Stan Wagon: <em>Mathematica¬Æ in Aktion</em>, Heidelberg (Spektrum Akademischer Verlag) 1993<a href="#fnref3">‚Ü©</a></p></li>
<li id="fn4"><p>Temple Fay: <em>The Butterfly Curve</em>, American Math. Monthly, 96(5); 442-443<a href="#fnref4">‚Ü©</a></p></li>
<li id="fn5"><p>Clifford A. Pickover: <em>Mit den Augen des Computers. Phantastische Welten aus dem Geist der Maschine</em>, M√ºnchen (Markt&amp;Technik) 1992, S. 41ff.<a href="#fnref5">‚Ü©</a></p></li>
<li id="fn6"><p>Eine sehr sch√∂ne Einf√ºhrung in <a href="http://scienceblogs.de/astrodicticum-simplex/2017/01/20/sternengeschichten-folge-217-das-ungeloeste-problem-der-navier-stokes-gleichungen/">das ungel√∂ste Problem der Navier-Stokes-Gleichungen</a> gibt es von <em>Florian Freistetter</em> in der 217. Folge seiner <em>Sternengeschichten</em><a href="#fnref6">‚Ü©</a></p></li>
<li id="fn7"><p>Ich wei√ü nicht, ob je und wann Jython den Sprung auf Python 3 wagt. Dort ist jedenfalls von Hause aus (per Default) jeder String ein UTF-8-String, in meinen Augen ein wichtiger, aber auch der einzige Grund, auf Python 3 umzusteigen.<a href="#fnref7">‚Ü©</a></p></li>
<li id="fn8"><p>Ich will ehrlich sein: Die ¬ªGeschw√§tzigkeit¬´ von PyGame ist nicht nur dem hohen Alter der Bibliothek geschuldet, sie erlaubt eine gro√üe Vielseitigkeit und erspart dem Programmierer dann wieder bei komplizierten Dingen viel Schreibarbeit. So ist zum Beispiel die eingebaute <code>Sprite</code>-Klasse und die Kollisionspr√ºfung etwas, was ich in Processing.py von Hand programmieren mu√ü.<a href="#fnref8">‚Ü©</a></p></li>
<li id="fn9"><p>Ein bei Processing.py durchgehend zu beobachtender Konventionsbruch macht mich allerdings wuschig. W√§hrend die <a href="https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles">PEP8</a> f√ºr Variablennamen die Trennung durch Unterstriche empfiehlt (z.B. <code>mouse_x</code>) folgen die Programmierer der Beispielprogramme durchgehend der Java-Konvention des <em>camelCase</em> (<code>mouseX</code>). Ich habe mich erst einmal entschlossen, ebenfalls den <em>camelCase</em> zu nutzen, ob ich dabei aber bleiben werde, wei√ü ich noch nicht.<a href="#fnref9">‚Ü©</a></p></li>
<li id="fn10"><p>Daniel Scholz: <em><a href="https://www.amazon.de/Pixelspiele-Modellieren-Simulieren-zellul%C3%A4ren-Springer-Lehrbuch/dp/3642451306/ref=as_li_ss_tl?_encoding=UTF8&amp;qid=1504972682&amp;sr=8-1&amp;linkCode=ll1&amp;tag=derschockwell-21&amp;linkId=2f0f795b9536747199607226b165a5da">Pixelspiele</a>, Modellieren und Simulieren mit zellul√§ren Automaten</em>, Berlin - Heidelberg (Springer Spektrum) 2014, S. 19-25<a href="#fnref10">‚Ü©</a></p></li>
<li id="fn11"><p>Das ist keine Einschr√§nkung, denn der Fensterrand ist ja im Grunde auch nichts anderes als eine undurchdringliche Mauer und im Zweifelsfall macht man das Spielfeld einfach um die Mauerdicke gr√∂√üer.<a href="#fnref11">‚Ü©</a></p></li>
</ol>
</section>
</body>
</html>
